ephysiopy.common.binning
========================

.. py:module:: ephysiopy.common.binning


Classes
-------

.. autoapisummary::

   ephysiopy.common.binning.RateMap


Module Contents
---------------

.. py:class:: RateMap(PosCalcs, pos_weights = None, xyInCms = False, binsize = 3, smooth_sz = 5)

   Bases: :py:obj:`object`


   
   Bins up positional data (xy, head direction etc) and produces rate maps
   of the relevant kind. This is a generic class meant to be independent of
   any particular recording format.

   :param xy: The xy data as a 2 x n_samples numpy array.
   :type xy: np.ndarray
   :param hdir: The head direction data a 1 x n_samples numpy array.
   :type hdir: np.ndarray
   :param speed: Similar to hdir.
   :type speed: np.ndarray
   :param pos_weights: A 1 x n_samples numpy array used to weight a particular
                       position samples when binning data. For example, if there were 5
                       positions recorded and a cell spiked once in position 2 and 5 times
                       in position 3 and nothing anywhere else then pos_weights looks like:
                       [0 0 1 5 0]
                       In the case of binning up position this will be an array of mostly 1's
                       unless there are some positions you want excluded.
   :type pos_weights: np.ndarray
   :param ppm: Optional. Pixels per metre. Specifies how many camera pixels per metre so this,
               in combination with cmsPerBin, will determine how many bins there are
               in the rate map. Defaults to None.
   :type ppm: int
   :param xyInCms: Optional. Whether the positional data is in cms. Defaults to False.
   :type xyInCms: bool
   :param cmsPerBin: Optional. How many cms on a side each bin is in a rate map OR the number of
                     degrees per bin in the case of directional binning. Defaults to 3.
   :type cmsPerBin: int
   :param smooth_sz: Optional. The width of the smoothing kernel for smoothing rate maps. Defaults to 5.
   :type smooth_sz: int

   .. attribute:: xy

      the x-y position as 2 x n_samples

      :type: np.ndarray

   .. attribute:: dir

      directional bearing as n_samples vector. In degrees.

      :type: np.ndarray

   .. attribute:: speed

      speed as n_samples vector

      :type: np.ndarray

   .. attribute:: pos_times

      the times, in seconds, at which the position sample was recorded.

      :type: np.ndarray

   .. attribute:: inCms

      whether the data has been converted to cms or not.

      :type: bool

   .. attribute:: ppm

      the number of pixels (camera coordinates) per metre

      :type: int

   .. attribute:: var2Bin

      VariableToBin enum value. See ephysiopy.common.utils.VariableToBin

      :type: Enum

   .. attribute:: mapType

      MapType enum value. See ephysiopy.common.utils.MapType

      :type: Enum

   .. attribute:: binedges

      The edges of the binned data (can be n-dimensional)

      :type: tuple[np.ndarray,...]

   .. attribute:: x_lims

      The limits of the x data (min and max)

      :type: tuple[float,...]

   .. attribute:: y_lims

      The limits of the y data (min and max)

      :type: tuple[float,...]

   .. attribute:: pos_weights

      the weights assigned to position data when binning. n_samples vector

      :type: np.ndarray

   .. attribute:: spike_weights

      same as pos_weights but for spikes

      :type: np.ndarray

   .. attribute:: binsize

      the size of each bin (could be x-y or degrees or some other unit)

      :type: tuple

   .. attribute:: smooth_sz

      the size of the smoothing kernel for filtering rate maps

      :type: int

   .. attribute:: smoothingType

      the kind of smoothing to apply. 'boxcar' or 'gaussian'

      :type: str















   ..
       !! processed by numpydoc !!

   .. py:method:: _autoCorr2D(A, nodwell, tol = 1e-10)

      
      Performs a spatial autocorrelation on the array A

      :param A: Either 2 or 3D. In the former it is simply the binned up ratemap
                where the two dimensions correspond to x and y.
                If 3D then the first two dimensions are x
                and y and the third (last dimension) is 'stack' of ratemaps
      :type A: np.ndarray
      :param nodwell: A boolean array corresponding the bins in the ratemap that
                      weren't visited. See Notes.
      :type nodwell: np.ndarray
      :param tol: Values below this are set to zero to deal with v small values
                  thrown up by the fft. Default 1e-10
      :type tol: float, optional

      :returns: **sac** -- The spatial autocorrelation
      :rtype: np.ndarray

      .. rubric:: Notes

      The nodwell input can usually be generated by:

      >>> nodwell = ~np.isfinite(A)















      ..
          !! processed by numpydoc !!


   .. py:method:: _bin_data(var, bin_edges, weights)

      
      Bins data taking account of possible multi-dimensionality

      :param var: The variable to bin
      :type var: np.ndarray
      :param bin_edges: The edges of the data - see numpys histogramdd for more
      :type bin_edges: np.ndarray
      :param weights: The weights attributed to the samples in var
      :type weights: np.ndarray

      :returns: **binned_data** -- The binned variable and the bin edges
      :rtype: tuple[np.ndarray, ...]

      .. rubric:: Notes

      This breaks compatability with numpys histogramdd
      In the 2d histogram case below I swap the axes around so that x and y
      are binned in the 'normal' format i.e. so x appears horizontally and y
      vertically.
      Multi-binning issue is dealt with awkwardly through checking
      the dimensionality of the weights array.
      'normally' this would be 1 dim but when multiple clusters are being
      binned it will be 2 dim.
      In that case np.apply_along_axis functionality is applied.
      The spike weights in that case might be created like so:

      >>> spk_W = np.zeros(shape=[len(trial.nClusters), trial.npos])
      >>> for i, cluster in enumerate(trial.clusters):
      >>>             x1 = trial.getClusterIdx(cluster)
      >>>             spk_W[i, :] = np.bincount(x1, minlength=trial.npos)

      This can then be fed into this fcn something like so:

      >>> rng = np.array((np.ma.min(
          trial.POS.xy, 1).data, np.ma.max(rial.POS.xy, 1).data))
      >>> h = _bin_data(
          var=trial.POS.xy, bin_edges=np.array([64, 64]),
          weights=spk_W, rng=rng)

      Returned will be a tuple containing the binned up data and
      the bin edges for x and y (obv this will be the same for all
      entries of h)















      ..
          !! processed by numpydoc !!


   .. py:method:: _calc_bin_dims()


   .. py:method:: _calc_bin_edges(binsize = 3)

      
      Aims to get the right number of bins for the variable to be binned

      :param binsize: Optional. The number of cms per bin for XY OR degrees for DIR OR cm/s for SPEED. Defaults to 3.
      :type binsize: int | tuple

      :returns: **bins** -- each member an array of bin edges
      :rtype: tuple of np.ndarray















      ..
          !! processed by numpydoc !!


   .. py:method:: _calc_ego_angles(arena_shape = 'circle', xy_binsize = 2.5)

      
      Calculate the angles between the segments of the arena wall
      and the positions of the animal throughout the trial.

      :param arena_shape: the shape of the arena, 'circle' or 'square'.
      :type arena_shape: str
      :param xy_binsize: the binsize
      :type xy_binsize: float

      :returns: **angles** -- the angles as well as the arena x-y coordinates.
      :rtype: tuple[np.ndarray,...]

      .. rubric:: Notes

      Angles are in radians.















      ..
          !! processed by numpydoc !!


   .. py:method:: _crossCorr2D(A, B, A_nodwell, B_nodwell, tol = 1e-10)

      
      Performs crosscorrelations between the maps in two instances of BinnedData, A and B.

      :param A: instance of BinnedData
      :type A: BinnedData
      :param B: instance of BinnedData
      :type B: BinnedData
      :param A_nodwell: array with NaNs where there was no position sampled.
      :type A_nodwell: np.ndarray
      :param B_nodwell: array with NaNs where there was no position sampled.
      :type B_nodwell: np.ndarray
      :param tol: values below this are set to 0.
      :type tol: float

      :returns: **binned_data** -- the data in A with the maps replaced by autocorrelograms
      :rtype: BinnedData















      ..
          !! processed by numpydoc !!


   .. py:method:: _getXYLimits()

      
      Gets the min/max of the x/y data
















      ..
          !! processed by numpydoc !!


   .. py:method:: apply_mask(mask)


   .. py:method:: autoCorr2D(A, nodwell, tol = 1e-10)

      
      Performs autocorrelations on all the maps in an instance of BinnedData.

      :param A: The binned data
      :type A: BinnedData
      :param nodwell: An array with NaNs where there was no position sampled.
      :type nodwell: np.ndarray
      :param tol: Tolerance below which values are set to 0.
      :type tol: float

      :returns: **data** -- The data in A with the maps replaced by autocorrelograms
      :rtype: BinnedData















      ..
          !! processed by numpydoc !!


   .. py:method:: crossCorr2D(A, B, A_nodwell, B_nodwell, tol = 1e-10)

      
      Performs crosscorrelations between the maps in two instances of BinnedData, A and B.

      :param A: an instance of BinnedData
      :type A: BinnedData
      :param B: an instance of BinnedData
      :type B: BinnedData
      :param A_nodwell: an array with NaNs where there was no position sampled.
      :type A_nodwell: np.ndarray
      :param B_nodwell: an array with NaNs where there was no position sampled.
      :type B_nodwell: np.ndarray
      :param tol: values below this are set to 0.
      :type tol: float

      :returns: **binned_data** -- the data in A with the maps replaced by autocorrelograms
      :rtype: BinnedData















      ..
          !! processed by numpydoc !!


   .. py:method:: getAdaptiveMap(pos_binned, spk_binned, alpha=4)

      
      Produces a ratemap that has been adaptively binned according to the
      algorithm described in Skaggs et al., 1996) [R0be3bcd829c5-1]_.

      :param pos_binned: The binned positional data.
      :type pos_binned: np.ndarray
      :param spk_binned: The binned spikes
      :type spk_binned: np.ndarray
      :param alpha: A scaling parameter determing the amount of occupancy to aim at
                    in each bin. Defaults to 4. In the original paper this was set to 200.
                    This is 4 here as the pos data is binned in seconds (the original data was in pos
                    samples so this is a factor of 50 smaller than the original paper's value, given 50Hz sample rate)
      :type alpha: int, optional

      :returns: **adaptive_map** -- The adaptively binned spike and pos maps.
                Use this to generate Skaggs information measure
      :rtype: tuple of np.ndarray

      .. rubric:: Notes

      Positions with high rates mean proportionately less error than those
      with low rates, so this tries to even the playing field. This type
      of binning should be used for calculations of spatial info
      as with the skaggs_info method in the fieldcalcs class (see below)
      alpha is a scaling parameter that might need tweaking for different
      data sets.

      The data [are] first binned
      into a 64 X 64 grid of spatial locations, and then the firing rate
      at each point in this grid was calculated by expanding a circle
      around the point until the following criterion was met:

      Nspks > alpha / (Nocc^2 * r^2)

      where Nspks is the number of spikes emitted in a circle of radius
      r (in bins), Nocc is the number of occupancy samples, alpha is the
      scaling parameter
      The firing rate in the given bin is then calculated as:

      sample_rate * (Nspks / Nocc)

      .. rubric:: References

      .. [R0be3bcd829c5-1] W. E. Skaggs, B. L. McNaughton, K. M. Gothard & E. J. Markus
          "An Information-Theoretic Approach to Deciphering the Hippocampal
          Code"
          Neural Information Processing Systems, 1993.















      ..
          !! processed by numpydoc !!


   .. py:method:: get_disperion_map(spk_times, pos_times)

      
      Attempt to write a faster version of creating an overdispersion
      map. A cell will sometimes fire too much or too little on a given
      run through its receptive field. This function quantifies that.

      This shows the amount of 'observed' variance in spiking around
      the mean spiking in a bin...

      :param spk_times: a vector of spike times (in seconds)
      :type spk_times: np.ndarray
      :param pos_times: vector of position times (in seconds)
      :type pos_times: np.ndarray

      :returns: **dispersion_map** -- the overdispersion map in an instance of BinnedData
      :rtype: BinnedData















      ..
          !! processed by numpydoc !!


   .. py:method:: get_map(spk_weights, var_type=VariableToBin.XY, map_type=MapType.RATE, smoothing=True, **kwargs)

      
      Bins up the variable type var_type and returns a tuple of
      (rmap, binnedPositionDir) or
      (rmap, binnedPostionX, binnedPositionY)

      :param spk_weights: Shape equal to number of positions samples captured and consists of
                          position weights. For example, if there were 5 positions
                          recorded and a cell spiked once in position 2 and 5 times in
                          position 3 and nothing anywhere else then pos_weights looks
                          like: [0 0 1 5 0].
                          spk_weights can also be list-like where each entry in the list is a different set of
                          weights - these are enumerated through in a list comp in the ._bin_data function. In
                          this case the returned tuple will consist of a 2-tuple where the first entry is an
                          array of the ratemaps (binned_spk / binned_pos) and the second part is the binned pos data (as it's common to all
                          the spike weights)
      :type spk_weights: np.ndarray
      :param var_type: The variable to bin. See ephysiopy.common.utils for legal values.
      :type var_type: Variable2Bin
      :param map_type: The kind of map returned. See ephysiopy.common.utils for legal values.
      :type map_type: MapType
      :param smoothing: Optional. Smooth the data or not. Default True.
      :type smoothing: bool

      :returns: **binned_data** -- An instance of BinnedData containing the binned data, the bin edges, the variable binned and
                the map type. See ephysiopy.common.utils for details of the class.
      :rtype: BinnedData















      ..
          !! processed by numpydoc !!


   .. py:method:: tWinSAC(xy, spkIdx, ppm=365, winSize=10, pos_sample_rate=50, nbins=71, boxcar=5, Pthresh=100, downsampfreq=50)

      
      Performs a temporal windowed spatial autocorrelation.

      :param xy: The position data
      :type xy: np.ndarray
      :param spkIdx: The indices in xy where the cell fired
      :type spkIdx: np.ndarray
      :param ppm: Optional. The camera pixels per metre. Default 365
      :type ppm: int
      :param winSize: Optional. The window size for the temporal search
      :type winSize: int
      :param pos_sample_rate: Optional. The rate at which position was sampled. Default 50
      :type pos_sample_rate: int
      :param nbins: Optional. The number of bins for creating the resulting ratemap. Default 71
      :type nbins: int
      :param boxcar: Optional. The size of the smoothing kernel to smooth ratemaps. Default 5
      :type boxcar: int
      :param Pthresh: Optional. The cut-off for values in the ratemap; values < Pthresh become nans. Default 100
      :type Pthresh: int
      :param downsampfreq: Optional. How much to downsample. Default 50
      :type downsampfreq: int

      :returns: **H** -- the temporal windowed SAC
      :rtype: array_like















      ..
          !! processed by numpydoc !!


   .. py:attribute:: PosCalcs


   .. py:attribute:: _binedges
      :value: None



   .. py:attribute:: _binsize
      :value: 3



   .. py:attribute:: _binsize2d
      :value: None



   .. py:attribute:: _inCms
      :value: False



   .. py:attribute:: _mapType


   .. py:attribute:: _pos_time_splits
      :value: None



   .. py:attribute:: _pos_weights
      :value: None



   .. py:attribute:: _smooth_sz
      :value: 5



   .. py:attribute:: _smoothingType
      :value: 'gaussian'



   .. py:attribute:: _spike_weights
      :value: None



   .. py:attribute:: _var2Bin


   .. py:attribute:: _x_lims
      :value: None



   .. py:attribute:: _y_lims
      :value: None



   .. py:property:: binedges


   .. py:property:: binsize


   .. py:property:: dir


   .. py:property:: inCms


   .. py:property:: mapType


   .. py:property:: pos_times


   .. py:property:: pos_weights

      
      The 'weights' used as an argument to np.histogram* for binning up
      position
      Mostly this is just an array of 1's equal to the length of the pos
      data, but usefully can be adjusted when masking data in the trial
      by
















      ..
          !! processed by numpydoc !!


   .. py:property:: ppm


   .. py:property:: smooth_sz


   .. py:property:: smoothingType


   .. py:property:: speed


   .. py:property:: spike_weights


   .. py:property:: var2Bin


   .. py:attribute:: whenToSmooth
      :value: 'before'



   .. py:property:: x_lims


   .. py:property:: xy


   .. py:property:: y_lims


