import functools
from inspect import getfullargspec
import warnings
from collections.abc import Callable

import copy

import matplotlib
import matplotlib.pylab as plt
import matplotlib.transforms as transforms
import numpy as np
from scipy.signal import hilbert
from matplotlib.patches import Rectangle
from matplotlib.collections import PatchCollection, QuadMesh
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.projections import get_projection_class

from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import seaborn as sns

from ephysiopy.axona import tintcolours as tcols
from ephysiopy.common.spikecalcs import xcorr, SpikeCalcsGeneric
from ephysiopy.common.binning import RateMap
from ephysiopy.common.utils import (
    clean_kwargs,
    BinnedData,
    rect,
)
from ephysiopy.common import fieldcalcs as fc

"""
A decorator class that accepts arguments. This one allows us to save the returned
matplotlib Axis object to a location and name specified by the user in the decorated
function
"""


def saveFigure(func):
    """
    Decorator to save a plot generated by a function.

    Parameters
    ----------
    func : callable
        The function that generates the plot.

    Returns
    -------
    callable
        The wrapped function that saves the plot if 'save_as' is provided in kwargs.
    """

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        fig = func(*args, **kwargs)
        if fig is not None:
            if "save_as" in kwargs.keys():
                plt.savefig(kwargs["save_as"])
        return fig

    return wrapper


def stripAxes(func):
    """
    Decorator to strip the axes from a plot generated by a function.

    Parameters
    ----------
    func : callable
        The function that generates the plot.

    Returns
    -------
    callable
        The wrapped function that strips the axes from the plot.
    """

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        ax = func(*args, **kwargs)
        if ax is not None:
            plt.setp(ax.get_xticklabels(), visible=False)
            plt.setp(ax.get_yticklabels(), visible=False)
            ax.axes.get_xaxis().set_visible(False)
            ax.axes.get_yaxis().set_visible(False)
            if "polar" in ax.name:
                ax.set_rticks([])
            else:
                ax.spines["right"].set_visible(False)
                ax.spines["top"].set_visible(False)
                ax.spines["bottom"].set_visible(False)
                ax.spines["left"].set_visible(False)
        return ax

    return wrapper


def addClusterChannelToAxes(func):
    """
    Decorator to add cluster and channel information to the axes of a plot.

    Parameters
    ----------
    func : callable
        The function that generates the plot.

    Returns
    -------
    callable
        The wrapped function that adds cluster and channel information to the axes.
    """
    argspec = getfullargspec(func)
    try:
        argindex = argspec.args.index("cluster")
    except ValueError:
        pass

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        ax = func(*args, **kwargs)
        if ax is not None:
            if "add_cluster" in kwargs.keys():
                if kwargs["add_cluster"] is True:
                    if "cluster" in argspec.args:
                        ax.text(
                            0.5,
                            1.2,
                            str(args[argindex]),
                            transform=ax.transAxes,
                            fontsize=20,
                            ha="center",
                        )
        return ax

    return wrapper


def _add_colour_wheel(ax: plt.Axes, fig: plt.Figure) -> plt.Axes:
    """
    Adds a colour wheel to the axes

    Parameters
    ----------
    ax : plt.Axes
        The axes to add the colour wheel to.
    fig : plt.Figure
        The figure containing the axes.

    Returns
    -------
    plt.Axes
        The axes containing the colour wheel.
    """
    ax_col = inset_axes(
        ax,
        width="100%",
        height="100%",
        bbox_to_anchor=(0.75, 0.75, 0.15, 0.15),
        axes_class=get_projection_class("polar"),
        bbox_transform=fig.transFigure,
    )
    ax_col.set_theta_zero_location("N")
    theta = np.linspace(0, 2 * np.pi, 1000)
    phi = np.linspace(0, 1, 2)
    X, Y = np.meshgrid(phi, theta)
    norm = matplotlib.colors.Normalize(0, 2 * np.pi)
    col_map = sns.color_palette("hls", as_cmap=True)
    ax_col.pcolormesh(theta, phi, Y.T, norm=norm, cmap=col_map)
    ax_col.set_yticklabels([])
    ax_col.spines["polar"].set_visible(False)
    ax_col.set_thetagrids([0, 90])
    return ax_col


jet_cmap = matplotlib.colormaps["jet"]
grey_cmap = matplotlib.colormaps["gray_r"]

# TODO: i think i want to separate out the plotting functions from the FigureMaker class
# and put them in a separate module. This will make it easier to test them and also
# make the code more modular and easier to read. I will also need to update the
# FigureMaker class to use the new plotting functions
# Axes preparation could be split out here or in the FigureMaker class
# functions using pcolormesh are:
# plot_rate_map
# plot_eb_map
# plot_eb_spikes (this is more complex as it uses a PatchCollection)
# plot_sac (again, complex as it has lots of annotations done)
# plot_speed_v_hd
# plot_theta_vs_running_speed


def _plot_multiple_clusters(
    func: Callable[..., plt.Figure], rmap: BinnedData, *args, **kwargs
) -> plt.Figure:
    """
    Plots multiple clusters.

    Parameters
    ----------
    func : function
        The function to apply to each cluster.
    rmap : BinnedData
        The rate map.
    **kwargs : dict
        Additional keyword arguments for the function.

    Returns
    -------
    matplotlib.figure.Figure
        The figure containing the plots.
    """
    fig = plt.figure()
    nrows = ncols = 1

    try:
        nrows = int(np.ceil((np.sqrt(len(rmap.binned_data)))))
        ncols = int(np.floor((np.sqrt(len(rmap.binned_data)))))
    except AttributeError:  # when rmap is not a BinnedData object
        nrows = int(np.ceil((np.sqrt(len(rmap)))))
        ncols = int(np.floor((np.sqrt(len(rmap)))))

    proj = kwargs.pop("projection", None)
    equal_axes = kwargs.pop("equal_axes", False)
    func2 = kwargs.pop("func2", None)

    for i, imap in enumerate(rmap):
        ax = fig.add_subplot(nrows, ncols, i + 1, projection=proj)
        # copy kwargs so that we don't modify the original
        kws = kwargs.copy()
        if "c" in kwargs.keys():
            kws["c"] = kwargs["c"][i]
        if func2:
            func2(imap, ax=ax, **kws)
        ax = func(imap, ax=ax, **kws)

        if equal_axes:
            ax.set_aspect("equal")
    return fig


@addClusterChannelToAxes
@stripAxes
def _plot_pcolormesh(rmap: BinnedData, ax: plt.Axes, **kwargs) -> plt.Axes:
    vmax = np.nanmax(np.ravel(rmap.binned_data))
    equal_axes = kwargs.pop("equal_axes", False)
    cmap = kwargs.pop("cmap", "viridis")  # matplotlib default
    kwargs = clean_kwargs(plt.pcolormesh, kwargs)
    ax.pcolormesh(
        rmap.bin_edges[1],
        rmap.bin_edges[0],
        rmap.binned_data[0],
        edgecolors="face",
        vmax=vmax,
        cmap=cmap,
        shading="auto",
        **kwargs,
    )
    if equal_axes:
        ax.set_aspect(True)
    return ax


@addClusterChannelToAxes
@stripAxes
def _plot_patch_collection(xy: np.ndarray, ax: plt.Axes, **kwargs) -> plt.Axes:
    """
    Plot a patch collection

    Parameters
    ----------
    xy : np.ndarray
        shape is [2  x m], where to put the rectangles

    **kwargs:
        ms - marker size for the rectangles
        c - array-like list or float of colour(s) for each rectangle

    Returns
    -------
    plt.Axes
        the axes into which the patches were plotted
    """
    rect_size = kwargs.pop("ms", 1)
    col = kwargs.pop("c", tcols.colours[1])
    col = np.array(col)
    if len(col) == 3:  # a singular value
        col = [col for _ in range(xy.shape[1])]

    rects = [
        Rectangle(
            _xy,
            width=rect_size,
            height=rect_size,
            clip_box=ax.bbox,
            facecolor=_col.T,
            rasterized=True,
            **kwargs,
        )
        for _xy, _col in zip(xy.T, col)
    ]
    ax.add_collection(PatchCollection(rects, match_original=True))
    return ax


class FigureMaker(object):
    """
    A mixin class for TrialInterface that deals solely with producing graphical output.

    """

    def __init__(self):
        """
        Initializes the FigureMaker object.
        """
        self.PosCalcs = None

        """
        Initializes the FigureMaker object with data from PosCalcs.
        """
        if self.PosCalcs is not None:
            self.RateMap = RateMap(self.PosCalcs)
            self.npos = self.PosCalcs.xy.shape[1]

    @stripAxes
    def _plot_path(self, A: BinnedData, ax: plt.Axes, **kwargs) -> plt.Axes:
        ax.plot(
            self.PosCalcs.xy[0, :],
            self.PosCalcs.xy[1, :],
            color=tcols.colours[0],
            zorder=1,
        )
        return ax

    def plot_rate_map(
        self, cluster: int | list, channel: int | list, **kwargs
    ) -> plt.Figure:
        """
        Plots the rate map for the specified cluster(s) and channel.

        Parameters
        ----------
        cluster : int or list
            The cluster(s) to get the rate map for.
        channel : int or list
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.
            ax : plt.Axes, optional
                The axes to plot on. If None, new axes are created.
            separate_plots : bool, optional
                If True, each cluster will be plotted on a separate plot. Defaults to False.

        Returns
        -------
        plt.Axes
            The axes containing the rate map plot.
        """
        rmap = self.get_rate_map(cluster, channel, **kwargs)

        ax = kwargs.pop("ax", None)
        separate_plots = kwargs.pop("separate_plots", False)
        kwargs["cmap"] = jet_cmap

        kwargs["equal_axes"] = kwargs.pop("equal_axes", True)
        # multiple clusters have been passed in so plot either in
        # one window  or one per cluster
        if len(rmap.binned_data) > 1 and separate_plots:
            for imap in rmap:
                fig = plt.figure()
                ax = fig.add_subplot(111)
                ax = _plot_pcolormesh(imap, ax, **kwargs)
                ax.set_aspect("equal")
            return fig
        elif len(rmap.binned_data) > 1 and not separate_plots:
            return _plot_multiple_clusters(_plot_pcolormesh, rmap, **kwargs)

        # plot a single cluster in an individual window
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111)

        kwargs = clean_kwargs(plt.pcolormesh, kwargs)
        ax = _plot_pcolormesh(rmap, ax, **kwargs)
        ax.set_aspect("equal")
        return fig

    @saveFigure
    def plot_hd_map(self, cluster: int, channel: int, **kwargs) -> plt.Axes:
        """
        Gets the head direction map for the specified cluster(s) and channel.

        Parameters
        ----------
        cluster : int
            The cluster(s) to get the head direction map for.
        channel : int
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes containing the head direction map plot.
        """
        rmap = self.get_hd_map(cluster, channel, **kwargs)

        @stripAxes
        def _plot_single_map(rmap: BinnedData, ax: plt.Axes, **kwargs):
            fill = kwargs.pop("fill", False)
            add_guides = kwargs.pop("add_guides", False)
            add_mrv = kwargs.pop("add_mrv", False)

            ax.set_theta_zero_location("N")
            theta = np.deg2rad(rmap.bin_edges[0])
            r = rmap.binned_data[0]
            r = np.insert(r, -1, r[0])
            ax.plot(theta, r)
            if fill:
                ax.fill(theta, r, alpha=0.5)
            ax.set_aspect("equal")

            if add_guides:
                ax.set_rgrids([])

            hasData = np.any(r > 0)

            # See if we should add the mean resultant vector (mrv)
            if add_mrv and hasData:
                veclen = fc.get_mean_resultant_length(rmap.binned_data[0])
                th = fc.get_mean_resultant_angle(rmap.binned_data[0])
                ax.plot(
                    [0, th],
                    [
                        0,
                        veclen
                        * np.max(rmap.binned_data[0])
                        * self.PosCalcs.sample_rate,
                    ],
                    "r",
                )
            if "polar" in ax.name:
                ax.set_thetagrids([0, 90, 180, 270])

            return ax

        ax = kwargs.pop("ax", None)
        separate_plots = kwargs.pop("separate_plots", False)
        kwargs["projection"] = "polar"
        # multiple clusters have been passed in so plot either in
        # one window  or one per cluster
        if len(rmap.binned_data) > 1 and separate_plots:
            # kwargs = clean_kwargs(plt.pcolormesh, kwargs)
            for imap in rmap:
                fig = plt.figure()
                ax = fig.add_subplot(111, projection="polar", **kwargs)
                _plot_single_map(imap, ax, **kwargs)
            return ax
        elif len(rmap.binned_data) > 1 and not separate_plots:
            return _plot_multiple_clusters(_plot_single_map, rmap, **kwargs)

        # plot a single cluster in an individual window
        if ax is None:
            fig = plt.figure()
            kwargs = clean_kwargs(fig.add_subplot, kwargs)
            ax = fig.add_subplot(111, projection="polar", **kwargs)

        return _plot_single_map(rmap, ax, **kwargs)

    def plot_spike_path(self, cluster=None, channel=None, **kwargs) -> plt.Figure:
        """
        Plots the spikes on the path for the specified cluster(s) and channel.

        Parameters
        ----------
        cluster : int or None
            The cluster(s) to get the spike path for.
        channel : int or None
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes containing the spike path plot.

        """
        if not self.RateMap:
            self.initialise()

        ax = kwargs.pop("ax", None)
        separate_plots = kwargs.pop("separate_plots", False)
        # multiple clusters have been passed in so plot either in
        # one window  or one per cluster
        if cluster or channel is not None:
            pos_idx = self._get_spike_pos_idx(cluster, channel)
            spike_locations = [self.PosCalcs.xy[:, idx] for idx in pos_idx]

            if len(spike_locations):
                kwargs["equal_axes"] = kwargs.pop("equal_axes", True)
                if separate_plots:
                    for idx in spike_locations:
                        fig = plt.figure()
                        ax = fig.add_subplot(111)
                        ax = self._plot_path(idx, ax)
                        _plot_patch_collection(idx, ax, **kwargs)
                    return fig
                else:
                    kwargs["func2"] = self._plot_path
                    return _plot_multiple_clusters(
                        _plot_patch_collection, spike_locations, **kwargs
                    )

        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111)

        if cluster or channel is None:
            ax = self._plot_path(None, ax)
            return fig

        ax = self._plot_path(pos_idx, ax)
        spike_locations = self.PosCalcs.xy[:, pos_idx[0]]
        ax = _plot_patch_collection(spike_locations, ax, **kwargs)

        return fig

    def plot_eb_map(self, cluster: int, channel: int, **kwargs) -> plt.Axes:
        """
        Plots the ego-centric boundary map for the specified cluster(s) and
        channel.

        Parameters
        ----------
        cluster : int
            The cluster(s) to get the ego-centric boundary map for.
        channel : int
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes containing the ego-centric boundary map plot.
        """
        rmap = self.get_eb_map(cluster, channel, range=None, **kwargs)

        ax = kwargs.pop("ax", None)
        separate_plots = kwargs.pop("separate_plots", False)

        # multiple clusters have been passed in so plot either in
        # one window  or one per cluster
        if len(rmap.binned_data) > 1 and separate_plots:
            # kwargs = clean_kwargs(plt.pcolormesh, kwargs)
            for imap in rmap:
                fig = plt.figure()
                ax = fig.add_subplot(111, projection="polar", **kwargs)
                ax = _plot_pcolormesh(imap, ax, **kwargs)
            return fig
        elif len(rmap.binned_data) > 1 and not separate_plots:
            kwargs["projection"] = "polar"
            return _plot_multiple_clusters(_plot_pcolormesh, rmap, **kwargs)

        # plot a single cluster in an individual window
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="polar", **kwargs)

        kwargs = clean_kwargs(plt.pcolormesh, kwargs)
        ax = _plot_pcolormesh(rmap, ax, **kwargs)
        return fig

    @saveFigure
    def plot_eb_spikes(self, cluster: int, channel: int, **kwargs) -> plt.Axes:
        """
        Plots the ego-centric boundary spikes for the specified cluster(s)
        and channel.

        Parameters
        ----------
        cluster : int
            The cluster(s) to get the ego-centric boundary spikes for.
        channel : int
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes containing the ego-centric boundary spikes plot.
        """
        if not self.RateMap:
            self.initialise()

        ax = kwargs.pop("ax", None)
        separate_plots = kwargs.get("separate_plots", False)

        pos_idx = self._get_spike_pos_idx(cluster, channel)
        spike_locations = [self.PosCalcs.xy[:, idx] for idx in pos_idx]
        # Parse kwargs
        num_dir_bins = kwargs.get("dir_bins", 60)
        # TODO: add colour wheel?
        add_colour_wheel = kwargs.get("add_colour_wheel", False)
        dir_colours = np.array(sns.color_palette("hls", num_dir_bins))
        # Process dirrectional data into colours for pathces
        indices = [
            np.floor(self.RateMap.dir[idx] / (360 / num_dir_bins)).astype(int)
            for idx in pos_idx
        ]
        idx_of_dir_to_colour = [dir_colours[idx, :] for idx in indices]

        kwargs["zorder"] = 2

        if len(spike_locations):
            kwargs["equal_axes"] = kwargs.pop("equal_axes", True)
            kwargs["c"] = idx_of_dir_to_colour
            if separate_plots:
                for idx in spike_locations:
                    fig = plt.figure()
                    ax = fig.add_subplot(111)
                    ax = self._plot_path([], ax)
                    _plot_patch_collection(idx, ax, **kwargs)
                return fig
            else:
                kwargs["func2"] = self._plot_path
                return _plot_multiple_clusters(
                    _plot_patch_collection, spike_locations, **kwargs
                )

        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111)
        ax.set_aspect("equal")

        ax = self._plot_path([], ax)
        ax = _plot_patch_collection(spike_locations[0], ax, **kwargs)

        if add_colour_wheel:
            ax = _add_colour_wheel(ax, fig)

        return fig

    @saveFigure
    def plot_sac(self, cluster: int, channel: int, **kwargs) -> plt.Axes:
        """
        Plots the spatial autocorrelation for the specified cluster(s) and channel.

        Parameters
        ----------
        cluster : int
            The cluster(s) to get the spatial autocorrelation for.
        channel : int
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes containing the spatial autocorrelation plot.
        """

        @addClusterChannelToAxes
        @stripAxes
        def _plot_single_sac(sac: BinnedData, ax: plt.Axes, **kwargs) -> plt.Axes:
            kwargs["cmap"] = grey_cmap
            ax = _plot_pcolormesh(sac, ax, **kwargs)
            measures = fc.grid_field_props(sac)
            Am = copy.deepcopy(sac)
            Am.binned_data[0][~measures["dist_to_centre"]] = np.nan
            Am.binned_data[0] = np.ma.masked_invalid(
                np.atleast_2d(Am.binned_data[0]))
            kwargs["cmap"] = jet_cmap

            cmap = copy.copy(jet_cmap)
            cmap.set_bad("w", 0)

            ax = _plot_pcolormesh(Am, ax, **kwargs)
            _y = 0, 0
            _x = 0, sac.bin_edges[0][-1]
            ax.plot(_x, _y, c="g")
            mag = measures["scale"] * 0.75
            th = np.linspace(0, measures["orientation"], 50)

            [x, y] = rect(mag, th, deg=1)
            # angle subtended by orientation
            ax.plot(x, -y, c="r")
            # plot lines from centre to peaks above middle
            for p in measures["closest_peak_coords"]:
                if p[0] <= measures["dist_to_centre"].shape[0] / 2:
                    ax.plot((0, p[1]), (0, p[0]), "k")
            ax.invert_yaxis()
            all_ax = ax.axes
            all_ax.set_aspect("equal")

            return ax

        sac = self.get_grid_map(cluster, channel)
        ax = kwargs.pop("ax", None)
        separate_plots = kwargs.pop("separate_plots", False)

        if len(sac.binned_data) > 1 and separate_plots:
            for imap in sac:
                fig = plt.figure()
                ax = fig.add_subplot(111)
                ax = _plot_single_sac(imap, ax, **kwargs)
            return fig
        elif len(sac.binned_data) > 1 and not separate_plots:
            return _plot_multiple_clusters(_plot_single_sac, sac, **kwargs)

        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111)

        ax = _plot_single_sac(sac, ax, **kwargs)

        return fig

    @saveFigure
    def plot_speed_v_rate(self, cluster: int, channel: int, **kwargs) -> plt.Axes:
        """
        Plots the speed versus rate plot for the specified cluster(s) and
        channel.

        By default the distribution of speeds will be plotted as a twin
        axis. To disable set add_speed_hist = False

        Parameters
        ----------
        cluster : int
            The cluster(s) to get the speed versus rate plot for.
        channel : int
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes containing the speed versus rate plot.
        """
        add_speed_hist = kwargs.pop("add_speed_hist", True)
        rmap = self.get_speed_v_rate_map(cluster, channel, **kwargs)
        # rmap is linear
        ax = kwargs.pop("ax", None)
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111)
        kwargs = clean_kwargs(plt.plot, kwargs)
        ax_colour = "cornflowerblue"
        ax.plot(rmap.bin_edges[0][:-1],
                rmap.binned_data[0], color=ax_colour, **kwargs)
        ax.set_xlabel("Speed (cm/s)")
        ax.set_ylabel("Rate (Hz)")
        if add_speed_hist:
            ax.spines["left"].set_color(ax_colour)
            ax.tick_params(axis="y", colors=ax_colour)
            ax.yaxis.label.set_color(ax_colour)
            ax2 = ax.twinx()
            ax2_colour = "grey"
            pos_weights = np.ones_like(self.PosCalcs.speed) * (
                1 / self.PosCalcs.sample_rate
            )
            speed_bincounts = np.bincount(
                np.digitize(self.PosCalcs.speed,
                            rmap.bin_edges[0], right=True),
                weights=pos_weights,
            )
            ax2.bar(
                rmap.bin_edges[0],
                speed_bincounts,
                alpha=0.5,
                width=np.mean(np.diff(rmap.bin_edges[0])),
                ec="grey",
                fc="grey",
            )
            ax2.set_ylabel("Duration (s)")
            ax2.spines["right"].set_color(ax2_colour)
            ax2.tick_params(axis="y", colors=ax2_colour)
            ax2.yaxis.label.set_color(ax2_colour)

        return ax

    @saveFigure
    def plot_speed_v_hd(self, cluster: int, channel: int, **kwargs) -> plt.Axes:
        """
        Plots the speed versus head direction plot for the specified cluster(s) and channel.

        Parameters
        ----------
        cluster : int
            The cluster(s) to get the speed versus head direction plot for.
        channel : int
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes containing the speed versus head direction plot.
        """
        rmap = self.get_speed_v_hd_map(cluster, channel, **kwargs)
        im = np.ma.MaskedArray(
            rmap.binned_data[0], np.isnan(rmap.binned_data[0]))
        # mask low rates...
        # im = np.ma.masked_where(im <= 1, im)
        # ... and where less than 0.5% of data is accounted for
        y, x = np.meshgrid(rmap.bin_edges[0], rmap.bin_edges[1], indexing="ij")
        vmax = np.nanmax(np.ravel(im))
        ax = kwargs.pop("ax", None)
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111)
        ax.pcolormesh(
            x, y, im, cmap=jet_cmap, edgecolors="face", vmax=vmax, shading="auto"
        )
        ax.set_xticks(
            [90, 180, 270], labels=["90", "180", "270"], fontweight="normal", size=6
        )
        ax.set_yticks(
            [10, 20, 30, 40],
            labels=["10", "20", "30", "40"],
            fontweight="normal",
            size=6,
        )
        ax.set_xlabel("Heading", fontweight="normal", size=6)
        return ax

    @saveFigure
    @addClusterChannelToAxes
    def plot_acorr(self, cluster: int, channel: int, **kwargs) -> plt.Axes:
        """
        Plots the autocorrelogram for the specified cluster(s) and channel.

        Parameters
        ----------
        cluster : int
            The cluster(s) to get the autocorrelogram for.
        channel : int
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes containing the autocorrelogram plot.
        """

        ts = self.get_spike_times(cluster, channel)
        ax = self._getXCorrPlot(ts, **kwargs)
        return ax

    @saveFigure
    def plot_xcorr(
        self, cluster_a: int, channel_a: int, cluster_b: int, channel_b: int, **kwargs
    ) -> plt.Axes:
        """
        Plots the temporal cross-correlogram between cluster_a and cluster_b

        Parameters
        ----------
        cluster_a : int
            first cluster
        channel_a :int
            first channel
        cluster_b : int
            second cluster
        channel_b : int
            second channel

        Returns
        -------
        plt.Axes
            The axes containing the cross-correlogram plot
        """
        if "strip_axes" in kwargs.keys():
            strip_axes = kwargs.pop("strip_axes")
        else:
            strip_axes = False
        ax = kwargs.get("ax", None)
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111)
        if "binsize" in kwargs.keys():
            binsize = kwargs["binsize"]
        else:
            binsize = 0.001
        if "Trange" in kwargs.keys():
            xrange = kwargs.pop("Trange")
        else:
            xrange = [-0.5, 0.5]

        a_times = self.get_spike_times(cluster_a, channel_a)
        b_times = self.get_spike_times(cluster_b, channel_b)
        xcorr_binned = xcorr(a_times, b_times, Trange=xrange, binsize=binsize)
        c = xcorr_binned.binned_data[0]
        b = xcorr_binned.bin_edges[0]
        ax.bar(b[:-1], c, width=binsize, color="k", align="edge", zorder=3)
        ax.set_xlim(xrange)
        ax.set_xticks((xrange[0], 0, xrange[1]))
        ax.set_xticklabels("")
        ax.tick_params(
            axis="both", which="both", left=False, right=False, bottom=False, top=False
        )
        ax.set_yticklabels("")
        ax.xaxis.set_ticks_position("bottom")
        if strip_axes:
            return stripAxes(ax)
        axtrans = transforms.blended_transform_factory(
            ax.transData, ax.transAxes)
        ax.vlines(0, ymin=0, ymax=1, colors="lightgrey",
                  transform=axtrans, zorder=1)
        return ax

    @saveFigure
    @addClusterChannelToAxes
    def plot_raster(self, cluster: int, channel: int, **kwargs) -> plt.Axes:
        """
        Plots the raster plot for the specified cluster(s) and channel.

        Parameters
        ----------
        cluster : int
            The cluster(s) to get the raster plot for.
        channel : int
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function, including:
            dt : list
                The range in seconds to plot data over either side of the TTL pulse.
            seconds_per_bin : float
                The number of seconds per bin.

        Returns
        -------
        plt.Axes
            The axes containing the raster plot.
        """
        ts = self.get_spike_times(cluster, channel)
        ax = self._getRasterPlot(ts, cluster=cluster, **kwargs)
        return ax

    @saveFigure
    def plot_power_spectrum(self, **kwargs) -> plt.Axes:
        """
        Plots the power spectrum.

        Parameters
        ----------
        **kwargs
            Additional keyword arguments passed to _getPowerSpectrumPlot
        """
        p = self.EEGCalcs.calcEEGPowerSpectrum()
        ax = self._getPowerSpectrumPlot(p[0], p[1], p[2], p[3], p[4], **kwargs)
        return ax

    @saveFigure
    def plot_theta_vs_running_speed(self, **kwargs) -> QuadMesh:
        """
        Plots theta frequency versus running speed.

        Parameters
        ----------
        **kwargs : dict
            Additional keyword arguments for the function, including:
            low_theta : float
                The lower bound of the theta frequency range (default is 6).
            high_theta : float
                The upper bound of the theta frequency range (default is 12).
            low_speed : float
                The lower bound of the running speed range (default is 2).
            high_speed : float
                The upper bound of the running speed range (default is 50).

        Returns
        -------
        QuadMesh
            The QuadMesh object containing the plot.
        """
        low_theta = kwargs.pop("low_theta", 6)
        high_theta = kwargs.pop("high_theta", 12)
        low_speed = kwargs.pop("low_speed", 2)
        high_speed = kwargs.pop("high_speed", 50)
        theta_filtered_eeg = self.EEGCalcs.butterFilter(low_theta, high_theta)
        hilbert_eeg = hilbert(theta_filtered_eeg)
        inst_freq = (
            self.EEGCalcs.fs / (2 * np.pi) *
            np.diff(np.unwrap(np.angle(hilbert_eeg)))
        )
        inst_freq = np.insert(inst_freq, -1, inst_freq[-1])
        eeg_times = np.arange(0, len(self.EEGCalcs.sig)) / self.EEGCalcs.fs
        pos_times = self.PosCalcs.xyTS
        idx = np.searchsorted(pos_times, eeg_times)
        idx[idx >= len(pos_times)] = len(pos_times) - 1
        eeg_speed = self.PosCalcs.speed[idx]
        h, edges = np.histogramdd(
            [inst_freq, eeg_speed],
            bins=(
                np.arange(low_theta, high_theta, 0.5),
                np.arange(low_speed, high_speed, 2),
            ),
        )
        ax = plt.pcolormesh(edges[1], edges[0], h,
                            cmap=jet_cmap, edgecolors="face")
        return ax

    @saveFigure
    def plot_clusters_theta_phase(
        self, cluster: int, channel: int, **kwargs
    ) -> plt.Axes:
        """
        Plots the theta phase for the specified cluster and channel.

        Parameters
        ----------
        cluster : int
            The cluster to get the theta phase for.
        channel : int
            The channel number.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes containing the theta phase plot.
        """

        from ephysiopy.common.rhythmicity import LFPOscillations

        ax = kwargs.pop("ax", None)
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="polar")
        if "polar" not in ax.name:
            raise ValueError("Need a polar axis")
        L = LFPOscillations(self.EEGCalcs.sig, self.EEGCalcs.fs)
        ts = self.get_spike_times(cluster, channel)
        phase, x, y = L.get_theta_phase(ts, **kwargs)
        ax.hist(phase, density=True, bins=36)
        ax.plot(x, y, linewidth=1, color="red", zorder=3)
        # add lines around the edge of the polar plot to show spiking locations
        y_lims = ax.get_ylim()
        line_start = y_lims[1] / 1.01
        ax.vlines(phase, ymin=line_start, ymax=y_lims[1] * 1.15, colors="k")
        ax.set_ylim(y_lims[0], y_lims[1] * 1.15)
        ax.set_thetagrids([])
        ax.set_rgrids([])
        ax.set_xticks(np.arange(0, 2 * np.pi, np.pi / 2),
                      ["0", "90", "180", "270"])
        return ax

    @saveFigure
    @stripAxes
    def _plotWaves(self, waves: np.ndarray, ax: matplotlib.axes, **kwargs) -> plt.Axes:
        ax.plot(waves, c="k", **kwargs)
        return ax

    def _getPowerSpectrumPlot(
        self,
        freqs: np.ndarray,
        power: np.ndarray,
        sm_power: np.ndarray,
        band_max_power: float,
        freq_at_band_max_power: float,
        max_freq: int = 50,
        theta_range: tuple = [6, 12],
        ax: plt.Axes = None,
        **kwargs,
    ) -> plt.Axes:
        """
        Gets the power spectrum. The parameters can be obtained from
        calcEEGPowerSpectrum() in the EEGCalcsGeneric class.

        Parameters
        ----------
        freqs : np.ndarray
            The frequencies.
        power : np.ndarray
            The power values.
        sm_power : np.ndarray
            The smoothed power values.
        band_max_power : float
            The maximum power in the band.
        freq_at_band_max_power : float
            The frequency at which the maximum power in the band occurs.
        max_freq : int, optional
            The maximum frequency. Defaults to 50.
        theta_range : tuple, optional
            The theta range. Defaults to [6, 12].
        ax : plt.Axes, optional
            The axes to plot on. If None, new axes are created.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes
            The axes with the plot.
        """
        min_freq = kwargs.pop("min_freq", 0)
        if "strip_axes" in kwargs.keys():
            strip_axes = kwargs.pop("strip_axes")
        else:
            strip_axes = False
        # downsample frequencies and power
        freqs = freqs[0::50]
        power = power[0::50]
        sm_power = sm_power[0::50]
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111)
        ax.plot(freqs, power, alpha=0.5, color=[0.8627, 0.8627, 0.8627])
        ax.plot(freqs, sm_power)
        ax.set_xlim(min_freq, max_freq)
        ylim = [0, np.max(sm_power[freqs < max_freq])]
        if "ylim" in kwargs:
            ylim = kwargs["ylim"]
        ax.set_ylim(ylim)
        ax.set_ylabel("Power")
        ax.set_xlabel("Frequency")
        ax.text(
            x=theta_range[1] / 0.9,
            y=band_max_power,
            s=str(freq_at_band_max_power)[0:4],
            fontsize=20,
        )
        from matplotlib.patches import Rectangle

        r = Rectangle(
            (theta_range[0], 0),
            width=np.diff(theta_range)[0],
            height=np.diff(ax.get_ylim())[0],
            alpha=0.25,
            color="r",
            ec="none",
        )
        ax.add_patch(r)
        if strip_axes:
            return stripAxes(ax)
        return ax

    def _getXCorrPlot(
        self, spk_times: np.array, ax: matplotlib.axes = None, **kwargs
    ) -> plt.Axes:
        """
        Returns an axis containing the autocorrelogram of the spike
        times provided over the range +/-500ms.

        Parameters
        ----------
        spk_times : np.array
            Spike times in seconds.
        ax : matplotlib.axes, optional
            The axes to plot into. If None, new axes are created.
        **kwargs : dict
            Additional keyword arguments for the function, including:
            binsize : int, optional
                The size of the bins in ms. Gets passed to SpikeCalcsGeneric.xcorr().
                Defaults to 1.

        Returns
        -------
        plt.Axes
            The axes with the plot.
        """
        if "strip_axes" in kwargs.keys():
            strip_axes = kwargs.pop("strip_axes")
        else:
            strip_axes = False
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111)
        if "binsize" in kwargs.keys():
            binsize = kwargs["binsize"]
        else:
            binsize = 0.001
        if "Trange" in kwargs.keys():
            xrange = kwargs.pop("Trange")
        else:
            xrange = [-0.5, 0.5]
        ac = xcorr(spk_times, Trange=xrange, **kwargs)
        c = ac.binned_data[0]
        b = ac.bin_edges[0]
        ax.bar(b[:-1], c, width=binsize, color="k", align="edge", zorder=3)
        ax.set_xlim(xrange)
        ax.set_xticks((xrange[0], 0, xrange[1]))
        ax.set_xticklabels("")
        ax.tick_params(
            axis="both", which="both", left=False, right=False, bottom=False, top=False
        )
        ax.set_yticklabels("")
        ax.xaxis.set_ticks_position("bottom")
        if strip_axes:
            return stripAxes(ax)
        axtrans = transforms.blended_transform_factory(
            ax.transData, ax.transAxes)
        ax.vlines(0, ymin=0, ymax=1, colors="lightgrey",
                  transform=axtrans, zorder=1)
        return ax

    def _getRasterPlot(
        self,
        spk_times: np.ndarray,
        dt=(-0.05, 0.1),
        ax: matplotlib.axes = None,
        cluster=0,
        secs_per_bin: int = 0.001,
        **kwargs,
    ) -> plt.Axes | None:
        """
        Plots a raster plot for a specified tetrode/ cluster.

        Parameters
        ----------
        spk_times : np.ndarray
            The spike times in seconds.
        dt : tuple, optional
            The window of time in ms to examine zeroed on the event of interest.
            Defaults to (-0.05, 0.1).
        ax : matplotlib.axes, optional
            The axes to plot into. If not provided, a new figure is created.
            Defaults to None.
        cluster : int, optional
            The cluster number. Defaults to 0.
        secs_per_bin : int, optional
            The number of seconds in each bin of the raster plot. Defaults to 0.001.
        **kwargs : dict
            Additional keyword arguments for the function.

        Returns
        -------
        plt.Axes or None
            The axes with the plot, or None if no spikes were fired in the period.
        """
        assert hasattr(self, "ttl_data")

        strip_axes = kwargs.pop("strip_axes", False)
        histColor = kwargs.pop(
            "hist_colour", [1 / 255.0, 1 / 255.0, 1 / 255.0])
        S = SpikeCalcsGeneric(spk_times, cluster=cluster)
        S.event_ts = self.ttl_data["ttl_timestamps"]
        S.event_window = np.array(dt)
        x, y = S.psth()
        if y:
            if ax is None:
                fig = plt.figure(figsize=(4.0, 7.0))
                axScatter = fig.add_subplot(111)
            else:
                axScatter = ax
            axScatter.scatter(x, y, marker=".", s=2,
                              rasterized=False, color=histColor)
            divider = make_axes_locatable(axScatter)
            axHistx = divider.append_axes(
                "top", 1.2, pad=0.2, sharex=axScatter, transform=axScatter.transAxes
            )
            scattTrans = transforms.blended_transform_factory(
                axScatter.transData, axScatter.transAxes
            )
            stim_pwidth = self.ttl_data["stim_duration"]
            if stim_pwidth is None:
                raise ValueError("stim duration is None")

            axScatter.add_patch(
                Rectangle(
                    (0, 0),
                    width=stim_pwidth,
                    height=1,
                    transform=scattTrans,
                    color=[0, 0, 1],
                    alpha=0.3,
                )
            )
            histTrans = transforms.blended_transform_factory(
                axHistx.transData, axHistx.transAxes
            )
            axHistx.add_patch(
                Rectangle(
                    (0, 0),
                    width=stim_pwidth,
                    height=1,
                    transform=histTrans,
                    color=[0, 0, 1],
                    alpha=0.3,
                )
            )
            ylabel_fs = xlabel_fs = 9
            labelpad = -8
            axScatter.set_ylabel(
                "Laser stimulation events", labelpad=labelpad - 10, fontsize=ylabel_fs
            )
            nStms = y[-1]
            axScatter.set_ylim(0, nStms)
            axScatter.set_yticks((0, nStms))
            axScatter.set_yticklabels(
                ("0", str(nStms + 1)), fontsize=ylabel_fs - 1)
            axScatter.set_xlim(dt)
            axScatter.set_xlabel("Time to laser onset(s)", fontsize=xlabel_fs)
            axScatter.set_xticks((dt[0], 0, dt[1]))
            axScatter.set_xticklabels(
                (str(dt[0]), "0", str(dt[1])), fontsize=xlabel_fs - 1
            )

            h, be = np.histogram(
                x,
                bins=np.arange(dt[0], dt[1] + secs_per_bin, secs_per_bin),
                range=dt,
                density=False,
            )
            axHistx.bar(
                be[:-1],
                h,
                width=secs_per_bin,
                align="edge",
                color=histColor,
                edgecolor="none",
                rasterized=True,
            )
            plt.setp(axHistx.get_xticklabels(), visible=False)
            # Label only the min and max of the y-axis
            # max is rounded to the nearest 10
            maxRate = int(np.ceil(np.max(h) / 10.0) * 10)
            axHistx.set_ylim(0, maxRate)
            axHistx.set_yticks((0, maxRate))
            axHistx.set_yticklabels(
                ("0", str(maxRate)), fontsize=ylabel_fs - 1)
            axHistx.set_xlim(dt)
            axHistx.set_ylabel("Firing rate(Hz)",
                               labelpad=labelpad, fontsize=ylabel_fs)
            fig = plt.gcf()
            fig.canvas.manager.set_window_title(f"Cluster {cluster}")
            if strip_axes:
                return stripAxes(axScatter)
            return axHistx
        else:
            warnings.warn(
                f"PSTH for cluster {cluster} is empty. The cell fired no spikes in the period under question"
            )
            return

    def plotSpectrogramByDepth(
        self,
        nchannels: int = 384,
        nseconds: int = 100,
        maxFreq: int = 125,
        channels: list = [],
        frequencies: list = [],
        frequencyIncrement: int = 1,
        **kwargs,
    ):
        """
        Plots a heat map spectrogram of the LFP for each channel.
        Line plots of power per frequency band and power on a subset of
        channels are also displayed to the right and above the main plot.

        Parameters
        ----------
        nchannels : int
            The number of channels on the probe.
        nseconds : int, optional
            How long in seconds from the start of the trial to do the spectrogram for (for speed).
            Default is 100.
        maxFreq : int
            The maximum frequency in Hz to plot the spectrogram out to. Maximum is 1250. Default is 125.
        channels : list
            The channels to plot separately on the top plot.
        frequencies : list
            The specific frequencies to examine across all channels. The mean from frequency:
            frequency+frequencyIncrement is calculated and plotted on the left hand side of the plot.
        frequencyIncrement : int
            The amount to add to each value of the frequencies list above.
        **kwargs : dict
            Additional keyword arguments for the function. Valid key value pairs:
                "saveas" - save the figure to this location, needs absolute path and filename.

        Notes
        -----
        Should also allow kwargs to specify exactly which channels and / or frequency bands to do the line plots for.
        """
        if not self.path2LFPdata:
            raise TypeError("Not a probe recording so not plotting")
        import os

        lfp_file = os.path.join(self.path2LFPdata, "continuous.dat")
        status = os.stat(lfp_file)
        nsamples = int(status.st_size / 2 / nchannels)
        mmap = np.memmap(lfp_file, np.int16, "r", 0,
                         (nchannels, nsamples), order="F")
        # Load the channel map NB assumes this is in the AP data
        # location and that kilosort was run there
        channel_map = np.squeeze(
            np.load(os.path.join(self.path2APdata, "channel_map.npy"))
        )
        lfp_sample_rate = 2500
        data = np.array(mmap[channel_map, 0: nseconds * lfp_sample_rate])
        from ephysiopy.common.ephys_generic import EEGCalcsGeneric

        E = EEGCalcsGeneric(data[0, :], lfp_sample_rate)
        E.calcEEGPowerSpectrum()
        spec_data = np.zeros(shape=(data.shape[0], len(E.sm_power[0::50])))
        for chan in range(data.shape[0]):
            E = EEGCalcsGeneric(data[chan, :], lfp_sample_rate)
            E.calcEEGPowerSpectrum()
            spec_data[chan, :] = E.sm_power[0::50]

        x, y = np.meshgrid(E.freqs[0::50], channel_map)
        import matplotlib.colors as colors
        from matplotlib.pyplot import cm
        from mpl_toolkits.axes_grid1 import make_axes_locatable

        _, spectoAx = plt.subplots()
        spectoAx.pcolormesh(
            x, y, spec_data, edgecolors="face", cmap="bone", norm=colors.LogNorm()
        )
        spectoAx.set_xlim(0, maxFreq)
        spectoAx.set_ylim(channel_map[0], channel_map[-1])
        spectoAx.set_xlabel("Frequency (Hz)")
        spectoAx.set_ylabel("Channel")
        divider = make_axes_locatable(spectoAx)
        channel_spectoAx = divider.append_axes(
            "top", 1.2, pad=0.1, sharex=spectoAx)
        meanfreq_powerAx = divider.append_axes(
            "right", 1.2, pad=0.1, sharey=spectoAx)
        plt.setp(
            channel_spectoAx.get_xticklabels() + meanfreq_powerAx.get_yticklabels(),
            visible=False,
        )

        # plot mean power across some channels
        mn_power = np.mean(spec_data, 0)
        if not channels:
            channels = range(1, nchannels, 60)
        cols = iter(cm.rainbow(np.linspace(0, 1, len(channels))))
        for chan in channels:
            c = next(cols)
            channel_spectoAx.plot(
                E.freqs[0::50],
                10 * np.log10(spec_data[chan, :] / mn_power),
                c=c,
                label=str(chan),
            )

        channel_spectoAx.set_ylabel("Channel power(dB)")
        channel_spectoAx.legend(
            bbox_to_anchor=(0.0, 1.02, 1.0, 0.102),
            loc="lower left",
            mode="expand",
            fontsize="x-small",
            ncol=4,
        )

        # plot mean frequencies across all channels
        if not frequencyIncrement:
            freq_inc = 6
        else:
            freq_inc = frequencyIncrement
        if not frequencies:
            lower_freqs = np.arange(1, maxFreq - freq_inc, freq_inc)
        else:
            lower_freqs = frequencies
        upper_freqs = [f + freq_inc for f in lower_freqs]
        cols = iter(cm.nipy_spectral(np.linspace(0, 1, len(upper_freqs))))
        mn_power = np.mean(spec_data, 1)
        for freqs in zip(lower_freqs, upper_freqs):
            freq_mask = np.logical_and(
                E.freqs[0::50] > freqs[0], E.freqs[0::50] < freqs[1]
            )
            mean_power = 10 * \
                np.log10(np.mean(spec_data[:, freq_mask], 1) / mn_power)
            c = next(cols)
            meanfreq_powerAx.plot(
                mean_power,
                channel_map,
                c=c,
                label=str(freqs[0]) + " - " + str(freqs[1]),
            )
        meanfreq_powerAx.set_xlabel("Mean freq. band power(dB)")
        meanfreq_powerAx.legend(
            bbox_to_anchor=(0.0, 1.02, 1.0, 0.102),
            loc="lower left",
            mode="expand",
            fontsize="x-small",
            ncol=1,
        )
        if "saveas" in kwargs:
            saveas = kwargs["saveas"]
            plt.savefig(saveas)
        plt.show()
