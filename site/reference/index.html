
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../how-to-guides/">
      
      
        <link rel="next" href="../explanation/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.21">
    
    
      
        <title>Reference - ephysiopy</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.66ac8b77.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#recording-data" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="ephysiopy" class="md-header__button md-logo" aria-label="ephysiopy" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ephysiopy
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Reference
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="ephysiopy" class="md-nav__button md-logo" aria-label="ephysiopy" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    ephysiopy
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Welcome to ephysiopy
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tutorials
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../how-to-guides/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    How to guides
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Reference
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Reference
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#recording-data" class="md-nav__link">
    <span class="md-ellipsis">
      Recording data
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording" class="md-nav__link">
    <span class="md-ellipsis">
      recording
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.AxonaTrial" class="md-nav__link">
    <span class="md-ellipsis">
      AxonaTrial
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AxonaTrial">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.AxonaTrial.apply_filter" class="md-nav__link">
    <span class="md-ellipsis">
      apply_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.AxonaTrial.get_spike_times" class="md-nav__link">
    <span class="md-ellipsis">
      get_spike_times
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase" class="md-nav__link">
    <span class="md-ellipsis">
      OpenEphysBase
    </span>
  </a>
  
    <nav class="md-nav" aria-label="OpenEphysBase">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase._get_recording_start_time" class="md-nav__link">
    <span class="md-ellipsis">
      _get_recording_start_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase.apply_filter" class="md-nav__link">
    <span class="md-ellipsis">
      apply_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase.get_spike_times" class="md-nav__link">
    <span class="md-ellipsis">
      get_spike_times
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase.load_lfp" class="md-nav__link">
    <span class="md-ellipsis">
      load_lfp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase.load_ttl" class="md-nav__link">
    <span class="md-ellipsis">
      load_ttl
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface" class="md-nav__link">
    <span class="md-ellipsis">
      TrialInterface
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TrialInterface">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface._get_map" class="md-nav__link">
    <span class="md-ellipsis">
      _get_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface._get_spike_pos_idx" class="md-nav__link">
    <span class="md-ellipsis">
      _get_spike_pos_idx
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.apply_filter" class="md-nav__link">
    <span class="md-ellipsis">
      apply_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_eb_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_eb_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_hd_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_hd_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_rate_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_rate_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_speed_v_hd_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_speed_v_hd_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_speed_v_rate_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_speed_v_rate_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_spike_times" class="md-nav__link">
    <span class="md-ellipsis">
      get_spike_times
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_spike_times_binned_into_position" class="md-nav__link">
    <span class="md-ellipsis">
      get_spike_times_binned_into_position
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_cluster_data" class="md-nav__link">
    <span class="md-ellipsis">
      load_cluster_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_lfp" class="md-nav__link">
    <span class="md-ellipsis">
      load_lfp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_neural_data" class="md-nav__link">
    <span class="md-ellipsis">
      load_neural_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_pos_data" class="md-nav__link">
    <span class="md-ellipsis">
      load_pos_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_settings" class="md-nav__link">
    <span class="md-ellipsis">
      load_settings
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.find_path_to_ripple_ttl" class="md-nav__link">
    <span class="md-ellipsis">
      find_path_to_ripple_ttl
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.memmapBinaryFile" class="md-nav__link">
    <span class="md-ellipsis">
      memmapBinaryFile
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#plotting-the-results" class="md-nav__link">
    <span class="md-ellipsis">
      Plotting the results
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting" class="md-nav__link">
    <span class="md-ellipsis">
      plotting
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker" class="md-nav__link">
    <span class="md-ellipsis">
      FigureMaker
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FigureMaker">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.PosCalcs" class="md-nav__link">
    <span class="md-ellipsis">
      PosCalcs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker._getPowerSpectrumPlot" class="md-nav__link">
    <span class="md-ellipsis">
      _getPowerSpectrumPlot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker._getRasterPlot" class="md-nav__link">
    <span class="md-ellipsis">
      _getRasterPlot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker._getXCorrPlot" class="md-nav__link">
    <span class="md-ellipsis">
      _getXCorrPlot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker._plot_multiple_clusters" class="md-nav__link">
    <span class="md-ellipsis">
      _plot_multiple_clusters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plotSpectrogramByDepth" class="md-nav__link">
    <span class="md-ellipsis">
      plotSpectrogramByDepth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_acorr" class="md-nav__link">
    <span class="md-ellipsis">
      plot_acorr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_eb_map" class="md-nav__link">
    <span class="md-ellipsis">
      plot_eb_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_eb_spikes" class="md-nav__link">
    <span class="md-ellipsis">
      plot_eb_spikes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_hd_map" class="md-nav__link">
    <span class="md-ellipsis">
      plot_hd_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_power_spectrum" class="md-nav__link">
    <span class="md-ellipsis">
      plot_power_spectrum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_raster" class="md-nav__link">
    <span class="md-ellipsis">
      plot_raster
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_rate_map" class="md-nav__link">
    <span class="md-ellipsis">
      plot_rate_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_sac" class="md-nav__link">
    <span class="md-ellipsis">
      plot_sac
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_speed_v_hd" class="md-nav__link">
    <span class="md-ellipsis">
      plot_speed_v_hd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_speed_v_rate" class="md-nav__link">
    <span class="md-ellipsis">
      plot_speed_v_rate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_spike_path" class="md-nav__link">
    <span class="md-ellipsis">
      plot_spike_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_xcorr" class="md-nav__link">
    <span class="md-ellipsis">
      plot_xcorr
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binning-up-data" class="md-nav__link">
    <span class="md-ellipsis">
      Binning up data
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.binning" class="md-nav__link">
    <span class="md-ellipsis">
      binning
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap" class="md-nav__link">
    <span class="md-ellipsis">
      RateMap
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RateMap">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.pos_weights" class="md-nav__link">
    <span class="md-ellipsis">
      pos_weights
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._autoCorr2D" class="md-nav__link">
    <span class="md-ellipsis">
      _autoCorr2D
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._bin_data" class="md-nav__link">
    <span class="md-ellipsis">
      _bin_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._calc_bin_edges" class="md-nav__link">
    <span class="md-ellipsis">
      _calc_bin_edges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._calc_ego_angles" class="md-nav__link">
    <span class="md-ellipsis">
      _calc_ego_angles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._crossCorr2D" class="md-nav__link">
    <span class="md-ellipsis">
      _crossCorr2D
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._getXYLimits" class="md-nav__link">
    <span class="md-ellipsis">
      _getXYLimits
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.autoCorr2D" class="md-nav__link">
    <span class="md-ellipsis">
      autoCorr2D
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.crossCorr2D" class="md-nav__link">
    <span class="md-ellipsis">
      crossCorr2D
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.getAdaptiveMap" class="md-nav__link">
    <span class="md-ellipsis">
      getAdaptiveMap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.get_disperion_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_disperion_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.get_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.tWinSAC" class="md-nav__link">
    <span class="md-ellipsis">
      tWinSAC
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#field-calculations" class="md-nav__link">
    <span class="md-ellipsis">
      Field calculations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs" class="md-nav__link">
    <span class="md-ellipsis">
      fieldcalcs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.PROP_VALS" class="md-nav__link">
    <span class="md-ellipsis">
      PROP_VALS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps" class="md-nav__link">
    <span class="md-ellipsis">
      FieldProps
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FieldProps">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.phi" class="md-nav__link">
    <span class="md-ellipsis">
      phi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.pos_phi" class="md-nav__link">
    <span class="md-ellipsis">
      pos_phi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.pos_r" class="md-nav__link">
    <span class="md-ellipsis">
      pos_r
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.projected_direction" class="md-nav__link">
    <span class="md-ellipsis">
      projected_direction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.__str__" class="md-nav__link">
    <span class="md-ellipsis">
      __str__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.smooth_runs" class="md-nav__link">
    <span class="md-ellipsis">
      smooth_runs
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.RunProps" class="md-nav__link">
    <span class="md-ellipsis">
      RunProps
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RunProps">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.RunProps.smooth_xy" class="md-nav__link">
    <span class="md-ellipsis">
      smooth_xy
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs._get_field_labels" class="md-nav__link">
    <span class="md-ellipsis">
      _get_field_labels
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.border_score" class="md-nav__link">
    <span class="md-ellipsis">
      border_score
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.calc_angs" class="md-nav__link">
    <span class="md-ellipsis">
      calc_angs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.coherence" class="md-nav__link">
    <span class="md-ellipsis">
      coherence
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.deform_SAC" class="md-nav__link">
    <span class="md-ellipsis">
      deform_SAC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.field_lims" class="md-nav__link">
    <span class="md-ellipsis">
      field_lims
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.field_props" class="md-nav__link">
    <span class="md-ellipsis">
      field_props
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.fieldprops" class="md-nav__link">
    <span class="md-ellipsis">
      fieldprops
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_circular_regions" class="md-nav__link">
    <span class="md-ellipsis">
      get_circular_regions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_deformed_sac_gridscore" class="md-nav__link">
    <span class="md-ellipsis">
      get_deformed_sac_gridscore
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_expanding_circle_gridscore" class="md-nav__link">
    <span class="md-ellipsis">
      get_expanding_circle_gridscore
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_mean_resultant" class="md-nav__link">
    <span class="md-ellipsis">
      get_mean_resultant
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_thigmotaxis_score" class="md-nav__link">
    <span class="md-ellipsis">
      get_thigmotaxis_score
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.global_threshold" class="md-nav__link">
    <span class="md-ellipsis">
      global_threshold
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.grid_field_props" class="md-nav__link">
    <span class="md-ellipsis">
      grid_field_props
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.grid_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      grid_orientation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.gridness" class="md-nav__link">
    <span class="md-ellipsis">
      gridness
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.kl_spatial_sparsity" class="md-nav__link">
    <span class="md-ellipsis">
      kl_spatial_sparsity
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.kldiv" class="md-nav__link">
    <span class="md-ellipsis">
      kldiv
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.kldiv_dir" class="md-nav__link">
    <span class="md-ellipsis">
      kldiv_dir
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.limit_to_one" class="md-nav__link">
    <span class="md-ellipsis">
      limit_to_one
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.local_threshold" class="md-nav__link">
    <span class="md-ellipsis">
      local_threshold
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.partitionFields" class="md-nav__link">
    <span class="md-ellipsis">
      partitionFields
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.skaggs_info" class="md-nav__link">
    <span class="md-ellipsis">
      skaggs_info
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.spatial_sparsity" class="md-nav__link">
    <span class="md-ellipsis">
      spatial_sparsity
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-coding" class="md-nav__link">
    <span class="md-ellipsis">
      Phase coding
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding" class="md-nav__link">
    <span class="md-ellipsis">
      phasecoding
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D" class="md-nav__link">
    <span class="md-ellipsis">
      phasePrecession2D
    </span>
  </a>
  
    <nav class="md-nav" aria-label="phasePrecession2D">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D.getPosProps" class="md-nav__link">
    <span class="md-ellipsis">
      getPosProps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D.getThetaProps" class="md-nav__link">
    <span class="md-ellipsis">
      getThetaProps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D.performRegression" class="md-nav__link">
    <span class="md-ellipsis">
      performRegression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D.update_regressors" class="md-nav__link">
    <span class="md-ellipsis">
      update_regressors
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.ccc" class="md-nav__link">
    <span class="md-ellipsis">
      ccc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.ccc_jack" class="md-nav__link">
    <span class="md-ellipsis">
      ccc_jack
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.circCircCorrTLinear" class="md-nav__link">
    <span class="md-ellipsis">
      circCircCorrTLinear
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.circRegress" class="md-nav__link">
    <span class="md-ellipsis">
      circRegress
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.plot_spikes_in_runs_per_field" class="md-nav__link">
    <span class="md-ellipsis">
      plot_spikes_in_runs_per_field
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.shuffledPVal" class="md-nav__link">
    <span class="md-ellipsis">
      shuffledPVal
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rhymicity" class="md-nav__link">
    <span class="md-ellipsis">
      Rhymicity
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity" class="md-nav__link">
    <span class="md-ellipsis">
      rhythmicity
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning" class="md-nav__link">
    <span class="md-ellipsis">
      CosineDirectionalTuning
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CosineDirectionalTuning">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.spk_clusters" class="md-nav__link">
    <span class="md-ellipsis">
      spk_clusters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning._rolling_window" class="md-nav__link">
    <span class="md-ellipsis">
      _rolling_window
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.getDirectionalBinPerPosition" class="md-nav__link">
    <span class="md-ellipsis">
      getDirectionalBinPerPosition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.getRunsOfMinLength" class="md-nav__link">
    <span class="md-ellipsis">
      getRunsOfMinLength
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.intrinsic_freq_autoCorr" class="md-nav__link">
    <span class="md-ellipsis">
      intrinsic_freq_autoCorr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.power_spectrum" class="md-nav__link">
    <span class="md-ellipsis">
      power_spectrum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.speedFilterRuns" class="md-nav__link">
    <span class="md-ellipsis">
      speedFilterRuns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations" class="md-nav__link">
    <span class="md-ellipsis">
      LFPOscillations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="LFPOscillations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.filterForLaser" class="md-nav__link">
    <span class="md-ellipsis">
      filterForLaser
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.getFreqPhase" class="md-nav__link">
    <span class="md-ellipsis">
      getFreqPhase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.get_theta_phase" class="md-nav__link">
    <span class="md-ellipsis">
      get_theta_phase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.modulationindex" class="md-nav__link">
    <span class="md-ellipsis">
      modulationindex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.plv" class="md-nav__link">
    <span class="md-ellipsis">
      plv
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.spike_xy_phase_plot" class="md-nav__link">
    <span class="md-ellipsis">
      spike_xy_phase_plot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.theta_running" class="md-nav__link">
    <span class="md-ellipsis">
      theta_running
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler" class="md-nav__link">
    <span class="md-ellipsis">
      Rippler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Rippler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._calc_ripple_chunks_duration_power" class="md-nav__link">
    <span class="md-ellipsis">
      _calc_ripple_chunks_duration_power
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._find_high_power_periods" class="md-nav__link">
    <span class="md-ellipsis">
      _find_high_power_periods
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._find_path_to_continuous" class="md-nav__link">
    <span class="md-ellipsis">
      _find_path_to_continuous
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._find_path_to_ripple_ttl" class="md-nav__link">
    <span class="md-ellipsis">
      _find_path_to_ripple_ttl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._load_start_time" class="md-nav__link">
    <span class="md-ellipsis">
      _load_start_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler.filter_timestamps_for_real_ripples" class="md-nav__link">
    <span class="md-ellipsis">
      filter_timestamps_for_real_ripples
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler.plot_mean_rippleband_power" class="md-nav__link">
    <span class="md-ellipsis">
      plot_mean_rippleband_power
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler.plot_mean_spectrogram" class="md-nav__link">
    <span class="md-ellipsis">
      plot_mean_spectrogram
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spike-calculations" class="md-nav__link">
    <span class="md-ellipsis">
      Spike calculations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs" class="md-nav__link">
    <span class="md-ellipsis">
      spikecalcs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsAxona" class="md-nav__link">
    <span class="md-ellipsis">
      SpikeCalcsAxona
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SpikeCalcsAxona">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsAxona.half_amp_dur" class="md-nav__link">
    <span class="md-ellipsis">
      half_amp_dur
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsAxona.p2t_time" class="md-nav__link">
    <span class="md-ellipsis">
      p2t_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsAxona.plotClusterSpace" class="md-nav__link">
    <span class="md-ellipsis">
      plotClusterSpace
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric" class="md-nav__link">
    <span class="md-ellipsis">
      SpikeCalcsGeneric
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SpikeCalcsGeneric">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.n_spikes" class="md-nav__link">
    <span class="md-ellipsis">
      n_spikes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.acorr" class="md-nav__link">
    <span class="md-ellipsis">
      acorr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.apply_filter" class="md-nav__link">
    <span class="md-ellipsis">
      apply_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_ifr" class="md-nav__link">
    <span class="md-ellipsis">
      get_ifr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_ifr_power_spectrum" class="md-nav__link">
    <span class="md-ellipsis">
      get_ifr_power_spectrum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.ifr_sp_corr" class="md-nav__link">
    <span class="md-ellipsis">
      ifr_sp_corr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.mean_isi_range" class="md-nav__link">
    <span class="md-ellipsis">
      mean_isi_range
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.mean_waveform" class="md-nav__link">
    <span class="md-ellipsis">
      mean_waveform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.psch" class="md-nav__link">
    <span class="md-ellipsis">
      psch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.psth" class="md-nav__link">
    <span class="md-ellipsis">
      psth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.responds_to_stimulus" class="md-nav__link">
    <span class="md-ellipsis">
      responds_to_stimulus
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.smooth_spike_train" class="md-nav__link">
    <span class="md-ellipsis">
      smooth_spike_train
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_band_max_freq" class="md-nav__link">
    <span class="md-ellipsis">
      theta_band_max_freq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idx" class="md-nav__link">
    <span class="md-ellipsis">
      theta_mod_idx
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idxV2" class="md-nav__link">
    <span class="md-ellipsis">
      theta_mod_idxV2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idxV3" class="md-nav__link">
    <span class="md-ellipsis">
      theta_mod_idxV3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.update_KSMeta" class="md-nav__link">
    <span class="md-ellipsis">
      update_KSMeta
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys" class="md-nav__link">
    <span class="md-ellipsis">
      SpikeCalcsOpenEphys
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SpikeCalcsOpenEphys">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys.get_channel_depth_from_templates" class="md-nav__link">
    <span class="md-ellipsis">
      get_channel_depth_from_templates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys.get_template_id_for_cluster" class="md-nav__link">
    <span class="md-ellipsis">
      get_template_id_for_cluster
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys.get_waveforms" class="md-nav__link">
    <span class="md-ellipsis">
      get_waveforms
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsProbe" class="md-nav__link">
    <span class="md-ellipsis">
      SpikeCalcsProbe
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.cluster_quality" class="md-nav__link">
    <span class="md-ellipsis">
      cluster_quality
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.contamination_percent" class="md-nav__link">
    <span class="md-ellipsis">
      contamination_percent
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.fit_smoothed_curve_to_xcorr" class="md-nav__link">
    <span class="md-ellipsis">
      fit_smoothed_curve_to_xcorr
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.get_param" class="md-nav__link">
    <span class="md-ellipsis">
      get_param
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.mahal" class="md-nav__link">
    <span class="md-ellipsis">
      mahal
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.xcorr" class="md-nav__link">
    <span class="md-ellipsis">
      xcorr
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#statistics" class="md-nav__link">
    <span class="md-ellipsis">
      Statistics
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs" class="md-nav__link">
    <span class="md-ellipsis">
      statscalcs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.V_test" class="md-nav__link">
    <span class="md-ellipsis">
      V_test
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.circ_r" class="md-nav__link">
    <span class="md-ellipsis">
      circ_r
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.duplicates_as_complex" class="md-nav__link">
    <span class="md-ellipsis">
      duplicates_as_complex
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.mean_resultant_vector" class="md-nav__link">
    <span class="md-ellipsis">
      mean_resultant_vector
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.watsonWilliams" class="md-nav__link">
    <span class="md-ellipsis">
      watsonWilliams
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.watsonsU2" class="md-nav__link">
    <span class="md-ellipsis">
      watsonsU2
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.watsonsU2n" class="md-nav__link">
    <span class="md-ellipsis">
      watsonsU2n
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#utility-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Utility functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils" class="md-nav__link">
    <span class="md-ellipsis">
      utils
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.BinnedData" class="md-nav__link">
    <span class="md-ellipsis">
      BinnedData
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BinnedData">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.BinnedData.correlate" class="md-nav__link">
    <span class="md-ellipsis">
      correlate
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.applyFilter2Labels" class="md-nav__link">
    <span class="md-ellipsis">
      applyFilter2Labels
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.blur_image" class="md-nav__link">
    <span class="md-ellipsis">
      blur_image
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.bwperim" class="md-nav__link">
    <span class="md-ellipsis">
      bwperim
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.clean_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      clean_kwargs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.corr_maps" class="md-nav__link">
    <span class="md-ellipsis">
      corr_maps
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.count_runs_and_unique_numbers" class="md-nav__link">
    <span class="md-ellipsis">
      count_runs_and_unique_numbers
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.count_to" class="md-nav__link">
    <span class="md-ellipsis">
      count_to
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.find_runs" class="md-nav__link">
    <span class="md-ellipsis">
      find_runs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.fixAngle" class="md-nav__link">
    <span class="md-ellipsis">
      fixAngle
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.get_z_score" class="md-nav__link">
    <span class="md-ellipsis">
      get_z_score
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.min_max_norm" class="md-nav__link">
    <span class="md-ellipsis">
      min_max_norm
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.polar" class="md-nav__link">
    <span class="md-ellipsis">
      polar
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.rect" class="md-nav__link">
    <span class="md-ellipsis">
      rect
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.remap_to_range" class="md-nav__link">
    <span class="md-ellipsis">
      remap_to_range
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.repeat_ind" class="md-nav__link">
    <span class="md-ellipsis">
      repeat_ind
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.shift_vector" class="md-nav__link">
    <span class="md-ellipsis">
      shift_vector
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.smooth" class="md-nav__link">
    <span class="md-ellipsis">
      smooth
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.window_rms" class="md-nav__link">
    <span class="md-ellipsis">
      window_rms
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#axona-input-output" class="md-nav__link">
    <span class="md-ellipsis">
      Axona input/ output
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO" class="md-nav__link">
    <span class="md-ellipsis">
      axonaIO
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.ClusterSession" class="md-nav__link">
    <span class="md-ellipsis">
      ClusterSession
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.EEG" class="md-nav__link">
    <span class="md-ellipsis">
      EEG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO" class="md-nav__link">
    <span class="md-ellipsis">
      IO
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IO">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getCluCut" class="md-nav__link">
    <span class="md-ellipsis">
      getCluCut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getCut" class="md-nav__link">
    <span class="md-ellipsis">
      getCut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getData" class="md-nav__link">
    <span class="md-ellipsis">
      getData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getHeader" class="md-nav__link">
    <span class="md-ellipsis">
      getHeader
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getHeaderVal" class="md-nav__link">
    <span class="md-ellipsis">
      getHeaderVal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.setData" class="md-nav__link">
    <span class="md-ellipsis">
      setData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.setHeader" class="md-nav__link">
    <span class="md-ellipsis">
      setHeader
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Pos" class="md-nav__link">
    <span class="md-ellipsis">
      Pos
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Stim" class="md-nav__link">
    <span class="md-ellipsis">
      Stim
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode" class="md-nav__link">
    <span class="md-ellipsis">
      Tetrode
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Tetrode">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.apply_mask" class="md-nav__link">
    <span class="md-ellipsis">
      apply_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getClustIdx" class="md-nav__link">
    <span class="md-ellipsis">
      getClustIdx
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getClustSpks" class="md-nav__link">
    <span class="md-ellipsis">
      getClustSpks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getClustTS" class="md-nav__link">
    <span class="md-ellipsis">
      getClustTS
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getPosSamples" class="md-nav__link">
    <span class="md-ellipsis">
      getPosSamples
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getSpkTS" class="md-nav__link">
    <span class="md-ellipsis">
      getSpkTS
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getUniqueClusters" class="md-nav__link">
    <span class="md-ellipsis">
      getUniqueClusters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conversion-code" class="md-nav__link">
    <span class="md-ellipsis">
      Conversion code
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Conversion code">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#openephys-to-axona" class="md-nav__link">
    <span class="md-ellipsis">
      OpenEphys to Axona
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona" class="md-nav__link">
    <span class="md-ellipsis">
      OE_Axona
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona" class="md-nav__link">
    <span class="md-ellipsis">
      OE2Axona
    </span>
  </a>
  
    <nav class="md-nav" aria-label="OE2Axona">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.settings" class="md-nav__link">
    <span class="md-ellipsis">
      settings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.convertPosData" class="md-nav__link">
    <span class="md-ellipsis">
      convertPosData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.convertSpikeData" class="md-nav__link">
    <span class="md-ellipsis">
      convertSpikeData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.convertTemplateDataToAxonaTetrode" class="md-nav__link">
    <span class="md-ellipsis">
      convertTemplateDataToAxonaTetrode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.exportLFP" class="md-nav__link">
    <span class="md-ellipsis">
      exportLFP
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.exportSetFile" class="md-nav__link">
    <span class="md-ellipsis">
      exportSetFile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.getOEData" class="md-nav__link">
    <span class="md-ellipsis">
      getOEData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.makeLFPData" class="md-nav__link">
    <span class="md-ellipsis">
      makeLFPData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.resample" class="md-nav__link">
    <span class="md-ellipsis">
      resample
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#openephys-to-numpy" class="md-nav__link">
    <span class="md-ellipsis">
      OpenEphys to numpy
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy" class="md-nav__link">
    <span class="md-ellipsis">
      OE_numpy
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy.OE2Numpy" class="md-nav__link">
    <span class="md-ellipsis">
      OE2Numpy
    </span>
  </a>
  
    <nav class="md-nav" aria-label="OE2Numpy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy.OE2Numpy.settings" class="md-nav__link">
    <span class="md-ellipsis">
      settings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy.OE2Numpy.getOEData" class="md-nav__link">
    <span class="md-ellipsis">
      getOEData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy.OE2Numpy.resample" class="md-nav__link">
    <span class="md-ellipsis">
      resample
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../explanation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Explanation
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#recording-data" class="md-nav__link">
    <span class="md-ellipsis">
      Recording data
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording" class="md-nav__link">
    <span class="md-ellipsis">
      recording
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.AxonaTrial" class="md-nav__link">
    <span class="md-ellipsis">
      AxonaTrial
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AxonaTrial">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.AxonaTrial.apply_filter" class="md-nav__link">
    <span class="md-ellipsis">
      apply_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.AxonaTrial.get_spike_times" class="md-nav__link">
    <span class="md-ellipsis">
      get_spike_times
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase" class="md-nav__link">
    <span class="md-ellipsis">
      OpenEphysBase
    </span>
  </a>
  
    <nav class="md-nav" aria-label="OpenEphysBase">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase._get_recording_start_time" class="md-nav__link">
    <span class="md-ellipsis">
      _get_recording_start_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase.apply_filter" class="md-nav__link">
    <span class="md-ellipsis">
      apply_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase.get_spike_times" class="md-nav__link">
    <span class="md-ellipsis">
      get_spike_times
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase.load_lfp" class="md-nav__link">
    <span class="md-ellipsis">
      load_lfp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.OpenEphysBase.load_ttl" class="md-nav__link">
    <span class="md-ellipsis">
      load_ttl
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface" class="md-nav__link">
    <span class="md-ellipsis">
      TrialInterface
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TrialInterface">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface._get_map" class="md-nav__link">
    <span class="md-ellipsis">
      _get_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface._get_spike_pos_idx" class="md-nav__link">
    <span class="md-ellipsis">
      _get_spike_pos_idx
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.apply_filter" class="md-nav__link">
    <span class="md-ellipsis">
      apply_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_eb_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_eb_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_hd_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_hd_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_rate_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_rate_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_speed_v_hd_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_speed_v_hd_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_speed_v_rate_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_speed_v_rate_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_spike_times" class="md-nav__link">
    <span class="md-ellipsis">
      get_spike_times
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.get_spike_times_binned_into_position" class="md-nav__link">
    <span class="md-ellipsis">
      get_spike_times_binned_into_position
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_cluster_data" class="md-nav__link">
    <span class="md-ellipsis">
      load_cluster_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_lfp" class="md-nav__link">
    <span class="md-ellipsis">
      load_lfp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_neural_data" class="md-nav__link">
    <span class="md-ellipsis">
      load_neural_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_pos_data" class="md-nav__link">
    <span class="md-ellipsis">
      load_pos_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.TrialInterface.load_settings" class="md-nav__link">
    <span class="md-ellipsis">
      load_settings
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.find_path_to_ripple_ttl" class="md-nav__link">
    <span class="md-ellipsis">
      find_path_to_ripple_ttl
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.io.recording.memmapBinaryFile" class="md-nav__link">
    <span class="md-ellipsis">
      memmapBinaryFile
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#plotting-the-results" class="md-nav__link">
    <span class="md-ellipsis">
      Plotting the results
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting" class="md-nav__link">
    <span class="md-ellipsis">
      plotting
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker" class="md-nav__link">
    <span class="md-ellipsis">
      FigureMaker
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FigureMaker">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.PosCalcs" class="md-nav__link">
    <span class="md-ellipsis">
      PosCalcs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker._getPowerSpectrumPlot" class="md-nav__link">
    <span class="md-ellipsis">
      _getPowerSpectrumPlot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker._getRasterPlot" class="md-nav__link">
    <span class="md-ellipsis">
      _getRasterPlot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker._getXCorrPlot" class="md-nav__link">
    <span class="md-ellipsis">
      _getXCorrPlot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker._plot_multiple_clusters" class="md-nav__link">
    <span class="md-ellipsis">
      _plot_multiple_clusters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plotSpectrogramByDepth" class="md-nav__link">
    <span class="md-ellipsis">
      plotSpectrogramByDepth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_acorr" class="md-nav__link">
    <span class="md-ellipsis">
      plot_acorr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_eb_map" class="md-nav__link">
    <span class="md-ellipsis">
      plot_eb_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_eb_spikes" class="md-nav__link">
    <span class="md-ellipsis">
      plot_eb_spikes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_hd_map" class="md-nav__link">
    <span class="md-ellipsis">
      plot_hd_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_power_spectrum" class="md-nav__link">
    <span class="md-ellipsis">
      plot_power_spectrum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_raster" class="md-nav__link">
    <span class="md-ellipsis">
      plot_raster
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_rate_map" class="md-nav__link">
    <span class="md-ellipsis">
      plot_rate_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_sac" class="md-nav__link">
    <span class="md-ellipsis">
      plot_sac
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_speed_v_hd" class="md-nav__link">
    <span class="md-ellipsis">
      plot_speed_v_hd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_speed_v_rate" class="md-nav__link">
    <span class="md-ellipsis">
      plot_speed_v_rate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_spike_path" class="md-nav__link">
    <span class="md-ellipsis">
      plot_spike_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.visualise.plotting.FigureMaker.plot_xcorr" class="md-nav__link">
    <span class="md-ellipsis">
      plot_xcorr
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binning-up-data" class="md-nav__link">
    <span class="md-ellipsis">
      Binning up data
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.binning" class="md-nav__link">
    <span class="md-ellipsis">
      binning
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap" class="md-nav__link">
    <span class="md-ellipsis">
      RateMap
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RateMap">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.pos_weights" class="md-nav__link">
    <span class="md-ellipsis">
      pos_weights
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._autoCorr2D" class="md-nav__link">
    <span class="md-ellipsis">
      _autoCorr2D
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._bin_data" class="md-nav__link">
    <span class="md-ellipsis">
      _bin_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._calc_bin_edges" class="md-nav__link">
    <span class="md-ellipsis">
      _calc_bin_edges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._calc_ego_angles" class="md-nav__link">
    <span class="md-ellipsis">
      _calc_ego_angles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._crossCorr2D" class="md-nav__link">
    <span class="md-ellipsis">
      _crossCorr2D
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap._getXYLimits" class="md-nav__link">
    <span class="md-ellipsis">
      _getXYLimits
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.autoCorr2D" class="md-nav__link">
    <span class="md-ellipsis">
      autoCorr2D
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.crossCorr2D" class="md-nav__link">
    <span class="md-ellipsis">
      crossCorr2D
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.getAdaptiveMap" class="md-nav__link">
    <span class="md-ellipsis">
      getAdaptiveMap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.get_disperion_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_disperion_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.get_map" class="md-nav__link">
    <span class="md-ellipsis">
      get_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.binning.RateMap.tWinSAC" class="md-nav__link">
    <span class="md-ellipsis">
      tWinSAC
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#field-calculations" class="md-nav__link">
    <span class="md-ellipsis">
      Field calculations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs" class="md-nav__link">
    <span class="md-ellipsis">
      fieldcalcs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.PROP_VALS" class="md-nav__link">
    <span class="md-ellipsis">
      PROP_VALS
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps" class="md-nav__link">
    <span class="md-ellipsis">
      FieldProps
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FieldProps">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.phi" class="md-nav__link">
    <span class="md-ellipsis">
      phi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.pos_phi" class="md-nav__link">
    <span class="md-ellipsis">
      pos_phi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.pos_r" class="md-nav__link">
    <span class="md-ellipsis">
      pos_r
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.projected_direction" class="md-nav__link">
    <span class="md-ellipsis">
      projected_direction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.__str__" class="md-nav__link">
    <span class="md-ellipsis">
      __str__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.FieldProps.smooth_runs" class="md-nav__link">
    <span class="md-ellipsis">
      smooth_runs
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.RunProps" class="md-nav__link">
    <span class="md-ellipsis">
      RunProps
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RunProps">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.RunProps.smooth_xy" class="md-nav__link">
    <span class="md-ellipsis">
      smooth_xy
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs._get_field_labels" class="md-nav__link">
    <span class="md-ellipsis">
      _get_field_labels
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.border_score" class="md-nav__link">
    <span class="md-ellipsis">
      border_score
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.calc_angs" class="md-nav__link">
    <span class="md-ellipsis">
      calc_angs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.coherence" class="md-nav__link">
    <span class="md-ellipsis">
      coherence
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.deform_SAC" class="md-nav__link">
    <span class="md-ellipsis">
      deform_SAC
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.field_lims" class="md-nav__link">
    <span class="md-ellipsis">
      field_lims
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.field_props" class="md-nav__link">
    <span class="md-ellipsis">
      field_props
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.fieldprops" class="md-nav__link">
    <span class="md-ellipsis">
      fieldprops
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_circular_regions" class="md-nav__link">
    <span class="md-ellipsis">
      get_circular_regions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_deformed_sac_gridscore" class="md-nav__link">
    <span class="md-ellipsis">
      get_deformed_sac_gridscore
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_expanding_circle_gridscore" class="md-nav__link">
    <span class="md-ellipsis">
      get_expanding_circle_gridscore
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_mean_resultant" class="md-nav__link">
    <span class="md-ellipsis">
      get_mean_resultant
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.get_thigmotaxis_score" class="md-nav__link">
    <span class="md-ellipsis">
      get_thigmotaxis_score
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.global_threshold" class="md-nav__link">
    <span class="md-ellipsis">
      global_threshold
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.grid_field_props" class="md-nav__link">
    <span class="md-ellipsis">
      grid_field_props
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.grid_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      grid_orientation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.gridness" class="md-nav__link">
    <span class="md-ellipsis">
      gridness
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.kl_spatial_sparsity" class="md-nav__link">
    <span class="md-ellipsis">
      kl_spatial_sparsity
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.kldiv" class="md-nav__link">
    <span class="md-ellipsis">
      kldiv
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.kldiv_dir" class="md-nav__link">
    <span class="md-ellipsis">
      kldiv_dir
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.limit_to_one" class="md-nav__link">
    <span class="md-ellipsis">
      limit_to_one
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.local_threshold" class="md-nav__link">
    <span class="md-ellipsis">
      local_threshold
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.partitionFields" class="md-nav__link">
    <span class="md-ellipsis">
      partitionFields
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.skaggs_info" class="md-nav__link">
    <span class="md-ellipsis">
      skaggs_info
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.fieldcalcs.spatial_sparsity" class="md-nav__link">
    <span class="md-ellipsis">
      spatial_sparsity
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-coding" class="md-nav__link">
    <span class="md-ellipsis">
      Phase coding
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding" class="md-nav__link">
    <span class="md-ellipsis">
      phasecoding
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D" class="md-nav__link">
    <span class="md-ellipsis">
      phasePrecession2D
    </span>
  </a>
  
    <nav class="md-nav" aria-label="phasePrecession2D">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D.getPosProps" class="md-nav__link">
    <span class="md-ellipsis">
      getPosProps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D.getThetaProps" class="md-nav__link">
    <span class="md-ellipsis">
      getThetaProps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D.performRegression" class="md-nav__link">
    <span class="md-ellipsis">
      performRegression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.phasePrecession2D.update_regressors" class="md-nav__link">
    <span class="md-ellipsis">
      update_regressors
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.ccc" class="md-nav__link">
    <span class="md-ellipsis">
      ccc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.ccc_jack" class="md-nav__link">
    <span class="md-ellipsis">
      ccc_jack
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.circCircCorrTLinear" class="md-nav__link">
    <span class="md-ellipsis">
      circCircCorrTLinear
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.circRegress" class="md-nav__link">
    <span class="md-ellipsis">
      circRegress
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.plot_spikes_in_runs_per_field" class="md-nav__link">
    <span class="md-ellipsis">
      plot_spikes_in_runs_per_field
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.phasecoding.shuffledPVal" class="md-nav__link">
    <span class="md-ellipsis">
      shuffledPVal
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rhymicity" class="md-nav__link">
    <span class="md-ellipsis">
      Rhymicity
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity" class="md-nav__link">
    <span class="md-ellipsis">
      rhythmicity
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning" class="md-nav__link">
    <span class="md-ellipsis">
      CosineDirectionalTuning
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CosineDirectionalTuning">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.spk_clusters" class="md-nav__link">
    <span class="md-ellipsis">
      spk_clusters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning._rolling_window" class="md-nav__link">
    <span class="md-ellipsis">
      _rolling_window
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.getDirectionalBinPerPosition" class="md-nav__link">
    <span class="md-ellipsis">
      getDirectionalBinPerPosition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.getRunsOfMinLength" class="md-nav__link">
    <span class="md-ellipsis">
      getRunsOfMinLength
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.intrinsic_freq_autoCorr" class="md-nav__link">
    <span class="md-ellipsis">
      intrinsic_freq_autoCorr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.power_spectrum" class="md-nav__link">
    <span class="md-ellipsis">
      power_spectrum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.CosineDirectionalTuning.speedFilterRuns" class="md-nav__link">
    <span class="md-ellipsis">
      speedFilterRuns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations" class="md-nav__link">
    <span class="md-ellipsis">
      LFPOscillations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="LFPOscillations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.filterForLaser" class="md-nav__link">
    <span class="md-ellipsis">
      filterForLaser
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.getFreqPhase" class="md-nav__link">
    <span class="md-ellipsis">
      getFreqPhase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.get_theta_phase" class="md-nav__link">
    <span class="md-ellipsis">
      get_theta_phase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.modulationindex" class="md-nav__link">
    <span class="md-ellipsis">
      modulationindex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.plv" class="md-nav__link">
    <span class="md-ellipsis">
      plv
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.spike_xy_phase_plot" class="md-nav__link">
    <span class="md-ellipsis">
      spike_xy_phase_plot
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.LFPOscillations.theta_running" class="md-nav__link">
    <span class="md-ellipsis">
      theta_running
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler" class="md-nav__link">
    <span class="md-ellipsis">
      Rippler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Rippler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._calc_ripple_chunks_duration_power" class="md-nav__link">
    <span class="md-ellipsis">
      _calc_ripple_chunks_duration_power
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._find_high_power_periods" class="md-nav__link">
    <span class="md-ellipsis">
      _find_high_power_periods
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._find_path_to_continuous" class="md-nav__link">
    <span class="md-ellipsis">
      _find_path_to_continuous
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._find_path_to_ripple_ttl" class="md-nav__link">
    <span class="md-ellipsis">
      _find_path_to_ripple_ttl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler._load_start_time" class="md-nav__link">
    <span class="md-ellipsis">
      _load_start_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler.filter_timestamps_for_real_ripples" class="md-nav__link">
    <span class="md-ellipsis">
      filter_timestamps_for_real_ripples
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler.plot_mean_rippleband_power" class="md-nav__link">
    <span class="md-ellipsis">
      plot_mean_rippleband_power
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.rhythmicity.Rippler.plot_mean_spectrogram" class="md-nav__link">
    <span class="md-ellipsis">
      plot_mean_spectrogram
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spike-calculations" class="md-nav__link">
    <span class="md-ellipsis">
      Spike calculations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs" class="md-nav__link">
    <span class="md-ellipsis">
      spikecalcs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsAxona" class="md-nav__link">
    <span class="md-ellipsis">
      SpikeCalcsAxona
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SpikeCalcsAxona">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsAxona.half_amp_dur" class="md-nav__link">
    <span class="md-ellipsis">
      half_amp_dur
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsAxona.p2t_time" class="md-nav__link">
    <span class="md-ellipsis">
      p2t_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsAxona.plotClusterSpace" class="md-nav__link">
    <span class="md-ellipsis">
      plotClusterSpace
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric" class="md-nav__link">
    <span class="md-ellipsis">
      SpikeCalcsGeneric
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SpikeCalcsGeneric">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.n_spikes" class="md-nav__link">
    <span class="md-ellipsis">
      n_spikes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.acorr" class="md-nav__link">
    <span class="md-ellipsis">
      acorr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.apply_filter" class="md-nav__link">
    <span class="md-ellipsis">
      apply_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_ifr" class="md-nav__link">
    <span class="md-ellipsis">
      get_ifr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_ifr_power_spectrum" class="md-nav__link">
    <span class="md-ellipsis">
      get_ifr_power_spectrum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.ifr_sp_corr" class="md-nav__link">
    <span class="md-ellipsis">
      ifr_sp_corr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.mean_isi_range" class="md-nav__link">
    <span class="md-ellipsis">
      mean_isi_range
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.mean_waveform" class="md-nav__link">
    <span class="md-ellipsis">
      mean_waveform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.psch" class="md-nav__link">
    <span class="md-ellipsis">
      psch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.psth" class="md-nav__link">
    <span class="md-ellipsis">
      psth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.responds_to_stimulus" class="md-nav__link">
    <span class="md-ellipsis">
      responds_to_stimulus
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.smooth_spike_train" class="md-nav__link">
    <span class="md-ellipsis">
      smooth_spike_train
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_band_max_freq" class="md-nav__link">
    <span class="md-ellipsis">
      theta_band_max_freq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idx" class="md-nav__link">
    <span class="md-ellipsis">
      theta_mod_idx
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idxV2" class="md-nav__link">
    <span class="md-ellipsis">
      theta_mod_idxV2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idxV3" class="md-nav__link">
    <span class="md-ellipsis">
      theta_mod_idxV3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.update_KSMeta" class="md-nav__link">
    <span class="md-ellipsis">
      update_KSMeta
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys" class="md-nav__link">
    <span class="md-ellipsis">
      SpikeCalcsOpenEphys
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SpikeCalcsOpenEphys">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys.get_channel_depth_from_templates" class="md-nav__link">
    <span class="md-ellipsis">
      get_channel_depth_from_templates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys.get_template_id_for_cluster" class="md-nav__link">
    <span class="md-ellipsis">
      get_template_id_for_cluster
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys.get_waveforms" class="md-nav__link">
    <span class="md-ellipsis">
      get_waveforms
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.SpikeCalcsProbe" class="md-nav__link">
    <span class="md-ellipsis">
      SpikeCalcsProbe
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.cluster_quality" class="md-nav__link">
    <span class="md-ellipsis">
      cluster_quality
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.contamination_percent" class="md-nav__link">
    <span class="md-ellipsis">
      contamination_percent
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.fit_smoothed_curve_to_xcorr" class="md-nav__link">
    <span class="md-ellipsis">
      fit_smoothed_curve_to_xcorr
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.get_param" class="md-nav__link">
    <span class="md-ellipsis">
      get_param
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.mahal" class="md-nav__link">
    <span class="md-ellipsis">
      mahal
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.spikecalcs.xcorr" class="md-nav__link">
    <span class="md-ellipsis">
      xcorr
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#statistics" class="md-nav__link">
    <span class="md-ellipsis">
      Statistics
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs" class="md-nav__link">
    <span class="md-ellipsis">
      statscalcs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.V_test" class="md-nav__link">
    <span class="md-ellipsis">
      V_test
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.circ_r" class="md-nav__link">
    <span class="md-ellipsis">
      circ_r
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.duplicates_as_complex" class="md-nav__link">
    <span class="md-ellipsis">
      duplicates_as_complex
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.mean_resultant_vector" class="md-nav__link">
    <span class="md-ellipsis">
      mean_resultant_vector
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.watsonWilliams" class="md-nav__link">
    <span class="md-ellipsis">
      watsonWilliams
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.watsonsU2" class="md-nav__link">
    <span class="md-ellipsis">
      watsonsU2
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.statscalcs.watsonsU2n" class="md-nav__link">
    <span class="md-ellipsis">
      watsonsU2n
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#utility-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Utility functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils" class="md-nav__link">
    <span class="md-ellipsis">
      utils
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.BinnedData" class="md-nav__link">
    <span class="md-ellipsis">
      BinnedData
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BinnedData">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.BinnedData.correlate" class="md-nav__link">
    <span class="md-ellipsis">
      correlate
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.applyFilter2Labels" class="md-nav__link">
    <span class="md-ellipsis">
      applyFilter2Labels
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.blur_image" class="md-nav__link">
    <span class="md-ellipsis">
      blur_image
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.bwperim" class="md-nav__link">
    <span class="md-ellipsis">
      bwperim
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.clean_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      clean_kwargs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.corr_maps" class="md-nav__link">
    <span class="md-ellipsis">
      corr_maps
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.count_runs_and_unique_numbers" class="md-nav__link">
    <span class="md-ellipsis">
      count_runs_and_unique_numbers
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.count_to" class="md-nav__link">
    <span class="md-ellipsis">
      count_to
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.find_runs" class="md-nav__link">
    <span class="md-ellipsis">
      find_runs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.fixAngle" class="md-nav__link">
    <span class="md-ellipsis">
      fixAngle
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.get_z_score" class="md-nav__link">
    <span class="md-ellipsis">
      get_z_score
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.min_max_norm" class="md-nav__link">
    <span class="md-ellipsis">
      min_max_norm
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.polar" class="md-nav__link">
    <span class="md-ellipsis">
      polar
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.rect" class="md-nav__link">
    <span class="md-ellipsis">
      rect
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.remap_to_range" class="md-nav__link">
    <span class="md-ellipsis">
      remap_to_range
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.repeat_ind" class="md-nav__link">
    <span class="md-ellipsis">
      repeat_ind
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.shift_vector" class="md-nav__link">
    <span class="md-ellipsis">
      shift_vector
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.smooth" class="md-nav__link">
    <span class="md-ellipsis">
      smooth
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.common.utils.window_rms" class="md-nav__link">
    <span class="md-ellipsis">
      window_rms
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#axona-input-output" class="md-nav__link">
    <span class="md-ellipsis">
      Axona input/ output
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO" class="md-nav__link">
    <span class="md-ellipsis">
      axonaIO
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.ClusterSession" class="md-nav__link">
    <span class="md-ellipsis">
      ClusterSession
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.EEG" class="md-nav__link">
    <span class="md-ellipsis">
      EEG
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO" class="md-nav__link">
    <span class="md-ellipsis">
      IO
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IO">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getCluCut" class="md-nav__link">
    <span class="md-ellipsis">
      getCluCut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getCut" class="md-nav__link">
    <span class="md-ellipsis">
      getCut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getData" class="md-nav__link">
    <span class="md-ellipsis">
      getData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getHeader" class="md-nav__link">
    <span class="md-ellipsis">
      getHeader
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.getHeaderVal" class="md-nav__link">
    <span class="md-ellipsis">
      getHeaderVal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.setData" class="md-nav__link">
    <span class="md-ellipsis">
      setData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.IO.setHeader" class="md-nav__link">
    <span class="md-ellipsis">
      setHeader
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Pos" class="md-nav__link">
    <span class="md-ellipsis">
      Pos
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Stim" class="md-nav__link">
    <span class="md-ellipsis">
      Stim
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode" class="md-nav__link">
    <span class="md-ellipsis">
      Tetrode
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Tetrode">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.apply_mask" class="md-nav__link">
    <span class="md-ellipsis">
      apply_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getClustIdx" class="md-nav__link">
    <span class="md-ellipsis">
      getClustIdx
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getClustSpks" class="md-nav__link">
    <span class="md-ellipsis">
      getClustSpks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getClustTS" class="md-nav__link">
    <span class="md-ellipsis">
      getClustTS
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getPosSamples" class="md-nav__link">
    <span class="md-ellipsis">
      getPosSamples
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getSpkTS" class="md-nav__link">
    <span class="md-ellipsis">
      getSpkTS
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.axona.axonaIO.Tetrode.getUniqueClusters" class="md-nav__link">
    <span class="md-ellipsis">
      getUniqueClusters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conversion-code" class="md-nav__link">
    <span class="md-ellipsis">
      Conversion code
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Conversion code">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#openephys-to-axona" class="md-nav__link">
    <span class="md-ellipsis">
      OpenEphys to Axona
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona" class="md-nav__link">
    <span class="md-ellipsis">
      OE_Axona
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona" class="md-nav__link">
    <span class="md-ellipsis">
      OE2Axona
    </span>
  </a>
  
    <nav class="md-nav" aria-label="OE2Axona">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.settings" class="md-nav__link">
    <span class="md-ellipsis">
      settings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.convertPosData" class="md-nav__link">
    <span class="md-ellipsis">
      convertPosData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.convertSpikeData" class="md-nav__link">
    <span class="md-ellipsis">
      convertSpikeData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.convertTemplateDataToAxonaTetrode" class="md-nav__link">
    <span class="md-ellipsis">
      convertTemplateDataToAxonaTetrode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.exportLFP" class="md-nav__link">
    <span class="md-ellipsis">
      exportLFP
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.exportSetFile" class="md-nav__link">
    <span class="md-ellipsis">
      exportSetFile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.getOEData" class="md-nav__link">
    <span class="md-ellipsis">
      getOEData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.makeLFPData" class="md-nav__link">
    <span class="md-ellipsis">
      makeLFPData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_Axona.OE2Axona.resample" class="md-nav__link">
    <span class="md-ellipsis">
      resample
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#openephys-to-numpy" class="md-nav__link">
    <span class="md-ellipsis">
      OpenEphys to numpy
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy" class="md-nav__link">
    <span class="md-ellipsis">
      OE_numpy
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy.OE2Numpy" class="md-nav__link">
    <span class="md-ellipsis">
      OE2Numpy
    </span>
  </a>
  
    <nav class="md-nav" aria-label="OE2Numpy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy.OE2Numpy.settings" class="md-nav__link">
    <span class="md-ellipsis">
      settings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy.OE2Numpy.getOEData" class="md-nav__link">
    <span class="md-ellipsis">
      getOEData
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ephysiopy.format_converters.OE_numpy.OE2Numpy.resample" class="md-nav__link">
    <span class="md-ellipsis">
      resample
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>Reference</h1>

<h2 id="recording-data">Recording data</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.io.recording"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.io.recording.AxonaTrial" class="doc doc-heading">
            <code>AxonaTrial</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ephysiopy.io.recording.TrialInterface" href="#ephysiopy.io.recording.TrialInterface">TrialInterface</a></code></p>







              <details class="quote">
                <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">AxonaTrial</span><span class="p">(</span><span class="n">TrialInterface</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_volts</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;volts&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">pname</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span> <span class="o">=</span> <span class="n">TetrodeDict</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)),</span> <span class="n">volts</span><span class="o">=</span><span class="n">use_volts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_settings</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">load_lfp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.axona.axonaIO</span> <span class="kn">import</span> <span class="n">EEG</span>

        <span class="k">if</span> <span class="s2">&quot;egf&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">lfp</span> <span class="o">=</span> <span class="n">EEG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">,</span> <span class="n">egf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lfp</span> <span class="o">=</span> <span class="n">EEG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lfp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span> <span class="o">=</span> <span class="n">EEGCalcsGeneric</span><span class="p">(</span><span class="n">lfp</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="n">lfp</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_neural_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;tetrode&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">use_volts</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;volts&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;tetrode&quot;</span><span class="p">],</span> <span class="n">use_volts</span><span class="p">]</span>  <span class="c1"># lazy load</span>

    <span class="k">def</span> <span class="nf">load_cluster_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_available_clusters_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">clust_chans</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># only other key is &#39;volts&#39;</span>
                <span class="n">clust_chans</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">clust_chans</span>

    <span class="k">def</span> <span class="nf">load_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">settings_io</span> <span class="o">=</span> <span class="n">IO</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings_io</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;.set file not loaded&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">load_pos_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ppm</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">jumpmax</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">AxonaPos</span> <span class="o">=</span> <span class="n">Pos</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">))</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">PosCalcsGeneric</span><span class="p">(</span>
                <span class="n">AxonaPos</span><span class="o">.</span><span class="n">led_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">AxonaPos</span><span class="o">.</span><span class="n">led_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">cm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">ppm</span><span class="o">=</span><span class="n">ppm</span><span class="p">,</span>
                <span class="n">jumpmax</span><span class="o">=</span><span class="n">jumpmax</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">P</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">AxonaPos</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="n">AxonaPos</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;sample_rate&quot;</span><span class="p">)</span>
            <span class="n">P</span><span class="o">.</span><span class="n">xyTS</span> <span class="o">=</span> <span class="n">AxonaPos</span><span class="o">.</span><span class="n">ts</span> <span class="o">/</span> <span class="n">P</span><span class="o">.</span><span class="n">sample_rate</span>  <span class="c1"># in seconds now</span>
            <span class="n">P</span><span class="o">.</span><span class="n">postprocesspos</span><span class="p">(</span><span class="n">tracker_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;SampleRate&quot;</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">})</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded pos data&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span> <span class="o">=</span> <span class="n">P</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t load the pos data&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_ttl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.axona.axonaIO</span> <span class="kn">import</span> <span class="n">Stim</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span> <span class="o">=</span> <span class="n">Stim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">)</span>
            <span class="c1"># ttl times in Stim are in ms</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded ttl data&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_spike_times</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            tetrode (int | list):</span>
<span class="sd">            cluster (int | list):</span>

<span class="sd">        Returns:</span>
<span class="sd">            spike_times (np.ndarray):</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tetrode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">get_spike_samples</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tetrode</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">tetrode</span> <span class="o">=</span> <span class="n">tetrode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">get_spike_samples</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tetrode</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">spikes</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">tc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
                        <span class="n">spikes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">get_spike_samples</span><span class="p">(</span><span class="n">tc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tc</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">return</span> <span class="n">spikes</span>

    <span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_filter</span><span class="p">:</span> <span class="n">TrialFilter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a mask to the data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trial_filter (TrialFilter): A namedtuple containing the filter</span>
<span class="sd">            name, start and end values:</span>
<span class="sd">                name (str): The name of the filter</span>
<span class="sd">                start (float): The start value of the filter</span>
<span class="sd">                end (float): The end value of the filter</span>

<span class="sd">            Valid names are:</span>
<span class="sd">                &#39;dir&#39; - the directional range to filter for</span>
<span class="sd">                &#39;speed&#39; - min and max speed to filter for</span>
<span class="sd">                &#39;xrange&#39; - min and max values to filter x pos values</span>
<span class="sd">                &#39;yrange&#39; - same as xrange but for y pos</span>
<span class="sd">                &#39;time&#39; - the times to keep / remove specified in ms</span>

<span class="sd">            Values are pairs specifying the range of values to filter for</span>
<span class="sd">            from the namedtuple TrialFilter that has fields &#39;start&#39; and &#39;end&#39;</span>
<span class="sd">            where &#39;start&#39; and &#39;end&#39; are the ranges to filter for</span>

<span class="sd">            See ephysiopy.common.utils.TrialFilter for more details</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray: An array of bools that is True where the mask is applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply_filter</span><span class="p">(</span><span class="o">*</span><span class="n">trial_filter</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tetrode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span>
                    <span class="n">mask</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.AxonaTrial.apply_filter" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">apply_filter</span><span class="p">(</span><span class="o">*</span><span class="n">trial_filter</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply a mask to the data</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>trial_filter</code>
            </td>
            <td>
                  <code><span title="ephysiopy.common.utils.TrialFilter">TrialFilter</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>name, start and end values:
    name (str): The name of the filter
    start (float): The start value of the filter
    end (float): The end value of the filter</p>
<p>Valid names are:
    'dir' - the directional range to filter for
    'speed' - min and max speed to filter for
    'xrange' - min and max values to filter x pos values
    'yrange' - same as xrange but for y pos
    'time' - the times to keep / remove specified in ms</p>
<p>Values are pairs specifying the range of values to filter for
from the namedtuple TrialFilter that has fields 'start' and 'end'
where 'start' and 'end' are the ranges to filter for</p>
<p>See ephysiopy.common.utils.TrialFilter for more details</p>
              </div>
            </td>
            <td>
                  <code>()</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>np.ndarray: An array of bools that is True where the mask is applied</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_filter</span><span class="p">:</span> <span class="n">TrialFilter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a mask to the data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trial_filter (TrialFilter): A namedtuple containing the filter</span>
<span class="sd">        name, start and end values:</span>
<span class="sd">            name (str): The name of the filter</span>
<span class="sd">            start (float): The start value of the filter</span>
<span class="sd">            end (float): The end value of the filter</span>

<span class="sd">        Valid names are:</span>
<span class="sd">            &#39;dir&#39; - the directional range to filter for</span>
<span class="sd">            &#39;speed&#39; - min and max speed to filter for</span>
<span class="sd">            &#39;xrange&#39; - min and max values to filter x pos values</span>
<span class="sd">            &#39;yrange&#39; - same as xrange but for y pos</span>
<span class="sd">            &#39;time&#39; - the times to keep / remove specified in ms</span>

<span class="sd">        Values are pairs specifying the range of values to filter for</span>
<span class="sd">        from the namedtuple TrialFilter that has fields &#39;start&#39; and &#39;end&#39;</span>
<span class="sd">        where &#39;start&#39; and &#39;end&#39; are the ranges to filter for</span>

<span class="sd">        See ephysiopy.common.utils.TrialFilter for more details</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray: An array of bools that is True where the mask is applied</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply_filter</span><span class="p">(</span><span class="o">*</span><span class="n">trial_filter</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tetrode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span>
                <span class="n">mask</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.AxonaTrial.get_spike_times" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tetrode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Parameters:
    tetrode (int | list):
    cluster (int | list):</p>
<p>Returns:
    spike_times (np.ndarray):</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spike_times</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters:</span>
<span class="sd">        tetrode (int | list):</span>
<span class="sd">        cluster (int | list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        spike_times (np.ndarray):</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tetrode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">get_spike_samples</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tetrode</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tetrode</span> <span class="o">=</span> <span class="n">tetrode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">get_spike_samples</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tetrode</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spikes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">tc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
                    <span class="n">spikes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">get_spike_samples</span><span class="p">(</span><span class="n">tc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tc</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">spikes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.io.recording.OpenEphysBase" class="doc doc-heading">
            <code>OpenEphysBase</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ephysiopy.io.recording.TrialInterface" href="#ephysiopy.io.recording.TrialInterface">TrialInterface</a></code></p>







              <details class="quote">
                <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">OpenEphysBase</span><span class="p">(</span><span class="n">TrialInterface</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pname</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;sync_message_file&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_settings</span><span class="p">()</span>
        <span class="c1"># The numbers after the strings in this list are the node id&#39;s</span>
        <span class="c1"># in openephys</span>
        <span class="n">record_methods</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Acquisition Board [0-9][0-9][0-9]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Acquisition Board&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Neuropix-PXI [0-9][0-9][0-9]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Neuropix-PXI&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Sources/Neuropix-PXI [0-9][0-9][0-9]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Rhythm FPGA [0-9][0-9][0-9]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Rhythm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Sources/Rhythm FPGA [0-9][0-9][0-9]&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">rec_method</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">string</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">record_methods</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;Sources/&quot;</span> <span class="ow">in</span> <span class="n">rec_method</span><span class="p">:</span>
            <span class="n">rec_method</span> <span class="o">=</span> <span class="n">rec_method</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;Sources/&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rec_kind</span> <span class="o">=</span> <span class="n">Xml2RecordingKind</span><span class="p">[</span><span class="n">rec_method</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># Attempt to find the files contained in the parent directory</span>
        <span class="c1"># related to the recording with the default experiment and</span>
        <span class="c1"># recording name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">find_files</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="p">[</span><span class="n">rec_method</span><span class="p">]</span><span class="o">.</span><span class="n">sample_rate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec_kind</span> <span class="o">==</span> <span class="n">RecordingKind</span><span class="o">.</span><span class="n">NEUROPIXELS</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="mi">30000</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># rubbish fix - many strs need casting to int/float</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="p">[</span><span class="n">rec_method</span><span class="p">]</span><span class="o">.</span><span class="n">channel_count</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec_kind</span> <span class="o">==</span> <span class="n">RecordingKind</span><span class="o">.</span><span class="n">NEUROPIXELS</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="o">=</span> <span class="mi">384</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kilodata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">template_model</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_recording_start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the recording start time from the sync_messages.txt file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        start_time (float) - in seconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">recording_start_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_message_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sync_message_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">sync_strs</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">sync_lines</span> <span class="o">=</span> <span class="n">sync_strs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sync_lines</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;Start Time&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                    <span class="n">start_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">start_time</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">recording_start_time</span>
        <span class="k">return</span> <span class="n">recording_start_time</span>

    <span class="k">def</span> <span class="nf">get_spike_times</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster (int| list)</span>
<span class="sd">        tetrode (int | list)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spike_times (list | np.ndarray): in seconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_cluster_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">spk_clusters</span><span class="p">:</span>
                <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">get_cluster_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">times</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cluster not present&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">times</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">spk_clusters</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">get_cluster_spike_times</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cluster not present&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">times</span>

    <span class="k">def</span> <span class="nf">load_lfp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Valid kwargs are:</span>
<span class="sd">        &#39;target_sample_rate&#39; - int</span>
<span class="sd">            the sample rate to downsample to from the original</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lfp</span> <span class="o">=</span> <span class="n">memmapBinaryFile</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span><span class="p">,</span> <span class="s2">&quot;continuous.dat&quot;</span><span class="p">),</span>
                <span class="n">n_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># set the target sample rate to 250Hz by default to match</span>
            <span class="c1"># Axona EEG data</span>
            <span class="n">target_sample_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;target_sample_rate&quot;</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">target_sample_rate</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">lfp</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                <span class="n">target_sample_rate</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span> <span class="o">=</span> <span class="n">EEGCalcsGeneric</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">target_sample_rate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_neural_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;path2APdata&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;path2APdata&quot;</span><span class="p">])</span>
        <span class="n">n_channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nChannels&quot;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_model</span> <span class="o">=</span> <span class="n">TemplateModel</span><span class="p">(</span>
                <span class="n">dir_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">,</span>
                <span class="n">sample_rate</span><span class="o">=</span><span class="mf">3e4</span><span class="p">,</span>
                <span class="n">dat_path</span><span class="o">=</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s2">&quot;continuous.dat&quot;</span><span class="p">),</span>
                <span class="n">n_channels_dat</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">n_channels</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded neural data&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Could not find raw data file&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># pname_root gets walked through and over-written with</span>
            <span class="c1"># correct location of settings.xml</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded settings data</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_available_clusters_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_neural_data</span><span class="p">()</span>
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template_model</span><span class="o">.</span><span class="n">spike_clusters</span><span class="p">)</span>
        <span class="n">clust_chans</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template_model</span><span class="o">.</span><span class="n">clusters_channels</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">clust_id</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template_model</span><span class="o">.</span><span class="n">clusters_channels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">clust_id</span> <span class="ow">in</span> <span class="n">unique_clusters</span><span class="p">:</span>
                <span class="n">clust_chans</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">ch</span>
                    <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template_model</span><span class="o">.</span><span class="n">clusters_channels</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cl</span> <span class="o">==</span> <span class="n">chan</span>
                <span class="p">]</span>

        <span class="k">return</span> <span class="n">clust_chans</span>

    <span class="k">def</span> <span class="nf">load_cluster_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">removeNoiseClusters</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2KiloSortData</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clusterData</span> <span class="o">=</span> <span class="n">KiloSortSession</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">clusterData</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">clusterData</span><span class="o">.</span><span class="n">load</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded KiloSort data&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">removeNoiseClusters</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">clusterData</span><span class="o">.</span><span class="n">removeKSNoiseClusters</span><span class="p">()</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removed noise clusters&quot;</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span> <span class="o">=</span> <span class="n">clusterData</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">load_pos_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ppm</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">jumpmax</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># kwargs valid keys = &quot;loadTTLPos&quot; - if present loads the ttl</span>
        <span class="c1"># timestamps not the ones in the plugin folder</span>

        <span class="c1"># Only sub-class that doesn&#39;t use this is OpenEphysNWB</span>
        <span class="c1"># which needs updating</span>
        <span class="c1"># TODO: Update / overhaul OpenEphysNWB</span>
        <span class="c1"># Load the start time from the sync_messages file</span>
        <span class="k">if</span> <span class="s2">&quot;cm&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;cm&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">recording_start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_recording_start_time</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos_method</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;Pos Tracker [0-9][0-9][0-9]&quot;</span><span class="p">,</span>
                <span class="s2">&quot;PosTracker [0-9][0-9][0-9]&quot;</span><span class="p">,</span>
                <span class="s2">&quot;TrackMe [0-9][0-9][0-9]&quot;</span><span class="p">,</span>
                <span class="s2">&quot;TrackingPlugin [0-9][0-9][0-9]&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Tracking Port&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">pos_plugin_name</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">string</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">pos_method</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;Sources/&quot;</span> <span class="ow">in</span> <span class="n">pos_plugin_name</span><span class="p">:</span>
                <span class="n">pos_plugin_name</span> <span class="o">=</span> <span class="n">pos_plugin_name</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;Sources/&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pos_plugin_name</span> <span class="o">=</span> <span class="n">pos_plugin_name</span>

            <span class="k">if</span> <span class="s2">&quot;Tracker&quot;</span> <span class="ow">in</span> <span class="n">pos_plugin_name</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading Tracker data...&quot;</span><span class="p">)</span>
                <span class="n">pos_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="p">,</span> <span class="s2">&quot;data_array.npy&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="s2">&quot;Tracking Port&quot;</span> <span class="ow">in</span> <span class="n">pos_plugin_name</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading Tracking Port data...&quot;</span><span class="p">)</span>
                <span class="n">pos_data</span> <span class="o">=</span> <span class="n">loadTrackingPluginData</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="p">,</span> <span class="s2">&quot;data_array.npy&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;TrackingPlugin&quot;</span> <span class="ow">in</span> <span class="n">pos_plugin_name</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading TrackingPlugin data...&quot;</span><span class="p">)</span>
                <span class="n">pos_data</span> <span class="o">=</span> <span class="n">loadTrackingPluginData</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="p">,</span> <span class="s2">&quot;data_array.npy&quot;</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">pos_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="p">,</span> <span class="s2">&quot;timestamps.npy&quot;</span><span class="p">))</span>
            <span class="c1"># pos_ts in seconds</span>
            <span class="n">pos_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">pos_ts</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;TrackMe&quot;</span> <span class="ow">in</span> <span class="n">pos_plugin_name</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading TrackMe data...&quot;</span><span class="p">)</span>
                <span class="n">n_pos_chans</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="p">[</span><span class="n">pos_plugin_name</span><span class="p">]</span><span class="o">.</span><span class="n">channel_count</span>
                <span class="p">)</span>
                <span class="n">pos_data</span> <span class="o">=</span> <span class="n">loadTrackMePluginData</span><span class="p">(</span>
                    <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="p">,</span> <span class="s2">&quot;continuous.dat&quot;</span><span class="p">)),</span>
                    <span class="n">n_channels</span><span class="o">=</span><span class="n">n_pos_chans</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;loadTTLPos&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">pos_ts</span> <span class="o">=</span> <span class="n">loadTrackMeTTLTimestamps</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2EventsData</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pos_ts</span> <span class="o">=</span> <span class="n">loadTrackMeTimestamps</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="p">))</span>
                <span class="n">pos_ts</span> <span class="o">=</span> <span class="n">pos_ts</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_data</span><span class="p">)]</span>
            <span class="n">sample_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="p">[</span><span class="n">pos_plugin_name</span><span class="p">]</span><span class="o">.</span><span class="n">sample_rate</span>
            <span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span> <span class="k">if</span> <span class="n">sample_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">50</span>
            <span class="c1"># the timestamps for the Tracker Port plugin are fucked so</span>
            <span class="c1"># we have to infer from the shape of the position data</span>
            <span class="k">if</span> <span class="s2">&quot;Tracking Port&quot;</span> <span class="ow">in</span> <span class="n">pos_plugin_name</span><span class="p">:</span>
                <span class="n">sample_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sample_rate&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="mi">50</span>
                <span class="c1"># pos_ts in seconds</span>
                <span class="n">pos_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sample_rate</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;TrackMe&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pos_plugin_name</span><span class="p">:</span>
                <span class="n">xyTS</span> <span class="o">=</span> <span class="n">pos_ts</span> <span class="o">-</span> <span class="n">recording_start_time</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xyTS</span> <span class="o">=</span> <span class="n">pos_ts</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_message_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">xyTS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">PosCalcsGeneric</span><span class="p">(</span>
                <span class="n">pos_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">pos_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">cm</span><span class="o">=</span><span class="n">cm</span><span class="p">,</span>
                <span class="n">ppm</span><span class="o">=</span><span class="n">ppm</span><span class="p">,</span>
                <span class="n">jumpmax</span><span class="o">=</span><span class="n">jumpmax</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">P</span><span class="o">.</span><span class="n">xyTS</span> <span class="o">=</span> <span class="n">xyTS</span>
            <span class="n">P</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">sample_rate</span>
            <span class="n">P</span><span class="o">.</span><span class="n">postprocesspos</span><span class="p">({</span><span class="s2">&quot;SampleRate&quot;</span><span class="p">:</span> <span class="n">sample_rate</span><span class="p">})</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded pos data&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span> <span class="o">=</span> <span class="n">P</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Could not find the pos data. </span><span class="se">\</span>
<span class="s2">                Make sure there is a pos_data folder with data_array.npy </span><span class="se">\</span>
<span class="s2">                and timestamps.npy in&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">recording_start_time</span>

    <span class="k">def</span> <span class="nf">load_ttl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loaded (bool) - whether the data was loaded or not</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Valid kwargs:</span>
<span class="sd">            StimControl_id (str): This is the string</span>
<span class="sd">                &quot;StimControl [0-9][0-9][0-9]&quot; where the numbers</span>
<span class="sd">                are the node id in the openephys signal chain</span>
<span class="sd">            TTL_channel_number (int): The integer value in the &quot;states.npy&quot;</span>
<span class="sd">                file that corresponds to the</span>
<span class="sd">                identity of the TTL input on the Digital I/O board on the</span>
<span class="sd">                openephys recording system. i.e. if there is input to BNC</span>
<span class="sd">                port 3 on the digital I/O board then values of 3 in the</span>
<span class="sd">                states.npy file are high TTL values on this input and -3</span>
<span class="sd">                are low TTL values. NB This is important as there could well</span>
<span class="sd">                be other TTL lines that are active and so the states vector</span>
<span class="sd">                will then contain a mix of integer values</span>
<span class="sd">            RippleDetector (str): Loads up the TTL data from the Ripple Detector</span>
<span class="sd">                plugin</span>

<span class="sd">        Sets some keys/values in a dict on &#39;self&#39;</span>
<span class="sd">        called ttl_data, namely:</span>

<span class="sd">        ttl_timestamps (list): the times of high ttl pulses in ms</span>
<span class="sd">        stim_duration (int): the duration of the ttl pulse in ms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2EventsData</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">ttl_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2EventsData</span><span class="p">,</span> <span class="s2">&quot;timestamps.npy&quot;</span><span class="p">))</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2EventsData</span><span class="p">,</span> <span class="s2">&quot;states.npy&quot;</span><span class="p">))</span>
        <span class="n">recording_start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_recording_start_time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s2">&quot;StimControl_id&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">stim_id</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;StimControl_id&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">stim_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">duration</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="p">[</span><span class="n">stim_id</span><span class="p">],</span> <span class="s2">&quot;Duration&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;stim_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;TTL_channel_number&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;TTL_channel_number&quot;</span><span class="p">]</span>
            <span class="n">high_ttl</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">states</span> <span class="o">==</span> <span class="n">chan</span><span class="p">]</span>
            <span class="c1"># get into seconds</span>
            <span class="n">high_ttl</span> <span class="o">=</span> <span class="p">(</span><span class="n">high_ttl</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">recording_start_time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">high_ttl</span> <span class="o">/</span> <span class="mf">1000.0</span>  <span class="c1"># in seconds now</span>
        <span class="k">if</span> <span class="s2">&quot;RippleDetector&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2RippleDetector</span><span class="p">:</span>
                <span class="n">detector_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">get_processor</span><span class="p">(</span><span class="s2">&quot;Ripple&quot;</span><span class="p">)</span>
                <span class="n">ttl_ts</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2RippleDetector</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;timestamps.npy&quot;</span><span class="p">)</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">recording_start_time</span>
                <span class="p">)</span>
                <span class="n">ttl_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2RippleDetector</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;states.npy&quot;</span><span class="p">)</span>
                <span class="n">save_ttl</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_save</span><span class="p">)</span>
                <span class="n">out_ttl</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_Out</span><span class="p">)</span>
                <span class="n">indices_to_throw</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ttl_states</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">i_pair</span> <span class="o">=</span> <span class="n">ttl_states</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">i_pair</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">save_ttl</span><span class="p">,</span> <span class="n">out_ttl</span><span class="p">])):</span>
                        <span class="c1"># be extra sure this is a zero time difference</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ttl_ts</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">indices_to_throw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ttl_states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">indices_to_throw</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">ttl_ts</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">ttl_states</span> <span class="o">=</span> <span class="n">ttl_states</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

                <span class="n">laser_ons</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="n">out_ttl</span><span class="p">]</span>
                <span class="n">laser_offs</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="o">-</span><span class="n">out_ttl</span><span class="p">]</span>
                <span class="n">no_laser_ons</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="n">save_ttl</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laser_ons</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps_off&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laser_offs</span>
                <span class="n">mean_duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">laser_offs</span> <span class="o">-</span> <span class="n">laser_ons</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;stim_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_duration</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;no_laser_ttls&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">no_laser_ons</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded ttl data&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">load_accelerometer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Need to figure out which of the channels are AUX if we want to load</span>
<span class="sd">        the accelerometer data with minimal user input...</span>
<span class="sd">        Annoyingly, there could also be more than one RecordNode which means</span>
<span class="sd">        the channels might get represented more than once in the structure.oebin</span>
<span class="sd">        file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_freq (int) - the desired frequency when downsampling the aux data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.openephys2py.OESettings</span> <span class="kn">import</span> <span class="n">OEStructure</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.common.ephys_generic</span> <span class="kn">import</span> <span class="n">downsample_aux</span>

        <span class="n">oebin</span> <span class="o">=</span> <span class="n">OEStructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">)</span>
        <span class="n">aux_chan_nums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">aux_bitvolts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">record_node_key</span> <span class="ow">in</span> <span class="n">oebin</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">channel_key</span> <span class="ow">in</span> <span class="n">oebin</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">record_node_key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># this thing is a 1-item list</span>
                <span class="k">if</span> <span class="s2">&quot;continuous&quot;</span> <span class="ow">in</span> <span class="n">channel_key</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">chan_keys</span> <span class="ow">in</span> <span class="n">oebin</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">record_node_key</span><span class="p">][</span><span class="n">channel_key</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">chan_idx</span><span class="p">,</span> <span class="n">i_chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                            <span class="n">oebin</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">record_node_key</span><span class="p">][</span><span class="n">channel_key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;channels&quot;</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="k">if</span> <span class="s2">&quot;AUX&quot;</span> <span class="ow">in</span> <span class="n">i_chan</span><span class="p">[</span><span class="s2">&quot;channel_name&quot;</span><span class="p">]:</span>
                                <span class="n">aux_chan_nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chan_idx</span><span class="p">)</span>
                                <span class="n">aux_bitvolts</span> <span class="o">=</span> <span class="n">i_chan</span><span class="p">[</span><span class="s2">&quot;bit_volts&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_chan_nums</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">aux_chan_nums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">aux_chan_nums</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">memmapBinaryFile</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span><span class="p">,</span> <span class="s2">&quot;continuous.dat&quot;</span><span class="p">),</span>
                    <span class="n">n_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">aux_chan_nums</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">aux_chan_nums</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">aux_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># now downsample the aux data a lot</span>
                <span class="c1"># might take a while so print a message to console</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Downsampling </span><span class="si">{</span><span class="n">aux_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> samples over </span><span class="si">{</span><span class="n">aux_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> channels...&quot;</span>
                <span class="p">)</span>
                <span class="n">aux_data</span> <span class="o">=</span> <span class="n">downsample_aux</span><span class="p">(</span><span class="n">aux_data</span><span class="p">,</span> <span class="n">target_freq</span><span class="o">=</span><span class="n">target_freq</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span> <span class="o">=</span> <span class="n">aux_data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aux_data_fs</span> <span class="o">=</span> <span class="n">target_freq</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aux_bitvolts</span> <span class="o">=</span> <span class="n">aux_bitvolts</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No AUX data found in structure.oebin file, so not loaded&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_filter</span><span class="p">:</span> <span class="n">TrialFilter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a mask to the data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trial_filter (TrialFilter): A namedtuple containing the filter</span>
<span class="sd">            name, start and end values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            np.array: An array of bools that is True where the mask is applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply_filter</span><span class="p">(</span><span class="o">*</span><span class="n">trial_filter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">find_files</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pname_root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span><span class="p">,</span>
        <span class="n">experiment_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;experiment1&quot;</span><span class="p">,</span>
        <span class="n">rec_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;recording1&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">exp_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">experiment_name</span><span class="p">)</span>
        <span class="n">PosTracker_match</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;events&quot;</span> <span class="o">/</span> <span class="s2">&quot;*Pos_Tracker*/BINARY_group*&quot;</span>
        <span class="p">)</span>
        <span class="n">TrackingPlugin_match</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;events&quot;</span> <span class="o">/</span> <span class="s2">&quot;*Tracking_Port*/BINARY_group*&quot;</span>
        <span class="p">)</span>
        <span class="n">TrackMe_match</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="s2">&quot;TrackMe-[0-9][0-9][0-9].TrackingNode&quot;</span>
        <span class="p">)</span>
        <span class="n">RippleDetector_match</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;events&quot;</span> <span class="o">/</span> <span class="s2">&quot;Ripple_Detector*&quot;</span> <span class="o">/</span> <span class="s2">&quot;TTL&quot;</span>
        <span class="p">)</span>
        <span class="n">sync_file_match</span> <span class="o">=</span> <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span>
        <span class="n">acq_method</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec_kind</span> <span class="o">==</span> <span class="n">RecordingKind</span><span class="o">.</span><span class="n">NEUROPIXELS</span><span class="p">:</span>
            <span class="c1"># the old OE NPX plugins saved two forms of the data,</span>
            <span class="c1"># one for AP @30kHz and one for LFP @??Hz</span>
            <span class="c1"># the newer plugin saves only the 30kHz data. Also, the</span>
            <span class="c1"># 2.0 probes are saved with Probe[A-Z] appended to the end</span>
            <span class="c1"># of the folder</span>
            <span class="c1"># the older way:</span>
            <span class="n">acq_method</span> <span class="o">=</span> <span class="s2">&quot;Neuropix-PXI-[0-9][0-9][0-9].&quot;</span>
            <span class="n">APdata_match</span> <span class="o">=</span> <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="p">(</span><span class="n">acq_method</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="n">LFPdata_match</span> <span class="o">=</span> <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="p">(</span><span class="n">acq_method</span> <span class="o">+</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>
            <span class="c1"># the new way:</span>
            <span class="n">Rawdata_match</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="p">(</span><span class="n">acq_method</span> <span class="o">+</span> <span class="s2">&quot;Probe[A-Z]&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec_kind</span> <span class="o">==</span> <span class="n">RecordingKind</span><span class="o">.</span><span class="n">FPGA</span><span class="p">:</span>
            <span class="n">acq_method</span> <span class="o">=</span> <span class="s2">&quot;Rhythm_FPGA-[0-9][0-9][0-9].&quot;</span>
            <span class="n">APdata_match</span> <span class="o">=</span> <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="p">(</span><span class="n">acq_method</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="n">LFPdata_match</span> <span class="o">=</span> <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="p">(</span><span class="n">acq_method</span> <span class="o">+</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>
            <span class="n">Rawdata_match</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="p">(</span><span class="n">acq_method</span> <span class="o">+</span> <span class="s2">&quot;Probe[A-Z]&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">acq_method</span> <span class="o">=</span> <span class="s2">&quot;Acquisition_Board-[0-9][0-9][0-9].*&quot;</span>
            <span class="n">APdata_match</span> <span class="o">=</span> <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="n">acq_method</span>
            <span class="n">LFPdata_match</span> <span class="o">=</span> <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="n">acq_method</span>
            <span class="n">Rawdata_match</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">exp_name</span> <span class="o">/</span> <span class="n">rec_name</span> <span class="o">/</span> <span class="s2">&quot;continuous&quot;</span> <span class="o">/</span> <span class="p">(</span><span class="n">acq_method</span> <span class="o">+</span> <span class="s2">&quot;Probe[A-Z]&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">Events_match</span> <span class="o">=</span> <span class="p">(</span>
            <span class="c1"># only dealing with a single TTL channel at the moment</span>
            <span class="n">exp_name</span>
            <span class="o">/</span> <span class="n">rec_name</span>
            <span class="o">/</span> <span class="s2">&quot;events&quot;</span>
            <span class="o">/</span> <span class="n">acq_method</span>
            <span class="o">/</span> <span class="s2">&quot;TTL&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">pname_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pname_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pname_root</span>

        <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">pname_root</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>  <span class="c1"># ignore hidden directories</span>
                    <span class="k">if</span> <span class="s2">&quot;data_array.npy&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">PosTracker_match</span><span class="p">)):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pos data at: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path2PosOEBin</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;*pos_data*&quot;</span><span class="p">):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pos data at: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">TrackingPlugin_match</span><span class="p">)):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pos data at: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;continuous.dat&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">APdata_match</span><span class="p">)):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Continuous AP data at: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path2APOEBin</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">LFPdata_match</span><span class="p">)):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Continuous LFP data at: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">Rawdata_match</span><span class="p">)):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">TrackMe_match</span><span class="p">)):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackMe posdata at: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2PosData</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;sync_messages.txt&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sync_file_match</span><span class="p">)):</span>
                            <span class="n">sync_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;sync_messages.txt&quot;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">fileContainsString</span><span class="p">(</span><span class="n">sync_file</span><span class="p">,</span> <span class="s2">&quot;Start Time&quot;</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">sync_message_file</span> <span class="o">=</span> <span class="n">sync_file</span>
                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sync_messages file at: </span><span class="si">{</span><span class="n">sync_file</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;full_words.npy&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">Events_match</span><span class="p">)):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path2EventsData</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Event data at: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2EventsData</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">RippleDetector_match</span><span class="p">)):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">path2RippleDetector</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;Ripple Detector plugin found at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2RippleDetector</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;.nwb&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">path2NWBData</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ff</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nwb data at: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2NWBData</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;spike_templates.npy&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">path2KiloSortData</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found KiloSort data at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path2KiloSortData</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.OpenEphysBase._get_recording_start_time" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_get_recording_start_time</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the recording start time from the sync_messages.txt file</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>start_time (float) - in seconds</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span>
<span class="normal">983</span>
<span class="normal">984</span>
<span class="normal">985</span>
<span class="normal">986</span>
<span class="normal">987</span>
<span class="normal">988</span>
<span class="normal">989</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_get_recording_start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the recording start time from the sync_messages.txt file</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    start_time (float) - in seconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">recording_start_time</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_message_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sync_message_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">sync_strs</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">sync_lines</span> <span class="o">=</span> <span class="n">sync_strs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sync_lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;Start Time&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">start_time</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">recording_start_time</span>
    <span class="k">return</span> <span class="n">recording_start_time</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.OpenEphysBase.apply_filter" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">apply_filter</span><span class="p">(</span><span class="o">*</span><span class="n">trial_filter</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply a mask to the data</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>trial_filter</code>
            </td>
            <td>
                  <code><span title="ephysiopy.common.utils.TrialFilter">TrialFilter</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>name, start and end values</p>
              </div>
            </td>
            <td>
                  <code>()</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>    np.array: An array of bools that is True where the mask is applied</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_filter</span><span class="p">:</span> <span class="n">TrialFilter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a mask to the data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trial_filter (TrialFilter): A namedtuple containing the filter</span>
<span class="sd">        name, start and end values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        np.array: An array of bools that is True where the mask is applied</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply_filter</span><span class="p">(</span><span class="o">*</span><span class="n">trial_filter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.OpenEphysBase.get_spike_times" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tetrode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tetrode</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>spike_times (list | np.ndarray): in seconds</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spike_times</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster (int| list)</span>
<span class="sd">    tetrode (int | list)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spike_times (list | np.ndarray): in seconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_cluster_data</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">spk_clusters</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">get_cluster_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">times</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cluster not present&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">spk_clusters</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">get_cluster_spike_times</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cluster not present&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">times</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.OpenEphysBase.load_lfp" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">load_lfp</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Valid kwargs are:
'target_sample_rate' - int
    the sample rate to downsample to from the original</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">load_lfp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Valid kwargs are:</span>
<span class="sd">    &#39;target_sample_rate&#39; - int</span>
<span class="sd">        the sample rate to downsample to from the original</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lfp</span> <span class="o">=</span> <span class="n">memmapBinaryFile</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span><span class="p">,</span> <span class="s2">&quot;continuous.dat&quot;</span><span class="p">),</span>
            <span class="n">n_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># set the target sample rate to 250Hz by default to match</span>
        <span class="c1"># Axona EEG data</span>
        <span class="n">target_sample_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;target_sample_rate&quot;</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">target_sample_rate</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">lfp</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
            <span class="n">target_sample_rate</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span> <span class="o">=</span> <span class="n">EEGCalcsGeneric</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">target_sample_rate</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.OpenEphysBase.load_ttl" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">load_ttl</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>loaded (bool) - whether the data was loaded or not</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Notes</summary>
  <p>Valid kwargs:
    StimControl_id (str): This is the string
        "StimControl [0-9][][0-9]" where the numbers
        are the node id in the openephys signal chain
    TTL_channel_number (int): The integer value in the "states.npy"
        file that corresponds to the
        identity of the TTL input on the Digital I/O board on the
        openephys recording system. i.e. if there is input to BNC
        port 3 on the digital I/O board then values of 3 in the
        states.npy file are high TTL values on this input and -3
        are low TTL values. NB This is important as there could well
        be other TTL lines that are active and so the states vector
        will then contain a mix of integer values
    RippleDetector (str): Loads up the TTL data from the Ripple Detector
        plugin</p>
<p>Sets some keys/values in a dict on 'self'
called ttl_data, namely:</p>
<p>ttl_timestamps (list): the times of high ttl pulses in ms
stim_duration (int): the duration of the ttl pulse in ms</p>
</details>
            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">load_ttl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    loaded (bool) - whether the data was loaded or not</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Valid kwargs:</span>
<span class="sd">        StimControl_id (str): This is the string</span>
<span class="sd">            &quot;StimControl [0-9][0-9][0-9]&quot; where the numbers</span>
<span class="sd">            are the node id in the openephys signal chain</span>
<span class="sd">        TTL_channel_number (int): The integer value in the &quot;states.npy&quot;</span>
<span class="sd">            file that corresponds to the</span>
<span class="sd">            identity of the TTL input on the Digital I/O board on the</span>
<span class="sd">            openephys recording system. i.e. if there is input to BNC</span>
<span class="sd">            port 3 on the digital I/O board then values of 3 in the</span>
<span class="sd">            states.npy file are high TTL values on this input and -3</span>
<span class="sd">            are low TTL values. NB This is important as there could well</span>
<span class="sd">            be other TTL lines that are active and so the states vector</span>
<span class="sd">            will then contain a mix of integer values</span>
<span class="sd">        RippleDetector (str): Loads up the TTL data from the Ripple Detector</span>
<span class="sd">            plugin</span>

<span class="sd">    Sets some keys/values in a dict on &#39;self&#39;</span>
<span class="sd">    called ttl_data, namely:</span>

<span class="sd">    ttl_timestamps (list): the times of high ttl pulses in ms</span>
<span class="sd">    stim_duration (int): the duration of the ttl pulse in ms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2EventsData</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">ttl_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2EventsData</span><span class="p">,</span> <span class="s2">&quot;timestamps.npy&quot;</span><span class="p">))</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2EventsData</span><span class="p">,</span> <span class="s2">&quot;states.npy&quot;</span><span class="p">))</span>
    <span class="n">recording_start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_recording_start_time</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="s2">&quot;StimControl_id&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">stim_id</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;StimControl_id&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stim_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="p">[</span><span class="n">stim_id</span><span class="p">],</span> <span class="s2">&quot;Duration&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;stim_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;TTL_channel_number&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">chan</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;TTL_channel_number&quot;</span><span class="p">]</span>
        <span class="n">high_ttl</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">states</span> <span class="o">==</span> <span class="n">chan</span><span class="p">]</span>
        <span class="c1"># get into seconds</span>
        <span class="n">high_ttl</span> <span class="o">=</span> <span class="p">(</span><span class="n">high_ttl</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">recording_start_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">high_ttl</span> <span class="o">/</span> <span class="mf">1000.0</span>  <span class="c1"># in seconds now</span>
    <span class="k">if</span> <span class="s2">&quot;RippleDetector&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2RippleDetector</span><span class="p">:</span>
            <span class="n">detector_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">get_processor</span><span class="p">(</span><span class="s2">&quot;Ripple&quot;</span><span class="p">)</span>
            <span class="n">ttl_ts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2RippleDetector</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;timestamps.npy&quot;</span><span class="p">)</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">recording_start_time</span>
            <span class="p">)</span>
            <span class="n">ttl_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2RippleDetector</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;states.npy&quot;</span><span class="p">)</span>
            <span class="n">save_ttl</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_save</span><span class="p">)</span>
            <span class="n">out_ttl</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_Out</span><span class="p">)</span>
            <span class="n">indices_to_throw</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ttl_states</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">i_pair</span> <span class="o">=</span> <span class="n">ttl_states</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">i_pair</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">save_ttl</span><span class="p">,</span> <span class="n">out_ttl</span><span class="p">])):</span>
                    <span class="c1"># be extra sure this is a zero time difference</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ttl_ts</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">indices_to_throw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ttl_states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">indices_to_throw</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">ttl_ts</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">ttl_states</span> <span class="o">=</span> <span class="n">ttl_states</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="n">laser_ons</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="n">out_ttl</span><span class="p">]</span>
            <span class="n">laser_offs</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="o">-</span><span class="n">out_ttl</span><span class="p">]</span>
            <span class="n">no_laser_ons</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="n">save_ttl</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laser_ons</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps_off&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laser_offs</span>
            <span class="n">mean_duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">laser_offs</span> <span class="o">-</span> <span class="n">laser_ons</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;stim_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_duration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;no_laser_ttls&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">no_laser_ons</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded ttl data&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.io.recording.TrialInterface" class="doc doc-heading">
            <code>TrialInterface</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ephysiopy.visualise.plotting.FigureMaker" href="#ephysiopy.visualise.plotting.FigureMaker">FigureMaker</a></code></p>


        <p>Defines a minimal and required set of methods for loading
electrophysiology data recorded using Axona or OpenEphys
(OpenEphysNWB is there but not used)</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.pname">pname</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the absolute pathname of the top-level data directory</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.settings">settings</span></code></td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>contains metadata about the trial</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="ephysiopy.io.recording.TrialInterface.PosCalcs" href="#ephysiopy.visualise.plotting.FigureMaker.PosCalcs">PosCalcs</a></code></td>
            <td>
                  <code><span title="ephysiopy.common.ephys_generic.PosCalcsGeneric">PosCalcsGeneric</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>contains the positional data for the trial</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.RateMap">RateMap</span></code></td>
            <td>
                  <code><span title="ephysiopy.io.recording.TrialInterface.RateMap">RateMap</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>methods for binning data mostly</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.EEGCalcs">EEGCalcs</span></code></td>
            <td>
                  <code><span title="ephysiopy.io.recording.TrialInterface.EEGCalcs">EEGCalcs</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>methods for dealing with LFP data</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.clusterData">clusterData</span></code></td>
            <td>
                  <code><span title="ephysiopy.io.recording.TrialInterface.clusterData">clusterData</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>contains results of a spike sorting session (i.e. KiloSort)</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.recording_start_time">recording_start_time</span></code></td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the start time of the recording in seconds</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.sync_message_file">sync_message_file</span></code></td>
            <td>
                  <code><span title="pathlib.Path">Path</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the location of the sync_message_file (OpenEphys)</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.ttl_data">ttl_data</span></code></td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>ttl data including timestamps, ids and states</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.accelerometer_data">accelerometer_data</span></code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>data relating to headstage accelerometers</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.path2PosData">path2PosData</span></code></td>
            <td>
                  <code><span title="pathlib.Path">Path</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>location of the positional data</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.mask_array">mask_array</span></code></td>
            <td>
                  <code><span title="numpy.ma.MaskedArray">MaskedArray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>contains the mask (if applied) for positional data</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="ephysiopy.io.recording.TrialInterface.filter">filter</span></code></td>
            <td>
                  <code><span title="ephysiopy.common.utils.TrialFilter">TrialFilter</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>contains details of the filter applied to the positional data</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">TrialInterface</span><span class="p">(</span><span class="n">FigureMaker</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a minimal and required set of methods for loading</span>
<span class="sd">    electrophysiology data recorded using Axona or OpenEphys</span>
<span class="sd">    (OpenEphysNWB is there but not used)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pname : str</span>
<span class="sd">        the absolute pathname of the top-level data directory</span>
<span class="sd">    settings : dict</span>
<span class="sd">        contains metadata about the trial</span>
<span class="sd">    PosCalcs : PosCalcsGeneric</span>
<span class="sd">        contains the positional data for the trial</span>
<span class="sd">    RateMap : RateMap</span>
<span class="sd">        methods for binning data mostly</span>
<span class="sd">    EEGCalcs : EEGCalcs</span>
<span class="sd">        methods for dealing with LFP data</span>
<span class="sd">    clusterData : clusterData</span>
<span class="sd">        contains results of a spike sorting session (i.e. KiloSort)</span>
<span class="sd">    recording_start_time : float</span>
<span class="sd">        the start time of the recording in seconds</span>
<span class="sd">    sync_message_file : Path</span>
<span class="sd">        the location of the sync_message_file (OpenEphys)</span>
<span class="sd">    ttl_data : dict</span>
<span class="sd">        ttl data including timestamps, ids and states</span>
<span class="sd">    accelerometer_data : np.ndarray</span>
<span class="sd">        data relating to headstage accelerometers</span>
<span class="sd">    path2PosData : Path</span>
<span class="sd">        location of the positional data</span>
<span class="sd">    mask_array : np.ma.MaskedArray</span>
<span class="sd">        contains the mask (if applied) for positional data</span>
<span class="sd">    filter : TrialFilter</span>
<span class="sd">        contains details of the filter applied to the positional data</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">Path</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">(),</span> <span class="sa">f</span><span class="s2">&quot;Path provided doesnt exist: </span><span class="si">{</span><span class="n">pname</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pname</span> <span class="o">=</span> <span class="n">pname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_PosCalcs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RateMap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_EEGCalcs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_message_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clusterData</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># KiloSortSession</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recording_start_time</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># float</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ttl_data</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accelerometer_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path2PosData</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Path or str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__subclasshook__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">subclass</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">subclass</span><span class="p">,</span> <span class="s2">&quot;load_neural_data&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">subclass</span><span class="o">.</span><span class="n">load_neural_data</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">subclass</span><span class="p">,</span> <span class="s2">&quot;load_lfp&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">subclass</span><span class="o">.</span><span class="n">load_lfp</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">subclass</span><span class="p">,</span> <span class="s2">&quot;load_pos&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">subclass</span><span class="o">.</span><span class="n">load_pos</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">subclass</span><span class="p">,</span> <span class="s2">&quot;load_cluster_data&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">subclass</span><span class="o">.</span><span class="n">load_cluster_data</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">subclass</span><span class="p">,</span> <span class="s2">&quot;load_settings&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">subclass</span><span class="o">.</span><span class="n">load_settings</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">subclass</span><span class="p">,</span> <span class="s2">&quot;get_spike_times&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">subclass</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">subclass</span><span class="p">,</span> <span class="s2">&quot;get_available_clusters_channels&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">subclass</span><span class="o">.</span><span class="n">get_available_clusters_channels</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">subclass</span><span class="p">,</span> <span class="s2">&quot;load_ttl&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">subclass</span><span class="o">.</span><span class="n">load_ttl</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">NotImplemented</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pname</span>

    <span class="nd">@pname</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pname</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span>

    <span class="nd">@settings</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">PosCalcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PosCalcs</span>

    <span class="nd">@PosCalcs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">PosCalcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_PosCalcs</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RateMap</span>

    <span class="nd">@RateMap</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RateMap</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">EEGCalcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EEGCalcs</span>

    <span class="nd">@EEGCalcs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">EEGCalcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_EEGCalcs</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">clusterData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusterData</span>

    <span class="nd">@clusterData</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">clusterData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clusterData</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">recording_start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recording_start_time</span>

    <span class="nd">@recording_start_time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">recording_start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recording_start_time</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sync_message_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sync_message_file</span>

    <span class="nd">@sync_message_file</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sync_message_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_message_file</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ttl_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ttl_data</span>

    <span class="nd">@ttl_data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ttl_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ttl_data</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">accelerometer_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accelerometer_data</span>

    <span class="nd">@accelerometer_data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">accelerometer_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accelerometer_data</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">path2PosData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path2PosData</span>

    <span class="nd">@path2PosData</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">path2PosData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path2PosData</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span>

    <span class="nd">@mask_array</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mask_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Need an array-like input&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask_array</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span>

    <span class="k">def</span> <span class="nf">_update_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">TrialFilter</span> <span class="o">|</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_lfp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the LFP data&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_neural_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the neural data&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_pos_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppm</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">jumpmax</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the position data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ppm (int): pixels per metre</span>
<span class="sd">        jumpmax (int): max jump in pixels between positions, more</span>
<span class="sd">            than this and the position is interpolated over</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_cluster_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the cluster data (Kilosort/ Axona cut/ whatever else&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Loads the format specific settings file&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_ttl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_spike_times</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the times of an individual cluster&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_filter</span><span class="p">:</span> <span class="n">TrialFilter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a mask to the data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trial_filter (TrialFilter): A namedtuple containing the filter</span>
<span class="sd">            name, start and end values</span>
<span class="sd">            name (str): The name of the filter</span>
<span class="sd">            start (float): The start value of the filter</span>
<span class="sd">            end (float): The end value of the filter</span>

<span class="sd">            Valid names are:</span>
<span class="sd">                &#39;dir&#39; - the directional range to filter for</span>
<span class="sd">                &#39;speed&#39; - min and max speed to filter for</span>
<span class="sd">                &#39;xrange&#39; - min and max values to filter x pos values</span>
<span class="sd">                &#39;yrange&#39; - same as xrange but for y pos</span>
<span class="sd">                &#39;time&#39; - the times to keep / remove specified in ms</span>

<span class="sd">            Values are pairs specifying the range of values to filter for</span>
<span class="sd">            from the namedtuple TrialFilter that has fields &#39;start&#39; and &#39;end&#39;</span>
<span class="sd">            where &#39;start&#39; and &#39;end&#39; are the ranges to filter for</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray: An array of bools that is True where the mask is applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trial_filter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bool_arr</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_filter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i_filter</span> <span class="ow">in</span> <span class="n">trial_filter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_filter</span><span class="p">(</span><span class="n">i_filter</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;dir&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="s2">&quot;w&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                                <span class="n">start</span> <span class="o">=</span> <span class="mi">135</span>
                                <span class="n">end</span> <span class="o">=</span> <span class="mi">225</span>
                            <span class="k">elif</span> <span class="s2">&quot;e&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                                <span class="n">start</span> <span class="o">=</span> <span class="mi">315</span>
                                <span class="n">end</span> <span class="o">=</span> <span class="mi">45</span>
                            <span class="k">elif</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                                <span class="n">start</span> <span class="o">=</span> <span class="mi">225</span>
                                <span class="n">end</span> <span class="o">=</span> <span class="mi">315</span>
                            <span class="k">elif</span> <span class="s2">&quot;n&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                                <span class="n">start</span> <span class="o">=</span> <span class="mi">45</span>
                                <span class="n">end</span> <span class="o">=</span> <span class="mi">135</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid direction&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;filter must contain a key / value pair&quot;</span><span class="p">)</span>
                        <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="n">end</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;speed&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;First value must be less than the second one&quot;</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="k">elif</span> <span class="s2">&quot;dir&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                            <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="k">elif</span> <span class="s2">&quot;xrange&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="s2">&quot;yrange&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="c1"># takes the form of &#39;from&#39; - &#39;to&#39; times in SECONDS</span>
                        <span class="c1"># such that only pos&#39;s between these ranges are KEPT</span>
                        <span class="n">from_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i_filter</span><span class="o">.</span><span class="n">start</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
                        <span class="n">to_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i_filter</span><span class="o">.</span><span class="n">end</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
                        <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                        <span class="n">bool_arr</span><span class="p">[:,</span> <span class="n">from_time</span><span class="p">:</span><span class="n">to_time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Unrecognised key&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span><span class="p">,</span> <span class="n">bool_arr</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span>
                <span class="n">mask</span><span class="p">,</span>
                <span class="n">xy_ts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xyTS</span><span class="p">,</span>
                <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">initialise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span> <span class="o">=</span> <span class="n">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_available_clusters_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">get_spike_times_binned_into_position</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster (int | list): The cluster(s).</span>
<span class="sd">        channel (int | list): The channel(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray - the spike times binned into the position data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="p">[</span><span class="n">ts</span><span class="p">]</span>
        <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="n">n_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span>
        <span class="n">binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_pos</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
            <span class="n">spk_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
                <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">minlength</span><span class="o">=</span><span class="n">n_pos</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spk_binned</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_pos</span><span class="p">:</span>
                <span class="n">spk_binned</span> <span class="o">=</span> <span class="n">spk_binned</span><span class="p">[:</span><span class="n">n_pos</span><span class="p">]</span>
            <span class="n">binned</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">spk_binned</span>
        <span class="k">return</span> <span class="n">binned</span>

    <span class="k">def</span> <span class="nf">_get_spike_pos_idx</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices into the position data at which some cluster</span>
<span class="sd">        on a given channel emitted putative spikes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster (int | list): The cluster(s). NB this can be None in which</span>
<span class="sd">                case the &quot;spike times&quot; are equal to the position times, which</span>
<span class="sd">                means data binned using these indices will be equivalent to</span>
<span class="sd">                binning up just the position data alone.</span>

<span class="sd">        channel (int | list): The channel identity. Ignored if cluster is None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray: The indices into the position data at which the spikes</span>
<span class="sd">                occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_times</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">,</span> <span class="s2">&quot;xyTS&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spk_times</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">,</span> <span class="s2">&quot;xyTS&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">spk_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">spk_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">channel</span>
            <span class="p">),</span> <span class="s2">&quot;Cluster and channel lists must be same length&quot;</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">clust</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
                <span class="n">spk_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">clust</span><span class="p">,</span> <span class="n">chan</span><span class="p">)</span>
                <span class="n">_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pos_times</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">):</span>
                    <span class="n">_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                        <span class="n">_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">_idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="p">:]</span>
                    <span class="p">)</span>
                <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pos_times</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="p">:])</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;do_shuffle&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">n_shuffles</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_shuffles&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">random_seed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;random_seed&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
            <span class="n">time_shifts</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span>
                <span class="n">low</span><span class="o">=</span><span class="mi">30</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span> <span class="o">-</span> <span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">),</span>
                <span class="n">size</span><span class="o">=</span><span class="n">n_shuffles</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">shifted_idx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">time_shifts</span><span class="p">:</span>
                <span class="n">shifted_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift_vector</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">shifted_idx</span>

        <span class="k">return</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">_get_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">var2bin</span><span class="p">:</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function generates a rate map for a given cluster and channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster (int | list): The cluster(s).</span>
<span class="sd">        channel (int | list): The channel(s).</span>
<span class="sd">        var2bin (VariableToBin.XY): The variable to bin. This is an enum that specifies the type of variable to bin.</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            do_shuffle (bool): If True, the rate map will be shuffled by the default number of shuffles (100).</span>
<span class="sd">                            If the n_shuffles keyword is provided, the rate map will be shuffled by that number of shuffles, and</span>
<span class="sd">                            an array of shuffled rate maps will be returned e.g [100 x nx x ny].</span>
<span class="sd">                            The shuffles themselves are generated by shifting the spike times by a random amount between 30s and the</span>
<span class="sd">                            length of the position data minus 30s. The random amount is drawn from a uniform distribution. In order to preserve</span>
<span class="sd">                            the shifts over multiple calls to this function, the option is provided to set the random seed to a fixed</span>
<span class="sd">                            value using the random_seed keyword.</span>
<span class="sd">                            Default is False</span>
<span class="sd">            n_shuffles (int): The number of shuffles to perform. Default is 100.</span>
<span class="sd">            random_seed (int): The random seed to use for the shuffles. Default is None.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray: The rate map as a numpy array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
        <span class="n">spk_times_in_pos_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spike_pos_idx</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">npos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PosCalcs</span><span class="o">.</span><span class="n">npos</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="n">spk_times_in_pos_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">npos</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">npos</span><span class="p">:</span>
                <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">npos</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">):</span>  <span class="c1"># likely the result of a shuffle arg passed to get_spike_pos_idx</span>
            <span class="c1"># TODO: but not necessarily - could be multiple clusters/ channels have been passed</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">spk_idx</span> <span class="ow">in</span> <span class="n">spk_times_in_pos_samples</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spk_idx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">npos</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">npos</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">npos</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;var_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">var2bin</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rmap</span>

    <span class="k">def</span> <span class="nf">get_rate_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the rate map for the specified cluster(s) and channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster (int | list): The cluster(s) to get the speed vs rate for.</span>
<span class="sd">        channel (int | list): The channel(s) number.</span>
<span class="sd">        **kwargs: Additional keyword arguments passed to _get_map</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BinnedData - the binned data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_hd_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the head direction map for the specified cluster(s) and channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster (int | list): The cluster(s) to get the speed vs rate for.</span>
<span class="sd">        channel (int | list): The channel(s) number.</span>
<span class="sd">        **kwargs: Additional keyword arguments passed to _get_map</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BinnedData - the binned data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">DIR</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_eb_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the edge bin map for the specified cluster(s) and channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster (int | list): The cluster(s) to get the speed vs rate for.</span>
<span class="sd">        channel (int | list): The channel(s) number.</span>
<span class="sd">        **kwargs: Additional keyword arguments passed to _get_map</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BinnedData - the binned data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">EGO_BOUNDARY</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_speed_v_rate_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the speed vs rate for the specified cluster(s) and channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster (int | list): The cluster(s) to get the speed vs rate for.</span>
<span class="sd">        channel (int | list): The channel(s) number.</span>
<span class="sd">        **kwargs: Additional keyword arguments passed to _get_map</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BinnedData - the binned data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_speed_v_hd_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the speed vs head direction map for the specified cluster(s) and channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster (int | list): The cluster(s) to get the speed vs head direction map for.</span>
<span class="sd">        channel (int | list): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments passed to _get_map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># binsize is in cm/s and degrees</span>
        <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;binsize&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span>
            <span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED_DIR</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_grid_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rate_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">clean_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">autoCorr2D</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">sac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">autoCorr2D</span><span class="p">(</span><span class="n">rmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sac</span>

    <span class="k">def</span> <span class="nf">get_adaptive_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span>
            <span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span> <span class="n">map_type</span><span class="o">=</span><span class="n">MapType</span><span class="o">.</span><span class="n">ADAPTIVE</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_xcorr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xcorr</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface._get_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_get_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">var2bin</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>This function generates a rate map for a given cluster and channel.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>var2bin</code>
            </td>
            <td>
                  <code><span title="ephysiopy.common.utils.VariableToBin.XY">XY</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>do_shuffle (bool): If True, the rate map will be shuffled by the default number of shuffles (100).
                If the n_shuffles keyword is provided, the rate map will be shuffled by that number of shuffles, and
                an array of shuffled rate maps will be returned e.g [100 x nx x ny].
                The shuffles themselves are generated by shifting the spike times by a random amount between 30s and the
                length of the position data minus 30s. The random amount is drawn from a uniform distribution. In order to preserve
                the shifts over multiple calls to this function, the option is provided to set the random seed to a fixed
                value using the random_seed keyword.
                Default is False
n_shuffles (int): The number of shuffles to perform. Default is 100.
random_seed (int): The random seed to use for the shuffles. Default is None.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>np.ndarray: The rate map as a numpy array.</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_get_map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">var2bin</span><span class="p">:</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function generates a rate map for a given cluster and channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster (int | list): The cluster(s).</span>
<span class="sd">    channel (int | list): The channel(s).</span>
<span class="sd">    var2bin (VariableToBin.XY): The variable to bin. This is an enum that specifies the type of variable to bin.</span>
<span class="sd">    **kwargs:</span>
<span class="sd">        do_shuffle (bool): If True, the rate map will be shuffled by the default number of shuffles (100).</span>
<span class="sd">                        If the n_shuffles keyword is provided, the rate map will be shuffled by that number of shuffles, and</span>
<span class="sd">                        an array of shuffled rate maps will be returned e.g [100 x nx x ny].</span>
<span class="sd">                        The shuffles themselves are generated by shifting the spike times by a random amount between 30s and the</span>
<span class="sd">                        length of the position data minus 30s. The random amount is drawn from a uniform distribution. In order to preserve</span>
<span class="sd">                        the shifts over multiple calls to this function, the option is provided to set the random seed to a fixed</span>
<span class="sd">                        value using the random_seed keyword.</span>
<span class="sd">                        Default is False</span>
<span class="sd">        n_shuffles (int): The number of shuffles to perform. Default is 100.</span>
<span class="sd">        random_seed (int): The random seed to use for the shuffles. Default is None.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray: The rate map as a numpy array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
    <span class="n">spk_times_in_pos_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spike_pos_idx</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">npos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PosCalcs</span><span class="o">.</span><span class="n">npos</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">):</span>
        <span class="n">spk_times_in_pos_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">npos</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">npos</span><span class="p">:</span>
            <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">npos</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">elif</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="p">):</span>  <span class="c1"># likely the result of a shuffle arg passed to get_spike_pos_idx</span>
        <span class="c1"># TODO: but not necessarily - could be multiple clusters/ channels have been passed</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spk_idx</span> <span class="ow">in</span> <span class="n">spk_times_in_pos_samples</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spk_idx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">npos</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">npos</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">npos</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;var_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">var2bin</span>
    <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rmap</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface._get_spike_pos_idx" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_get_spike_pos_idx</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the indices into the position data at which some cluster
on a given channel emitted putative spikes.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <pre><code>case the "spike times" are equal to the position times, which
means data binned using these indices will be equivalent to
binning up just the position data alone.
</code></pre>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>np.ndarray: The indices into the position data at which the spikes</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>occurred.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_get_spike_pos_idx</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices into the position data at which some cluster</span>
<span class="sd">    on a given channel emitted putative spikes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster (int | list): The cluster(s). NB this can be None in which</span>
<span class="sd">            case the &quot;spike times&quot; are equal to the position times, which</span>
<span class="sd">            means data binned using these indices will be equivalent to</span>
<span class="sd">            binning up just the position data alone.</span>

<span class="sd">    channel (int | list): The channel identity. Ignored if cluster is None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray: The indices into the position data at which the spikes</span>
<span class="sd">            occurred.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pos_times</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">,</span> <span class="s2">&quot;xyTS&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spk_times</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">,</span> <span class="s2">&quot;xyTS&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">spk_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">spk_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">channel</span>
        <span class="p">),</span> <span class="s2">&quot;Cluster and channel lists must be same length&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">clust</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
            <span class="n">spk_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">clust</span><span class="p">,</span> <span class="n">chan</span><span class="p">)</span>
            <span class="n">_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pos_times</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">):</span>
                <span class="n">_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                    <span class="n">_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">_idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="p">:]</span>
                <span class="p">)</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pos_times</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="p">:])</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;do_shuffle&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">n_shuffles</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_shuffles&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">random_seed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;random_seed&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
        <span class="n">time_shifts</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span>
            <span class="n">low</span><span class="o">=</span><span class="mi">30</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span> <span class="o">-</span> <span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">),</span>
            <span class="n">size</span><span class="o">=</span><span class="n">n_shuffles</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">shifted_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">time_shifts</span><span class="p">:</span>
            <span class="n">shifted_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift_vector</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">shifted_idx</span>

    <span class="k">return</span> <span class="n">idx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.apply_filter" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">apply_filter</span><span class="p">(</span><span class="o">*</span><span class="n">trial_filter</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply a mask to the data</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>trial_filter</code>
            </td>
            <td>
                  <code><span title="ephysiopy.common.utils.TrialFilter">TrialFilter</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>name, start and end values
name (str): The name of the filter
start (float): The start value of the filter
end (float): The end value of the filter</p>
<p>Valid names are:
    'dir' - the directional range to filter for
    'speed' - min and max speed to filter for
    'xrange' - min and max values to filter x pos values
    'yrange' - same as xrange but for y pos
    'time' - the times to keep / remove specified in ms</p>
<p>Values are pairs specifying the range of values to filter for
from the namedtuple TrialFilter that has fields 'start' and 'end'
where 'start' and 'end' are the ranges to filter for</p>
              </div>
            </td>
            <td>
                  <code>()</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>np.ndarray: An array of bools that is True where the mask is applied</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_filter</span><span class="p">:</span> <span class="n">TrialFilter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a mask to the data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trial_filter (TrialFilter): A namedtuple containing the filter</span>
<span class="sd">        name, start and end values</span>
<span class="sd">        name (str): The name of the filter</span>
<span class="sd">        start (float): The start value of the filter</span>
<span class="sd">        end (float): The end value of the filter</span>

<span class="sd">        Valid names are:</span>
<span class="sd">            &#39;dir&#39; - the directional range to filter for</span>
<span class="sd">            &#39;speed&#39; - min and max speed to filter for</span>
<span class="sd">            &#39;xrange&#39; - min and max values to filter x pos values</span>
<span class="sd">            &#39;yrange&#39; - same as xrange but for y pos</span>
<span class="sd">            &#39;time&#39; - the times to keep / remove specified in ms</span>

<span class="sd">        Values are pairs specifying the range of values to filter for</span>
<span class="sd">        from the namedtuple TrialFilter that has fields &#39;start&#39; and &#39;end&#39;</span>
<span class="sd">        where &#39;start&#39; and &#39;end&#39; are the ranges to filter for</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray: An array of bools that is True where the mask is applied</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trial_filter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bool_arr</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_filter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i_filter</span> <span class="ow">in</span> <span class="n">trial_filter</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_filter</span><span class="p">(</span><span class="n">i_filter</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;dir&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s2">&quot;w&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="mi">135</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="mi">225</span>
                        <span class="k">elif</span> <span class="s2">&quot;e&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="mi">315</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="mi">45</span>
                        <span class="k">elif</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="mi">225</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="mi">315</span>
                        <span class="k">elif</span> <span class="s2">&quot;n&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="mi">45</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="mi">135</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid direction&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;filter must contain a key / value pair&quot;</span><span class="p">)</span>
                    <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="n">end</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;speed&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;First value must be less than the second one&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;dir&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                        <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;xrange&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;yrange&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="c1"># takes the form of &#39;from&#39; - &#39;to&#39; times in SECONDS</span>
                    <span class="c1"># such that only pos&#39;s between these ranges are KEPT</span>
                    <span class="n">from_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i_filter</span><span class="o">.</span><span class="n">start</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
                    <span class="n">to_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i_filter</span><span class="o">.</span><span class="n">end</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
                    <span class="n">bool_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="n">bool_arr</span><span class="p">[:,</span> <span class="n">from_time</span><span class="p">:</span><span class="n">to_time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Unrecognised key&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span><span class="p">,</span> <span class="n">bool_arr</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusterData</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span>
            <span class="n">mask</span><span class="p">,</span>
            <span class="n">xy_ts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xyTS</span><span class="p">,</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.get_eb_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_eb_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the edge bin map for the specified cluster(s) and channel.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>BinnedData - the binned data</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_eb_map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the edge bin map for the specified cluster(s) and channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster (int | list): The cluster(s) to get the speed vs rate for.</span>
<span class="sd">    channel (int | list): The channel(s) number.</span>
<span class="sd">    **kwargs: Additional keyword arguments passed to _get_map</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BinnedData - the binned data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">EGO_BOUNDARY</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.get_hd_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_hd_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the head direction map for the specified cluster(s) and channel.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>BinnedData - the binned data</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_hd_map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the head direction map for the specified cluster(s) and channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster (int | list): The cluster(s) to get the speed vs rate for.</span>
<span class="sd">    channel (int | list): The channel(s) number.</span>
<span class="sd">    **kwargs: Additional keyword arguments passed to _get_map</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BinnedData - the binned data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">DIR</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.get_rate_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_rate_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the rate map for the specified cluster(s) and channel.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>BinnedData - the binned data</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_rate_map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the rate map for the specified cluster(s) and channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster (int | list): The cluster(s) to get the speed vs rate for.</span>
<span class="sd">    channel (int | list): The channel(s) number.</span>
<span class="sd">    **kwargs: Additional keyword arguments passed to _get_map</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BinnedData - the binned data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.get_speed_v_hd_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_speed_v_hd_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the speed vs head direction map for the specified cluster(s) and channel.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_speed_v_hd_map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the speed vs head direction map for the specified cluster(s) and channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster (int | list): The cluster(s) to get the speed vs head direction map for.</span>
<span class="sd">    channel (int | list): The channel number.</span>
<span class="sd">    **kwargs: Additional keyword arguments passed to _get_map</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># binsize is in cm/s and degrees</span>
    <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;binsize&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span>
        <span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED_DIR</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">)</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.get_speed_v_rate_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_speed_v_rate_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the speed vs rate for the specified cluster(s) and channel.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>BinnedData - the binned data</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_speed_v_rate_map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the speed vs rate for the specified cluster(s) and channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster (int | list): The cluster(s) to get the speed vs rate for.</span>
<span class="sd">    channel (int | list): The channel(s) number.</span>
<span class="sd">    **kwargs: Additional keyword arguments passed to _get_map</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BinnedData - the binned data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.get_spike_times" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the times of an individual cluster</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<span class="k">def</span> <span class="nf">get_spike_times</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the times of an individual cluster&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.get_spike_times_binned_into_position" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spike_times_binned_into_position</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>np.ndarray - the spike times binned into the position data</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spike_times_binned_into_position</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster (int | list): The cluster(s).</span>
<span class="sd">    channel (int | list): The channel(s).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray - the spike times binned into the position data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="p">[</span><span class="n">ts</span><span class="p">]</span>
    <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
    <span class="n">n_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span>
    <span class="n">binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_pos</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
        <span class="n">spk_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
            <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">minlength</span><span class="o">=</span><span class="n">n_pos</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spk_binned</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_pos</span><span class="p">:</span>
            <span class="n">spk_binned</span> <span class="o">=</span> <span class="n">spk_binned</span><span class="p">[:</span><span class="n">n_pos</span><span class="p">]</span>
        <span class="n">binned</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">spk_binned</span>
    <span class="k">return</span> <span class="n">binned</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.load_cluster_data" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">load_cluster_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Load the cluster data (Kilosort/ Axona cut/ whatever else</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<span class="k">def</span> <span class="nf">load_cluster_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load the cluster data (Kilosort/ Axona cut/ whatever else&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.load_lfp" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">load_lfp</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Load the LFP data</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<span class="k">def</span> <span class="nf">load_lfp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load the LFP data&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.load_neural_data" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">load_neural_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Load the neural data</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<span class="k">def</span> <span class="nf">load_neural_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load the neural data&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.load_pos_data" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">load_pos_data</span><span class="p">(</span><span class="n">ppm</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">jumpmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Load the position data</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>ppm</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>300</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>jumpmax</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>than this and the position is interpolated over</p>
              </div>
            </td>
            <td>
                  <code>100</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<span class="k">def</span> <span class="nf">load_pos_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppm</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">jumpmax</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the position data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ppm (int): pixels per metre</span>
<span class="sd">    jumpmax (int): max jump in pixels between positions, more</span>
<span class="sd">        than this and the position is interpolated over</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.io.recording.TrialInterface.load_settings" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">load_settings</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Loads the format specific settings file</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<span class="k">def</span> <span class="nf">load_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Loads the format specific settings file&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="ephysiopy.io.recording.find_path_to_ripple_ttl" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">find_path_to_ripple_ttl</span><span class="p">(</span><span class="n">trial_root</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Iterates through a directory tree and finds the path to the
Ripple Detector plugin data and returns its location</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">find_path_to_ripple_ttl</span><span class="p">(</span><span class="n">trial_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterates through a directory tree and finds the path to the</span>
<span class="sd">    Ripple Detector plugin data and returns its location</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exp_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;experiment&quot;</span><span class="p">,</span> <span class="s2">&quot;experiment1&quot;</span><span class="p">)</span>
    <span class="n">rec_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;recording&quot;</span><span class="p">,</span> <span class="s2">&quot;recording1&quot;</span><span class="p">)</span>
    <span class="n">ripple_match</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">trial_root</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Record Node [0-9][0-9][0-9]&quot;</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">exp_name</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">rec_name</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;events&quot;</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Ripple_Detector-[0-9][0-9][0-9].*&quot;</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;TTL&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">trial_root</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>  <span class="c1"># ignore hidden directories</span>
                <span class="k">if</span> <span class="s2">&quot;timestamps.npy&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ripple_match</span><span class="p">)):</span>
                        <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Path</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.io.recording.memmapBinaryFile" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">memmapBinaryFile</span><span class="p">(</span><span class="n">path2file</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">384</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns a numpy memmap of the int16 data in the
file path2file, if present</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/io/recording.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">memmapBinaryFile</span><span class="p">(</span><span class="n">path2file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">384</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a numpy memmap of the int16 data in the</span>
<span class="sd">    file path2file, if present</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os</span>

    <span class="k">if</span> <span class="s2">&quot;data_type&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data_type&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path2file</span><span class="p">):</span>
        <span class="c1"># make sure n_channels is int as could be str</span>
        <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_channels</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path2file</span><span class="p">)</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">status</span><span class="o">.</span><span class="n">st_size</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">n_channels</span><span class="p">))</span>
        <span class="n">mmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span>
            <span class="n">path2file</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mmap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="plotting-the-results">Plotting the results</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.visualise.plotting"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.visualise.plotting.FigureMaker" class="doc doc-heading">
            <code>FigureMaker</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>A mixin class for TrialInterface that deals solely with
producing graphical output.</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  99</span>
<span class="normal"> 100</span>
<span class="normal"> 101</span>
<span class="normal"> 102</span>
<span class="normal"> 103</span>
<span class="normal"> 104</span>
<span class="normal"> 105</span>
<span class="normal"> 106</span>
<span class="normal"> 107</span>
<span class="normal"> 108</span>
<span class="normal"> 109</span>
<span class="normal"> 110</span>
<span class="normal"> 111</span>
<span class="normal"> 112</span>
<span class="normal"> 113</span>
<span class="normal"> 114</span>
<span class="normal"> 115</span>
<span class="normal"> 116</span>
<span class="normal"> 117</span>
<span class="normal"> 118</span>
<span class="normal"> 119</span>
<span class="normal"> 120</span>
<span class="normal"> 121</span>
<span class="normal"> 122</span>
<span class="normal"> 123</span>
<span class="normal"> 124</span>
<span class="normal"> 125</span>
<span class="normal"> 126</span>
<span class="normal"> 127</span>
<span class="normal"> 128</span>
<span class="normal"> 129</span>
<span class="normal"> 130</span>
<span class="normal"> 131</span>
<span class="normal"> 132</span>
<span class="normal"> 133</span>
<span class="normal"> 134</span>
<span class="normal"> 135</span>
<span class="normal"> 136</span>
<span class="normal"> 137</span>
<span class="normal"> 138</span>
<span class="normal"> 139</span>
<span class="normal"> 140</span>
<span class="normal"> 141</span>
<span class="normal"> 142</span>
<span class="normal"> 143</span>
<span class="normal"> 144</span>
<span class="normal"> 145</span>
<span class="normal"> 146</span>
<span class="normal"> 147</span>
<span class="normal"> 148</span>
<span class="normal"> 149</span>
<span class="normal"> 150</span>
<span class="normal"> 151</span>
<span class="normal"> 152</span>
<span class="normal"> 153</span>
<span class="normal"> 154</span>
<span class="normal"> 155</span>
<span class="normal"> 156</span>
<span class="normal"> 157</span>
<span class="normal"> 158</span>
<span class="normal"> 159</span>
<span class="normal"> 160</span>
<span class="normal"> 161</span>
<span class="normal"> 162</span>
<span class="normal"> 163</span>
<span class="normal"> 164</span>
<span class="normal"> 165</span>
<span class="normal"> 166</span>
<span class="normal"> 167</span>
<span class="normal"> 168</span>
<span class="normal"> 169</span>
<span class="normal"> 170</span>
<span class="normal"> 171</span>
<span class="normal"> 172</span>
<span class="normal"> 173</span>
<span class="normal"> 174</span>
<span class="normal"> 175</span>
<span class="normal"> 176</span>
<span class="normal"> 177</span>
<span class="normal"> 178</span>
<span class="normal"> 179</span>
<span class="normal"> 180</span>
<span class="normal"> 181</span>
<span class="normal"> 182</span>
<span class="normal"> 183</span>
<span class="normal"> 184</span>
<span class="normal"> 185</span>
<span class="normal"> 186</span>
<span class="normal"> 187</span>
<span class="normal"> 188</span>
<span class="normal"> 189</span>
<span class="normal"> 190</span>
<span class="normal"> 191</span>
<span class="normal"> 192</span>
<span class="normal"> 193</span>
<span class="normal"> 194</span>
<span class="normal"> 195</span>
<span class="normal"> 196</span>
<span class="normal"> 197</span>
<span class="normal"> 198</span>
<span class="normal"> 199</span>
<span class="normal"> 200</span>
<span class="normal"> 201</span>
<span class="normal"> 202</span>
<span class="normal"> 203</span>
<span class="normal"> 204</span>
<span class="normal"> 205</span>
<span class="normal"> 206</span>
<span class="normal"> 207</span>
<span class="normal"> 208</span>
<span class="normal"> 209</span>
<span class="normal"> 210</span>
<span class="normal"> 211</span>
<span class="normal"> 212</span>
<span class="normal"> 213</span>
<span class="normal"> 214</span>
<span class="normal"> 215</span>
<span class="normal"> 216</span>
<span class="normal"> 217</span>
<span class="normal"> 218</span>
<span class="normal"> 219</span>
<span class="normal"> 220</span>
<span class="normal"> 221</span>
<span class="normal"> 222</span>
<span class="normal"> 223</span>
<span class="normal"> 224</span>
<span class="normal"> 225</span>
<span class="normal"> 226</span>
<span class="normal"> 227</span>
<span class="normal"> 228</span>
<span class="normal"> 229</span>
<span class="normal"> 230</span>
<span class="normal"> 231</span>
<span class="normal"> 232</span>
<span class="normal"> 233</span>
<span class="normal"> 234</span>
<span class="normal"> 235</span>
<span class="normal"> 236</span>
<span class="normal"> 237</span>
<span class="normal"> 238</span>
<span class="normal"> 239</span>
<span class="normal"> 240</span>
<span class="normal"> 241</span>
<span class="normal"> 242</span>
<span class="normal"> 243</span>
<span class="normal"> 244</span>
<span class="normal"> 245</span>
<span class="normal"> 246</span>
<span class="normal"> 247</span>
<span class="normal"> 248</span>
<span class="normal"> 249</span>
<span class="normal"> 250</span>
<span class="normal"> 251</span>
<span class="normal"> 252</span>
<span class="normal"> 253</span>
<span class="normal"> 254</span>
<span class="normal"> 255</span>
<span class="normal"> 256</span>
<span class="normal"> 257</span>
<span class="normal"> 258</span>
<span class="normal"> 259</span>
<span class="normal"> 260</span>
<span class="normal"> 261</span>
<span class="normal"> 262</span>
<span class="normal"> 263</span>
<span class="normal"> 264</span>
<span class="normal"> 265</span>
<span class="normal"> 266</span>
<span class="normal"> 267</span>
<span class="normal"> 268</span>
<span class="normal"> 269</span>
<span class="normal"> 270</span>
<span class="normal"> 271</span>
<span class="normal"> 272</span>
<span class="normal"> 273</span>
<span class="normal"> 274</span>
<span class="normal"> 275</span>
<span class="normal"> 276</span>
<span class="normal"> 277</span>
<span class="normal"> 278</span>
<span class="normal"> 279</span>
<span class="normal"> 280</span>
<span class="normal"> 281</span>
<span class="normal"> 282</span>
<span class="normal"> 283</span>
<span class="normal"> 284</span>
<span class="normal"> 285</span>
<span class="normal"> 286</span>
<span class="normal"> 287</span>
<span class="normal"> 288</span>
<span class="normal"> 289</span>
<span class="normal"> 290</span>
<span class="normal"> 291</span>
<span class="normal"> 292</span>
<span class="normal"> 293</span>
<span class="normal"> 294</span>
<span class="normal"> 295</span>
<span class="normal"> 296</span>
<span class="normal"> 297</span>
<span class="normal"> 298</span>
<span class="normal"> 299</span>
<span class="normal"> 300</span>
<span class="normal"> 301</span>
<span class="normal"> 302</span>
<span class="normal"> 303</span>
<span class="normal"> 304</span>
<span class="normal"> 305</span>
<span class="normal"> 306</span>
<span class="normal"> 307</span>
<span class="normal"> 308</span>
<span class="normal"> 309</span>
<span class="normal"> 310</span>
<span class="normal"> 311</span>
<span class="normal"> 312</span>
<span class="normal"> 313</span>
<span class="normal"> 314</span>
<span class="normal"> 315</span>
<span class="normal"> 316</span>
<span class="normal"> 317</span>
<span class="normal"> 318</span>
<span class="normal"> 319</span>
<span class="normal"> 320</span>
<span class="normal"> 321</span>
<span class="normal"> 322</span>
<span class="normal"> 323</span>
<span class="normal"> 324</span>
<span class="normal"> 325</span>
<span class="normal"> 326</span>
<span class="normal"> 327</span>
<span class="normal"> 328</span>
<span class="normal"> 329</span>
<span class="normal"> 330</span>
<span class="normal"> 331</span>
<span class="normal"> 332</span>
<span class="normal"> 333</span>
<span class="normal"> 334</span>
<span class="normal"> 335</span>
<span class="normal"> 336</span>
<span class="normal"> 337</span>
<span class="normal"> 338</span>
<span class="normal"> 339</span>
<span class="normal"> 340</span>
<span class="normal"> 341</span>
<span class="normal"> 342</span>
<span class="normal"> 343</span>
<span class="normal"> 344</span>
<span class="normal"> 345</span>
<span class="normal"> 346</span>
<span class="normal"> 347</span>
<span class="normal"> 348</span>
<span class="normal"> 349</span>
<span class="normal"> 350</span>
<span class="normal"> 351</span>
<span class="normal"> 352</span>
<span class="normal"> 353</span>
<span class="normal"> 354</span>
<span class="normal"> 355</span>
<span class="normal"> 356</span>
<span class="normal"> 357</span>
<span class="normal"> 358</span>
<span class="normal"> 359</span>
<span class="normal"> 360</span>
<span class="normal"> 361</span>
<span class="normal"> 362</span>
<span class="normal"> 363</span>
<span class="normal"> 364</span>
<span class="normal"> 365</span>
<span class="normal"> 366</span>
<span class="normal"> 367</span>
<span class="normal"> 368</span>
<span class="normal"> 369</span>
<span class="normal"> 370</span>
<span class="normal"> 371</span>
<span class="normal"> 372</span>
<span class="normal"> 373</span>
<span class="normal"> 374</span>
<span class="normal"> 375</span>
<span class="normal"> 376</span>
<span class="normal"> 377</span>
<span class="normal"> 378</span>
<span class="normal"> 379</span>
<span class="normal"> 380</span>
<span class="normal"> 381</span>
<span class="normal"> 382</span>
<span class="normal"> 383</span>
<span class="normal"> 384</span>
<span class="normal"> 385</span>
<span class="normal"> 386</span>
<span class="normal"> 387</span>
<span class="normal"> 388</span>
<span class="normal"> 389</span>
<span class="normal"> 390</span>
<span class="normal"> 391</span>
<span class="normal"> 392</span>
<span class="normal"> 393</span>
<span class="normal"> 394</span>
<span class="normal"> 395</span>
<span class="normal"> 396</span>
<span class="normal"> 397</span>
<span class="normal"> 398</span>
<span class="normal"> 399</span>
<span class="normal"> 400</span>
<span class="normal"> 401</span>
<span class="normal"> 402</span>
<span class="normal"> 403</span>
<span class="normal"> 404</span>
<span class="normal"> 405</span>
<span class="normal"> 406</span>
<span class="normal"> 407</span>
<span class="normal"> 408</span>
<span class="normal"> 409</span>
<span class="normal"> 410</span>
<span class="normal"> 411</span>
<span class="normal"> 412</span>
<span class="normal"> 413</span>
<span class="normal"> 414</span>
<span class="normal"> 415</span>
<span class="normal"> 416</span>
<span class="normal"> 417</span>
<span class="normal"> 418</span>
<span class="normal"> 419</span>
<span class="normal"> 420</span>
<span class="normal"> 421</span>
<span class="normal"> 422</span>
<span class="normal"> 423</span>
<span class="normal"> 424</span>
<span class="normal"> 425</span>
<span class="normal"> 426</span>
<span class="normal"> 427</span>
<span class="normal"> 428</span>
<span class="normal"> 429</span>
<span class="normal"> 430</span>
<span class="normal"> 431</span>
<span class="normal"> 432</span>
<span class="normal"> 433</span>
<span class="normal"> 434</span>
<span class="normal"> 435</span>
<span class="normal"> 436</span>
<span class="normal"> 437</span>
<span class="normal"> 438</span>
<span class="normal"> 439</span>
<span class="normal"> 440</span>
<span class="normal"> 441</span>
<span class="normal"> 442</span>
<span class="normal"> 443</span>
<span class="normal"> 444</span>
<span class="normal"> 445</span>
<span class="normal"> 446</span>
<span class="normal"> 447</span>
<span class="normal"> 448</span>
<span class="normal"> 449</span>
<span class="normal"> 450</span>
<span class="normal"> 451</span>
<span class="normal"> 452</span>
<span class="normal"> 453</span>
<span class="normal"> 454</span>
<span class="normal"> 455</span>
<span class="normal"> 456</span>
<span class="normal"> 457</span>
<span class="normal"> 458</span>
<span class="normal"> 459</span>
<span class="normal"> 460</span>
<span class="normal"> 461</span>
<span class="normal"> 462</span>
<span class="normal"> 463</span>
<span class="normal"> 464</span>
<span class="normal"> 465</span>
<span class="normal"> 466</span>
<span class="normal"> 467</span>
<span class="normal"> 468</span>
<span class="normal"> 469</span>
<span class="normal"> 470</span>
<span class="normal"> 471</span>
<span class="normal"> 472</span>
<span class="normal"> 473</span>
<span class="normal"> 474</span>
<span class="normal"> 475</span>
<span class="normal"> 476</span>
<span class="normal"> 477</span>
<span class="normal"> 478</span>
<span class="normal"> 479</span>
<span class="normal"> 480</span>
<span class="normal"> 481</span>
<span class="normal"> 482</span>
<span class="normal"> 483</span>
<span class="normal"> 484</span>
<span class="normal"> 485</span>
<span class="normal"> 486</span>
<span class="normal"> 487</span>
<span class="normal"> 488</span>
<span class="normal"> 489</span>
<span class="normal"> 490</span>
<span class="normal"> 491</span>
<span class="normal"> 492</span>
<span class="normal"> 493</span>
<span class="normal"> 494</span>
<span class="normal"> 495</span>
<span class="normal"> 496</span>
<span class="normal"> 497</span>
<span class="normal"> 498</span>
<span class="normal"> 499</span>
<span class="normal"> 500</span>
<span class="normal"> 501</span>
<span class="normal"> 502</span>
<span class="normal"> 503</span>
<span class="normal"> 504</span>
<span class="normal"> 505</span>
<span class="normal"> 506</span>
<span class="normal"> 507</span>
<span class="normal"> 508</span>
<span class="normal"> 509</span>
<span class="normal"> 510</span>
<span class="normal"> 511</span>
<span class="normal"> 512</span>
<span class="normal"> 513</span>
<span class="normal"> 514</span>
<span class="normal"> 515</span>
<span class="normal"> 516</span>
<span class="normal"> 517</span>
<span class="normal"> 518</span>
<span class="normal"> 519</span>
<span class="normal"> 520</span>
<span class="normal"> 521</span>
<span class="normal"> 522</span>
<span class="normal"> 523</span>
<span class="normal"> 524</span>
<span class="normal"> 525</span>
<span class="normal"> 526</span>
<span class="normal"> 527</span>
<span class="normal"> 528</span>
<span class="normal"> 529</span>
<span class="normal"> 530</span>
<span class="normal"> 531</span>
<span class="normal"> 532</span>
<span class="normal"> 533</span>
<span class="normal"> 534</span>
<span class="normal"> 535</span>
<span class="normal"> 536</span>
<span class="normal"> 537</span>
<span class="normal"> 538</span>
<span class="normal"> 539</span>
<span class="normal"> 540</span>
<span class="normal"> 541</span>
<span class="normal"> 542</span>
<span class="normal"> 543</span>
<span class="normal"> 544</span>
<span class="normal"> 545</span>
<span class="normal"> 546</span>
<span class="normal"> 547</span>
<span class="normal"> 548</span>
<span class="normal"> 549</span>
<span class="normal"> 550</span>
<span class="normal"> 551</span>
<span class="normal"> 552</span>
<span class="normal"> 553</span>
<span class="normal"> 554</span>
<span class="normal"> 555</span>
<span class="normal"> 556</span>
<span class="normal"> 557</span>
<span class="normal"> 558</span>
<span class="normal"> 559</span>
<span class="normal"> 560</span>
<span class="normal"> 561</span>
<span class="normal"> 562</span>
<span class="normal"> 563</span>
<span class="normal"> 564</span>
<span class="normal"> 565</span>
<span class="normal"> 566</span>
<span class="normal"> 567</span>
<span class="normal"> 568</span>
<span class="normal"> 569</span>
<span class="normal"> 570</span>
<span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">FigureMaker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mixin class for TrialInterface that deals solely with</span>
<span class="sd">    producing graphical output.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the FigureMaker object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span> <span class="o">=</span> <span class="kc">None</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the FigureMaker object with data from PosCalcs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span> <span class="o">=</span> <span class="n">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">npos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_plot_multiple_clusters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">clusters</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots multiple clusters.</span>

<span class="sd">        Args:</span>
<span class="sd">            func (function): The function to apply to each cluster.</span>
<span class="sd">            clusters (list): The list of clusters to plot.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;projection&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;projection&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">proj</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
            <span class="n">func</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span>

    <span class="nd">@savePlot</span>
    <span class="nd">@stripAxes</span>
    <span class="k">def</span> <span class="nf">plot_rate_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the rate map for the specified cluster(s) and channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster(s) to get the rate map for.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rate_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">clean_kwargs</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># TODO: doesn&#39;t deal with multiple clusters being binned</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">jet_cmap</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span>
            <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
            <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="nd">@stripAxes</span>
    <span class="k">def</span> <span class="nf">plot_hd_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the head direction map for the specified cluster(s) and channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster(s) to get the head direction map</span>
<span class="sd">                for.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hd_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">add_mrv</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_mrv&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">add_guides</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_guides&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">fill</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fill&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">clean_kwargs</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;polar&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_theta_zero_location</span><span class="p">(</span><span class="s2">&quot;N&quot;</span><span class="p">)</span>
        <span class="c1"># need to deal with the case where the axis is supplied but</span>
        <span class="c1"># is not polar. deal with polar first</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span>
        <span class="p">)</span>  <span class="c1"># in samples so * pos sample_rate</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">hasData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;polar&quot;</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="n">hasData</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fill</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">add_guides</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_rgrids</span><span class="p">([])</span>

        <span class="c1"># See if we should add the mean resultant vector (mrv)</span>
        <span class="k">if</span> <span class="n">add_mrv</span> <span class="ow">and</span> <span class="n">hasData</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ephysiopy.common.statscalcs</span> <span class="kn">import</span> <span class="n">mean_resultant_vector</span>

            <span class="n">veclen</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">get_mean_resultant_length</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">th</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">get_mean_resultant_angle</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">th</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">veclen</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">],</span>
                <span class="s2">&quot;r&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;polar&quot;</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_thetagrids</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="nd">@stripAxes</span>
    <span class="k">def</span> <span class="nf">plot_spike_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the spike path for the specified cluster(s) and channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int | None): The cluster(s) to get the spike path</span>
<span class="sd">                for.</span>
<span class="sd">            channel (int | None): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">marker</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;marker&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cluster</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spike_pos_idx</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">],</span>
                <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="nd">@stripAxes</span>
    <span class="k">def</span> <span class="nf">plot_eb_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the ego-centric boundary map for the specified cluster(s) and</span>
<span class="sd">        channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster(s) to get the ego-centric</span>
<span class="sd">                boundary map for.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_ratemap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;return_ratemap&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_eb_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s2">&quot;polar&quot;</span><span class="p">)</span>
        <span class="c1"># sanitise kwargs before passing on to pcolormesh</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">clean_kwargs</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span>
            <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>
        <span class="c1"># ax.set_xticklabels(np.arange(0, 2*np.pi, np.pi/4))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Angle (deg)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Distance (cm)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_ratemap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ax</span><span class="p">,</span> <span class="n">rmap</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="nd">@stripAxes</span>
    <span class="k">def</span> <span class="nf">plot_eb_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the ego-centric boundary spikes for the specified cluster(s)</span>
<span class="sd">        and channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster(s) to get the ego-centric</span>
<span class="sd">                boundary spikes for.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
        <span class="c1"># Parse kwargs</span>
        <span class="n">num_dir_bins</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dir_bins&quot;</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
        <span class="n">rect_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ms&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">add_colour_wheel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;add_colour_wheel&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">dir_colours</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hls&quot;</span><span class="p">,</span> <span class="n">num_dir_bins</span><span class="p">)</span>
        <span class="c1"># Process dirrectional data</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spike_pos_idx</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="n">dir_spike_fired_at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">dir</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">idx_of_dir_to_colour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
            <span class="n">dir_spike_fired_at</span> <span class="o">/</span> <span class="p">(</span><span class="mi">360</span> <span class="o">/</span> <span class="n">num_dir_bins</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">rects</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Rectangle</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                <span class="n">width</span><span class="o">=</span><span class="n">rect_size</span><span class="p">,</span>
                <span class="n">height</span><span class="o">=</span><span class="n">rect_size</span><span class="p">,</span>
                <span class="n">clip_box</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">,</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="n">dir_colours</span><span class="p">[</span><span class="n">idx_of_dir_to_colour</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">c</span><span class="o">=</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">PatchCollection</span><span class="p">(</span><span class="n">rects</span><span class="p">,</span> <span class="n">match_original</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">add_colour_wheel</span><span class="p">:</span>
            <span class="n">ax_col</span> <span class="o">=</span> <span class="n">inset_axes</span><span class="p">(</span>
                <span class="n">ax</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="s2">&quot;100%&quot;</span><span class="p">,</span>
                <span class="n">height</span><span class="o">=</span><span class="s2">&quot;100%&quot;</span><span class="p">,</span>
                <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">),</span>
                <span class="n">axes_class</span><span class="o">=</span><span class="n">get_projection_class</span><span class="p">(</span><span class="s2">&quot;polar&quot;</span><span class="p">),</span>
                <span class="n">bbox_transform</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">transFigure</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax_col</span><span class="o">.</span><span class="n">set_theta_zero_location</span><span class="p">(</span><span class="s2">&quot;N&quot;</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">col_map</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hls&quot;</span><span class="p">,</span> <span class="n">as_cmap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax_col</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">col_map</span><span class="p">)</span>
            <span class="n">ax_col</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([])</span>
            <span class="n">ax_col</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;polar&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax_col</span><span class="o">.</span><span class="n">set_thetagrids</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="nd">@stripAxes</span>
    <span class="k">def</span> <span class="nf">plot_sac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the spatial autocorrelation for the specified cluster(s) and</span>
<span class="sd">        channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster(s) to get the spatial</span>
<span class="sd">                autocorrelation for.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="n">measures</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">grid_field_props</span><span class="p">(</span><span class="n">sac</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">Am</span> <span class="o">=</span> <span class="n">sac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Am</span><span class="p">[</span><span class="o">~</span><span class="n">measures</span><span class="p">[</span><span class="s2">&quot;dist_to_centre&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">Am</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Am</span><span class="p">))</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">sac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
            <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">sac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">grey_cmap</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span>
            <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
            <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="kn">import</span> <span class="nn">copy</span>

        <span class="n">cmap</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">jet_cmap</span><span class="p">)</span>
        <span class="n">cmap</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
            <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">Am</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span>
            <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
            <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># horizontal green line at 3 o&#39;clock</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">)</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.75</span>
        <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">],</span> <span class="mi">50</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.common.utils</span> <span class="kn">import</span> <span class="n">rect</span>

        <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">rect</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># angle subtended by orientation</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># plot lines from centre to peaks above middle</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;closest_peak_coords&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;dist_to_centre&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">all_ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">all_ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_speed_v_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the speed versus rate plot for the specified cluster(s) and</span>
<span class="sd">        channel.</span>

<span class="sd">        By default the distribution of speeds will be plotted as a twin</span>
<span class="sd">        axis. To disable set add_speed_hist = False</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster(s) to get the speed versus rate</span>
<span class="sd">                plot for.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">add_speed_hist</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_speed_hist&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_speed_v_rate_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># rmap is linear</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">clean_kwargs</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax_colour</span> <span class="o">=</span> <span class="s2">&quot;cornflowerblue&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">ax_colour</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Speed (cm/s)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Rate (Hz)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_speed_hist</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ax_colour</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">ax_colour</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ax_colour</span><span class="p">)</span>
            <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
            <span class="n">ax2_colour</span> <span class="o">=</span> <span class="s2">&quot;grey&quot;</span>
            <span class="n">pos_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span>
            <span class="p">)</span>
            <span class="n">speed_bincounts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span><span class="p">,</span> <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">weights</span><span class="o">=</span><span class="n">pos_weights</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span>
                <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">speed_bincounts</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                <span class="n">ec</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span>
                <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Duration (s)&quot;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ax2_colour</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">ax2_colour</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ax2_colour</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span>

    <span class="c1"># @stripAxes</span>
    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_speed_v_hd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the speed versus head direction plot for the specified cluster(s)</span>
<span class="sd">        and channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster(s) to get the speed versus head</span>
<span class="sd">                direction plot for.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_speed_v_hd_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># mask low rates...</span>
        <span class="c1"># im = np.ma.masked_where(im &lt;= 1, im)</span>
        <span class="c1"># ... and where less than 0.5% of data is accounted for</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">jet_cmap</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;90&quot;</span><span class="p">,</span> <span class="s2">&quot;180&quot;</span><span class="p">,</span> <span class="s2">&quot;270&quot;</span><span class="p">],</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span>
            <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;20&quot;</span><span class="p">,</span> <span class="s2">&quot;30&quot;</span><span class="p">,</span> <span class="s2">&quot;40&quot;</span><span class="p">],</span>
            <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Heading&quot;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_acorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the autocorrelogram for the specified cluster(s) and channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster(s) to get the autocorrelogram</span>
<span class="sd">                for.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getXCorrPlot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_xcorr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster_a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel_a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cluster_b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel_b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the temporal cross-correlogram between cluster_a and cluster_b</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_a (int) : first cluster</span>
<span class="sd">        channel_a (int) : first channel</span>
<span class="sd">        cluster_b (int) : second cluster</span>
<span class="sd">        channel_b (int) : second channel</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        plt.Axes : matplotlib.Axes instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;strip_axes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strip_axes</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;binsize&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;binsize&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binsize</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="k">if</span> <span class="s2">&quot;Trange&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">xrange</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;Trange&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xrange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>

        <span class="n">a_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster_a</span><span class="p">,</span> <span class="n">channel_a</span><span class="p">)</span>
        <span class="n">b_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster_b</span><span class="p">,</span> <span class="n">channel_b</span><span class="p">)</span>
        <span class="n">xcorr_binned</span> <span class="o">=</span> <span class="n">xcorr</span><span class="p">(</span><span class="n">a_times</span><span class="p">,</span> <span class="n">b_times</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">xrange</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">xcorr_binned</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">xcorr_binned</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xrange</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s2">&quot;bottom&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">axtrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;lightgrey&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axtrans</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the raster plot for the specified cluster(s) and channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int | list): The cluster(s) to get the raster plot for.</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRasterPlot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_power_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the power spectrum.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">calcEEGPowerSpectrum</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPowerSpectrumPlot</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_theta_vs_running_speed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuadMesh</span><span class="p">:</span>
        <span class="n">low_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;low_theta&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">high_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;high_theta&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
        <span class="n">low_speed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;low_speed&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">high_speed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;high_speed&quot;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">theta_filtered_eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">butterFilter</span><span class="p">(</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">)</span>
        <span class="n">hilbert_eeg</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">theta_filtered_eeg</span><span class="p">)</span>
        <span class="n">inst_freq</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">hilbert_eeg</span><span class="p">)))</span>
        <span class="p">)</span>
        <span class="n">inst_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">inst_freq</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inst_freq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">eeg_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">sig</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">fs</span>
        <span class="n">pos_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xyTS</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pos_times</span><span class="p">,</span> <span class="n">eeg_times</span><span class="p">)</span>
        <span class="n">idx</span><span class="p">[</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_times</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">eeg_speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span>
            <span class="p">[</span><span class="n">inst_freq</span><span class="p">,</span> <span class="n">eeg_speed</span><span class="p">],</span>
            <span class="n">bins</span><span class="o">=</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">low_speed</span><span class="p">,</span> <span class="n">high_speed</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">jet_cmap</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_clusters_theta_phase</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.common.rhythmicity</span> <span class="kn">import</span> <span class="n">LFPOscillations</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;polar&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;polar&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need a polar axis&quot;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">LFPOscillations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="n">phase</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">get_theta_phase</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">36</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># add lines around the edge of the polar plot to show spiking locations</span>
        <span class="n">y_lims</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
        <span class="n">line_start</span> <span class="o">=</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1.01</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="n">line_start</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.15</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.15</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_thetagrids</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_rgrids</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;90&quot;</span><span class="p">,</span> <span class="s2">&quot;180&quot;</span><span class="p">,</span> <span class="s2">&quot;270&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="nd">@savePlot</span>
    <span class="nd">@stripAxes</span>
    <span class="k">def</span> <span class="nf">_plotWaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waves</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ax</span><span class="p">:</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">waves</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">_getPowerSpectrumPlot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">freqs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">power</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sm_power</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">band_max_power</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">freq_at_band_max_power</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">theta_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the power spectrum. The parameters can be obtained from</span>
<span class="sd">        calcEEGPowerSpectrum() in the EEGCalcsGeneric class.</span>

<span class="sd">        Args:</span>
<span class="sd">            freqs (np.array): The frequencies.</span>
<span class="sd">            power (np.array): The power values.</span>
<span class="sd">            sm_power (np.array): The smoothed power values.</span>
<span class="sd">            band_max_power (float): The maximum power in the band.</span>
<span class="sd">            freq_at_band_max_power (float): The frequency at which the maximum</span>
<span class="sd">                power in the band occurs.</span>
<span class="sd">            max_freq (int, optional): The maximum frequency. Defaults to 50.</span>
<span class="sd">            theta_range (tuple, optional): The theta range.</span>
<span class="sd">                Defaults to [6, 12].</span>
<span class="sd">            ax (matplotlib.axes, optional): The axes to plot on. If None, new</span>
<span class="sd">                axes are created.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.axes: The axes with the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_freq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;min_freq&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;strip_axes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strip_axes</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># downsample frequencies and power</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>
        <span class="n">sm_power</span> <span class="o">=</span> <span class="n">sm_power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">sm_power</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">min_freq</span><span class="p">,</span> <span class="n">max_freq</span><span class="p">)</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sm_power</span><span class="p">[</span><span class="n">freqs</span> <span class="o">&lt;</span> <span class="n">max_freq</span><span class="p">])]</span>
        <span class="k">if</span> <span class="s2">&quot;ylim&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;ylim&quot;</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">theta_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">0.9</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="n">band_max_power</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">freq_at_band_max_power</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span>
            <span class="p">(</span><span class="n">theta_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">theta_range</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">height</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
            <span class="n">ec</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">_getXCorrPlot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">ax</span><span class="p">:</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an axis containing the autocorrelogram of the spike</span>
<span class="sd">        times provided over the range +/-500ms.</span>

<span class="sd">        Args:</span>
<span class="sd">            spk_times (np.array): Spike times in seconds.</span>
<span class="sd">            ax (matplotlib.axes, optional): The axes to plot into. If None,</span>
<span class="sd">                new axes are created.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">                binsize (int, optional): The size of the bins in ms. Gets</span>
<span class="sd">                passed to SpikeCalcsGeneric.xcorr(). Defaults to 1.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.axes: The axes with the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;strip_axes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strip_axes</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;binsize&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;binsize&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binsize</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="k">if</span> <span class="s2">&quot;Trange&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">xrange</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;Trange&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xrange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
        <span class="n">ac</span> <span class="o">=</span> <span class="n">xcorr</span><span class="p">(</span><span class="n">spk_times</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">xrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xrange</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s2">&quot;bottom&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">axtrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;lightgrey&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axtrans</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">_getRasterPlot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spk_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cluster</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">secs_per_bin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots a raster plot for a specified tetrode/ cluster.</span>

<span class="sd">        Args:</span>
<span class="sd">            spk_times (np.array): The spike times in seconds</span>
<span class="sd">            dt (tuple, optional): The window of time in ms to examine zeroed</span>
<span class="sd">                on the event of interest i.e. the first value will probably</span>
<span class="sd">                be negative as in the example. Defaults to (-50, 100).</span>
<span class="sd">            prc_max (float, optional): The proportion of firing the cell has</span>
<span class="sd">                to &#39;lose&#39; to count as silent; a float between 0 and 1.</span>
<span class="sd">                Defaults to 0.5.</span>
<span class="sd">            ax (matplotlib.axes, optional): The axes to plot into.</span>
<span class="sd">                If not provided a new figure is created. Defaults to None.</span>
<span class="sd">            ms_per_bin (int, optional): The number of milliseconds in each bin</span>
<span class="sd">                of the raster plot. Defaults to 1.</span>
<span class="sd">            sample_rate (float, optional): The sample rate. Defaults to 3e4.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.axes: The axes with the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ttl_data&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;strip_axes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strip_axes</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">SpikeCalcsGeneric</span><span class="p">(</span><span class="n">spk_times</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">event_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps&quot;</span><span class="p">]</span>
        <span class="n">S</span><span class="o">.</span><span class="n">event_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">psth</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">))</span>
            <span class="n">axScatter</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axScatter</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="n">histColor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">]</span>
        <span class="n">axScatter</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">histColor</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axScatter</span><span class="p">)</span>
        <span class="n">axScatter</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">axScatter</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
        <span class="n">axHistx</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span>
            <span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">axScatter</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axScatter</span><span class="o">.</span><span class="n">transAxes</span>
        <span class="p">)</span>
        <span class="n">scattTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span>
            <span class="n">axScatter</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">axScatter</span><span class="o">.</span><span class="n">transAxes</span>
        <span class="p">)</span>
        <span class="n">stim_pwidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;stim_duration&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stim_pwidth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stim duration is None&quot;</span><span class="p">)</span>

        <span class="n">axScatter</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
            <span class="n">Rectangle</span><span class="p">(</span>
                <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">width</span><span class="o">=</span><span class="n">stim_pwidth</span><span class="p">,</span>
                <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">scattTrans</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">histTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span>
            <span class="n">axHistx</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">axHistx</span><span class="o">.</span><span class="n">transAxes</span>
        <span class="p">)</span>
        <span class="n">axHistx</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
            <span class="n">Rectangle</span><span class="p">(</span>
                <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">width</span><span class="o">=</span><span class="n">stim_pwidth</span><span class="p">,</span>
                <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">histTrans</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">axScatter</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Laser stimulation events&quot;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=-</span><span class="mf">2.5</span><span class="p">)</span>
        <span class="n">axScatter</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time to stimulus onset(s)&quot;</span><span class="p">)</span>
        <span class="n">nStms</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">axScatter</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nStms</span><span class="p">)</span>
        <span class="c1"># Label only the min and max of the y-axis</span>
        <span class="n">ylabels</span> <span class="o">=</span> <span class="n">axScatter</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">yticks</span> <span class="o">=</span> <span class="n">axScatter</span><span class="o">.</span><span class="n">get_yticklines</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">yticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">axHistx</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">secs_per_bin</span><span class="p">,</span> <span class="n">secs_per_bin</span><span class="p">),</span>
            <span class="n">color</span><span class="o">=</span><span class="n">histColor</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
            <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">histtype</span><span class="o">=</span><span class="s2">&quot;stepfilled&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">axHistx</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Spike count&quot;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=-</span><span class="mf">2.5</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axHistx</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Label only the min and max of the y-axis</span>
        <span class="n">ylabels</span> <span class="o">=</span> <span class="n">axHistx</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">yticks</span> <span class="o">=</span> <span class="n">axHistx</span><span class="o">.</span><span class="n">get_yticklines</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">yticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">axHistx</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">axScatter</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">cluster</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">axScatter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axScatter</span>

    <span class="k">def</span> <span class="nf">plotSpectrogramByDepth</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nchannels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">384</span><span class="p">,</span>
        <span class="n">nseconds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">maxFreq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">125</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">frequencies</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">frequencyIncrement</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots a heat map spectrogram of the LFP for each channel.</span>
<span class="sd">        Line plots of power per frequency band and power on a subset of</span>
<span class="sd">        channels are also displayed to the right and above the main plot.</span>

<span class="sd">        Args:</span>
<span class="sd">            nchannels (int): The number of channels on the probe.</span>
<span class="sd">            nseconds (int, optional): How long in seconds from the start of</span>
<span class="sd">                the trial to do the spectrogram for (for speed).</span>
<span class="sd">                Default is 100.</span>
<span class="sd">            maxFreq (int): The maximum frequency in Hz to plot the spectrogram</span>
<span class="sd">                out to. Maximum is 1250. Default is 125.</span>
<span class="sd">            channels (list): The channels to plot separately on the top plot.</span>
<span class="sd">            frequencies (list): The specific frequencies to examine across</span>
<span class="sd">                all channels. The mean from frequency:</span>
<span class="sd">                frequency+frequencyIncrement is calculated and plotted on</span>
<span class="sd">                the left hand side of the plot.</span>
<span class="sd">            frequencyIncrement (int): The amount to add to each value of</span>
<span class="sd">                the frequencies list above.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">                Valid key value pairs:</span>
<span class="sd">                    &quot;saveas&quot; - save the figure to this location, needs absolute</span>
<span class="sd">                    path and filename.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Should also allow kwargs to specify exactly which channels</span>
<span class="sd">            and / or frequency bands to do the line plots for.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a probe recording so not plotting&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">os</span>

        <span class="n">lfp_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span><span class="p">,</span> <span class="s2">&quot;continuous.dat&quot;</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">lfp_file</span><span class="p">)</span>
        <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">status</span><span class="o">.</span><span class="n">st_size</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">nchannels</span><span class="p">)</span>
        <span class="n">mmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">lfp_file</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">nchannels</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="c1"># Load the channel map NB assumes this is in the AP data</span>
        <span class="c1"># location and that kilosort was run there</span>
        <span class="n">channel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">,</span> <span class="s2">&quot;channel_map.npy&quot;</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">lfp_sample_rate</span> <span class="o">=</span> <span class="mi">2500</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mmap</span><span class="p">[</span><span class="n">channel_map</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">nseconds</span> <span class="o">*</span> <span class="n">lfp_sample_rate</span><span class="p">])</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.common.ephys_generic</span> <span class="kn">import</span> <span class="n">EEGCalcsGeneric</span>

        <span class="n">E</span> <span class="o">=</span> <span class="n">EEGCalcsGeneric</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lfp_sample_rate</span><span class="p">)</span>
        <span class="n">E</span><span class="o">.</span><span class="n">calcEEGPowerSpectrum</span><span class="p">()</span>
        <span class="n">spec_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="o">.</span><span class="n">sm_power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">EEGCalcsGeneric</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">chan</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lfp_sample_rate</span><span class="p">)</span>
            <span class="n">E</span><span class="o">.</span><span class="n">calcEEGPowerSpectrum</span><span class="p">()</span>
            <span class="n">spec_data</span><span class="p">[</span><span class="n">chan</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">sm_power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">E</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">],</span> <span class="n">channel_map</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
        <span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">cm</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">spectoAx</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">spectoAx</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">spec_data</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;bone&quot;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">spectoAx</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxFreq</span><span class="p">)</span>
        <span class="n">spectoAx</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">channel_map</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">channel_map</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">spectoAx</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">spectoAx</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Channel&quot;</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">spectoAx</span><span class="p">)</span>
        <span class="n">channel_spectoAx</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">spectoAx</span><span class="p">)</span>
        <span class="n">meanfreq_powerAx</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">spectoAx</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span>
            <span class="n">channel_spectoAx</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="o">+</span> <span class="n">meanfreq_powerAx</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span>
            <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># plot mean power across some channels</span>
        <span class="n">mn_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nchannels</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">rainbow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">))))</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">channel_spectoAx</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">E</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">],</span>
                <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec_data</span><span class="p">[</span><span class="n">chan</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">mn_power</span><span class="p">),</span>
                <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">chan</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="n">channel_spectoAx</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Channel power(dB)&quot;</span><span class="p">)</span>
        <span class="n">channel_spectoAx</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span>
            <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.02</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.102</span><span class="p">),</span>
            <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower left&quot;</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;expand&quot;</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;x-small&quot;</span><span class="p">,</span>
            <span class="n">ncol</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># plot mean frequencies across all channels</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">frequencyIncrement</span><span class="p">:</span>
            <span class="n">freq_inc</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freq_inc</span> <span class="o">=</span> <span class="n">frequencyIncrement</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">frequencies</span><span class="p">:</span>
            <span class="n">lower_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxFreq</span> <span class="o">-</span> <span class="n">freq_inc</span><span class="p">,</span> <span class="n">freq_inc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower_freqs</span> <span class="o">=</span> <span class="n">frequencies</span>
        <span class="n">upper_freqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="n">freq_inc</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">lower_freqs</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">nipy_spectral</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">upper_freqs</span><span class="p">))))</span>
        <span class="n">mn_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec_data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">freqs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lower_freqs</span><span class="p">,</span> <span class="n">upper_freqs</span><span class="p">):</span>
            <span class="n">freq_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">E</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">E</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">mean_power</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec_data</span><span class="p">[:,</span> <span class="n">freq_mask</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">mn_power</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">meanfreq_powerAx</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">mean_power</span><span class="p">,</span>
                <span class="n">channel_map</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; - &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">)</span>
        <span class="n">meanfreq_powerAx</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Mean freq. band power(dB)&quot;</span><span class="p">)</span>
        <span class="n">meanfreq_powerAx</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span>
            <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.02</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.102</span><span class="p">),</span>
            <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower left&quot;</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;expand&quot;</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;x-small&quot;</span><span class="p">,</span>
            <span class="n">ncol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;saveas&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">saveas</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;saveas&quot;</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">saveas</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.visualise.plotting.FigureMaker.PosCalcs" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">PosCalcs</span> <span class="o">=</span> <span class="kc">None</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Initializes the FigureMaker object with data from PosCalcs.</p>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Initializes the FigureMaker object.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes the FigureMaker object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span> <span class="o">=</span> <span class="kc">None</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes the FigureMaker object with data from PosCalcs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span> <span class="o">=</span> <span class="n">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker._getPowerSpectrumPlot" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_getPowerSpectrumPlot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">sm_power</span><span class="p">,</span> <span class="n">band_max_power</span><span class="p">,</span> <span class="n">freq_at_band_max_power</span><span class="p">,</span> <span class="n">max_freq</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">theta_range</span><span class="o">=</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots the power spectrum. The parameters can be obtained from
calcEEGPowerSpectrum() in the EEGCalcsGeneric class.</p>
<p>Args:
    freqs (np.array): The frequencies.
    power (np.array): The power values.
    sm_power (np.array): The smoothed power values.
    band_max_power (float): The maximum power in the band.
    freq_at_band_max_power (float): The frequency at which the maximum
        power in the band occurs.
    max_freq (int, optional): The maximum frequency. Defaults to 50.
    theta_range (tuple, optional): The theta range.
        Defaults to [6, 12].
    ax (matplotlib.axes, optional): The axes to plot on. If None, new
        axes are created.
    **kwargs: Additional keyword arguments for the function.</p>
<p>Returns:
    matplotlib.axes: The axes with the plot.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_getPowerSpectrumPlot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">freqs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">power</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sm_power</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">band_max_power</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">freq_at_band_max_power</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="n">theta_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the power spectrum. The parameters can be obtained from</span>
<span class="sd">    calcEEGPowerSpectrum() in the EEGCalcsGeneric class.</span>

<span class="sd">    Args:</span>
<span class="sd">        freqs (np.array): The frequencies.</span>
<span class="sd">        power (np.array): The power values.</span>
<span class="sd">        sm_power (np.array): The smoothed power values.</span>
<span class="sd">        band_max_power (float): The maximum power in the band.</span>
<span class="sd">        freq_at_band_max_power (float): The frequency at which the maximum</span>
<span class="sd">            power in the band occurs.</span>
<span class="sd">        max_freq (int, optional): The maximum frequency. Defaults to 50.</span>
<span class="sd">        theta_range (tuple, optional): The theta range.</span>
<span class="sd">            Defaults to [6, 12].</span>
<span class="sd">        ax (matplotlib.axes, optional): The axes to plot on. If None, new</span>
<span class="sd">            axes are created.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>

<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.axes: The axes with the plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_freq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;min_freq&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;strip_axes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strip_axes</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># downsample frequencies and power</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>
    <span class="n">sm_power</span> <span class="o">=</span> <span class="n">sm_power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">sm_power</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">min_freq</span><span class="p">,</span> <span class="n">max_freq</span><span class="p">)</span>
    <span class="n">ylim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sm_power</span><span class="p">[</span><span class="n">freqs</span> <span class="o">&lt;</span> <span class="n">max_freq</span><span class="p">])]</span>
    <span class="k">if</span> <span class="s2">&quot;ylim&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;ylim&quot;</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">theta_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="n">band_max_power</span><span class="p">,</span>
        <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">freq_at_band_max_power</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span>
        <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span>
        <span class="p">(</span><span class="n">theta_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">theta_range</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">height</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="n">ec</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker._getRasterPlot" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_getRasterPlot</span><span class="p">(</span><span class="n">spk_times</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">secs_per_bin</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots a raster plot for a specified tetrode/ cluster.</p>
<p>Args:
    spk_times (np.array): The spike times in seconds
    dt (tuple, optional): The window of time in ms to examine zeroed
        on the event of interest i.e. the first value will probably
        be negative as in the example. Defaults to (-50, 100).
    prc_max (float, optional): The proportion of firing the cell has
        to 'lose' to count as silent; a float between 0 and 1.
        Defaults to 0.5.
    ax (matplotlib.axes, optional): The axes to plot into.
        If not provided a new figure is created. Defaults to None.
    ms_per_bin (int, optional): The number of milliseconds in each bin
        of the raster plot. Defaults to 1.
    sample_rate (float, optional): The sample rate. Defaults to 3e4.
    **kwargs: Additional keyword arguments for the function.</p>
<p>Returns:
    matplotlib.axes: The axes with the plot.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_getRasterPlot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">spk_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cluster</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">secs_per_bin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a raster plot for a specified tetrode/ cluster.</span>

<span class="sd">    Args:</span>
<span class="sd">        spk_times (np.array): The spike times in seconds</span>
<span class="sd">        dt (tuple, optional): The window of time in ms to examine zeroed</span>
<span class="sd">            on the event of interest i.e. the first value will probably</span>
<span class="sd">            be negative as in the example. Defaults to (-50, 100).</span>
<span class="sd">        prc_max (float, optional): The proportion of firing the cell has</span>
<span class="sd">            to &#39;lose&#39; to count as silent; a float between 0 and 1.</span>
<span class="sd">            Defaults to 0.5.</span>
<span class="sd">        ax (matplotlib.axes, optional): The axes to plot into.</span>
<span class="sd">            If not provided a new figure is created. Defaults to None.</span>
<span class="sd">        ms_per_bin (int, optional): The number of milliseconds in each bin</span>
<span class="sd">            of the raster plot. Defaults to 1.</span>
<span class="sd">        sample_rate (float, optional): The sample rate. Defaults to 3e4.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>

<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.axes: The axes with the plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ttl_data&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;strip_axes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strip_axes</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">SpikeCalcsGeneric</span><span class="p">(</span><span class="n">spk_times</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">)</span>
    <span class="n">S</span><span class="o">.</span><span class="n">event_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps&quot;</span><span class="p">]</span>
    <span class="n">S</span><span class="o">.</span><span class="n">event_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">psth</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">))</span>
        <span class="n">axScatter</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axScatter</span> <span class="o">=</span> <span class="n">ax</span>
    <span class="n">histColor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">]</span>
    <span class="n">axScatter</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">histColor</span><span class="p">)</span>
    <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axScatter</span><span class="p">)</span>
    <span class="n">axScatter</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">axScatter</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="n">axHistx</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span>
        <span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">axScatter</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axScatter</span><span class="o">.</span><span class="n">transAxes</span>
    <span class="p">)</span>
    <span class="n">scattTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span>
        <span class="n">axScatter</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">axScatter</span><span class="o">.</span><span class="n">transAxes</span>
    <span class="p">)</span>
    <span class="n">stim_pwidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;stim_duration&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">stim_pwidth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stim duration is None&quot;</span><span class="p">)</span>

    <span class="n">axScatter</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
        <span class="n">Rectangle</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">width</span><span class="o">=</span><span class="n">stim_pwidth</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">scattTrans</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">histTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span>
        <span class="n">axHistx</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">axHistx</span><span class="o">.</span><span class="n">transAxes</span>
    <span class="p">)</span>
    <span class="n">axHistx</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
        <span class="n">Rectangle</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">width</span><span class="o">=</span><span class="n">stim_pwidth</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">histTrans</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">axScatter</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Laser stimulation events&quot;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=-</span><span class="mf">2.5</span><span class="p">)</span>
    <span class="n">axScatter</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time to stimulus onset(s)&quot;</span><span class="p">)</span>
    <span class="n">nStms</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">axScatter</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nStms</span><span class="p">)</span>
    <span class="c1"># Label only the min and max of the y-axis</span>
    <span class="n">ylabels</span> <span class="o">=</span> <span class="n">axScatter</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">yticks</span> <span class="o">=</span> <span class="n">axScatter</span><span class="o">.</span><span class="n">get_yticklines</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">yticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">axHistx</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">secs_per_bin</span><span class="p">,</span> <span class="n">secs_per_bin</span><span class="p">),</span>
        <span class="n">color</span><span class="o">=</span><span class="n">histColor</span><span class="p">,</span>
        <span class="nb">range</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
        <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">histtype</span><span class="o">=</span><span class="s2">&quot;stepfilled&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">axHistx</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Spike count&quot;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=-</span><span class="mf">2.5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axHistx</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Label only the min and max of the y-axis</span>
    <span class="n">ylabels</span> <span class="o">=</span> <span class="n">axHistx</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">yticks</span> <span class="o">=</span> <span class="n">axHistx</span><span class="o">.</span><span class="n">get_yticklines</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">yticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">axHistx</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">axScatter</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">cluster</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">axScatter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">axScatter</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker._getXCorrPlot" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_getXCorrPlot</span><span class="p">(</span><span class="n">spk_times</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns an axis containing the autocorrelogram of the spike
times provided over the range +/-500ms.</p>
<p>Args:
    spk_times (np.array): Spike times in seconds.
    ax (matplotlib.axes, optional): The axes to plot into. If None,
        new axes are created.
    **kwargs: Additional keyword arguments for the function.
        binsize (int, optional): The size of the bins in ms. Gets
        passed to SpikeCalcsGeneric.xcorr(). Defaults to 1.</p>
<p>Returns:
    matplotlib.axes: The axes with the plot.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_getXCorrPlot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">ax</span><span class="p">:</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an axis containing the autocorrelogram of the spike</span>
<span class="sd">    times provided over the range +/-500ms.</span>

<span class="sd">    Args:</span>
<span class="sd">        spk_times (np.array): Spike times in seconds.</span>
<span class="sd">        ax (matplotlib.axes, optional): The axes to plot into. If None,</span>
<span class="sd">            new axes are created.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">            binsize (int, optional): The size of the bins in ms. Gets</span>
<span class="sd">            passed to SpikeCalcsGeneric.xcorr(). Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.axes: The axes with the plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;strip_axes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strip_axes</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;binsize&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;binsize&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">binsize</span> <span class="o">=</span> <span class="mf">0.001</span>
    <span class="k">if</span> <span class="s2">&quot;Trange&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">xrange</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;Trange&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xrange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
    <span class="n">ac</span> <span class="o">=</span> <span class="n">xcorr</span><span class="p">(</span><span class="n">spk_times</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">xrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xrange</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span>
        <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s2">&quot;bottom&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">axtrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;lightgrey&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axtrans</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker._plot_multiple_clusters" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_plot_multiple_clusters</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots multiple clusters.</p>
<p>Args:
    func (function): The function to apply to each cluster.
    clusters (list): The list of clusters to plot.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_plot_multiple_clusters</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">clusters</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots multiple clusters.</span>

<span class="sd">    Args:</span>
<span class="sd">        func (function): The function to apply to each cluster.</span>
<span class="sd">        clusters (list): The list of clusters to plot.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">))</span>
    <span class="k">if</span> <span class="s2">&quot;projection&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;projection&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">proj</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plotSpectrogramByDepth" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plotSpectrogramByDepth</span><span class="p">(</span><span class="n">nchannels</span><span class="o">=</span><span class="mi">384</span><span class="p">,</span> <span class="n">nseconds</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">maxFreq</span><span class="o">=</span><span class="mi">125</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[],</span> <span class="n">frequencies</span><span class="o">=</span><span class="p">[],</span> <span class="n">frequencyIncrement</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots a heat map spectrogram of the LFP for each channel.
Line plots of power per frequency band and power on a subset of
channels are also displayed to the right and above the main plot.</p>
<p>Args:
    nchannels (int): The number of channels on the probe.
    nseconds (int, optional): How long in seconds from the start of
        the trial to do the spectrogram for (for speed).
        Default is 100.
    maxFreq (int): The maximum frequency in Hz to plot the spectrogram
        out to. Maximum is 1250. Default is 125.
    channels (list): The channels to plot separately on the top plot.
    frequencies (list): The specific frequencies to examine across
        all channels. The mean from frequency:
        frequency+frequencyIncrement is calculated and plotted on
        the left hand side of the plot.
    frequencyIncrement (int): The amount to add to each value of
        the frequencies list above.
    **kwargs: Additional keyword arguments for the function.
        Valid key value pairs:
            "saveas" - save the figure to this location, needs absolute
            path and filename.</p>
<p>Notes:
    Should also allow kwargs to specify exactly which channels
    and / or frequency bands to do the line plots for.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">plotSpectrogramByDepth</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">nchannels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">384</span><span class="p">,</span>
    <span class="n">nseconds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">maxFreq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">125</span><span class="p">,</span>
    <span class="n">channels</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">frequencies</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">frequencyIncrement</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a heat map spectrogram of the LFP for each channel.</span>
<span class="sd">    Line plots of power per frequency band and power on a subset of</span>
<span class="sd">    channels are also displayed to the right and above the main plot.</span>

<span class="sd">    Args:</span>
<span class="sd">        nchannels (int): The number of channels on the probe.</span>
<span class="sd">        nseconds (int, optional): How long in seconds from the start of</span>
<span class="sd">            the trial to do the spectrogram for (for speed).</span>
<span class="sd">            Default is 100.</span>
<span class="sd">        maxFreq (int): The maximum frequency in Hz to plot the spectrogram</span>
<span class="sd">            out to. Maximum is 1250. Default is 125.</span>
<span class="sd">        channels (list): The channels to plot separately on the top plot.</span>
<span class="sd">        frequencies (list): The specific frequencies to examine across</span>
<span class="sd">            all channels. The mean from frequency:</span>
<span class="sd">            frequency+frequencyIncrement is calculated and plotted on</span>
<span class="sd">            the left hand side of the plot.</span>
<span class="sd">        frequencyIncrement (int): The amount to add to each value of</span>
<span class="sd">            the frequencies list above.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">            Valid key value pairs:</span>
<span class="sd">                &quot;saveas&quot; - save the figure to this location, needs absolute</span>
<span class="sd">                path and filename.</span>

<span class="sd">    Notes:</span>
<span class="sd">        Should also allow kwargs to specify exactly which channels</span>
<span class="sd">        and / or frequency bands to do the line plots for.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a probe recording so not plotting&quot;</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">os</span>

    <span class="n">lfp_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2LFPdata</span><span class="p">,</span> <span class="s2">&quot;continuous.dat&quot;</span><span class="p">)</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">lfp_file</span><span class="p">)</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">status</span><span class="o">.</span><span class="n">st_size</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">nchannels</span><span class="p">)</span>
    <span class="n">mmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">lfp_file</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">nchannels</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
    <span class="c1"># Load the channel map NB assumes this is in the AP data</span>
    <span class="c1"># location and that kilosort was run there</span>
    <span class="n">channel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">,</span> <span class="s2">&quot;channel_map.npy&quot;</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">lfp_sample_rate</span> <span class="o">=</span> <span class="mi">2500</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mmap</span><span class="p">[</span><span class="n">channel_map</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">nseconds</span> <span class="o">*</span> <span class="n">lfp_sample_rate</span><span class="p">])</span>
    <span class="kn">from</span> <span class="nn">ephysiopy.common.ephys_generic</span> <span class="kn">import</span> <span class="n">EEGCalcsGeneric</span>

    <span class="n">E</span> <span class="o">=</span> <span class="n">EEGCalcsGeneric</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lfp_sample_rate</span><span class="p">)</span>
    <span class="n">E</span><span class="o">.</span><span class="n">calcEEGPowerSpectrum</span><span class="p">()</span>
    <span class="n">spec_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="o">.</span><span class="n">sm_power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">])))</span>
    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">EEGCalcsGeneric</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">chan</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lfp_sample_rate</span><span class="p">)</span>
        <span class="n">E</span><span class="o">.</span><span class="n">calcEEGPowerSpectrum</span><span class="p">()</span>
        <span class="n">spec_data</span><span class="p">[</span><span class="n">chan</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">sm_power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">E</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">],</span> <span class="n">channel_map</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
    <span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">cm</span>
    <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">spectoAx</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">spectoAx</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">spec_data</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;bone&quot;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">spectoAx</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxFreq</span><span class="p">)</span>
    <span class="n">spectoAx</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">channel_map</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">channel_map</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">spectoAx</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
    <span class="n">spectoAx</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Channel&quot;</span><span class="p">)</span>
    <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">spectoAx</span><span class="p">)</span>
    <span class="n">channel_spectoAx</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">spectoAx</span><span class="p">)</span>
    <span class="n">meanfreq_powerAx</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">spectoAx</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span>
        <span class="n">channel_spectoAx</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="o">+</span> <span class="n">meanfreq_powerAx</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span>
        <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># plot mean power across some channels</span>
    <span class="n">mn_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">channels</span><span class="p">:</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nchannels</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">rainbow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">))))</span>
    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">channel_spectoAx</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">E</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">],</span>
            <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec_data</span><span class="p">[</span><span class="n">chan</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">mn_power</span><span class="p">),</span>
            <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">chan</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="n">channel_spectoAx</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Channel power(dB)&quot;</span><span class="p">)</span>
    <span class="n">channel_spectoAx</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span>
        <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.02</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.102</span><span class="p">),</span>
        <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower left&quot;</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;expand&quot;</span><span class="p">,</span>
        <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;x-small&quot;</span><span class="p">,</span>
        <span class="n">ncol</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># plot mean frequencies across all channels</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">frequencyIncrement</span><span class="p">:</span>
        <span class="n">freq_inc</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">freq_inc</span> <span class="o">=</span> <span class="n">frequencyIncrement</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">frequencies</span><span class="p">:</span>
        <span class="n">lower_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxFreq</span> <span class="o">-</span> <span class="n">freq_inc</span><span class="p">,</span> <span class="n">freq_inc</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lower_freqs</span> <span class="o">=</span> <span class="n">frequencies</span>
    <span class="n">upper_freqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="n">freq_inc</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">lower_freqs</span><span class="p">]</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">nipy_spectral</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">upper_freqs</span><span class="p">))))</span>
    <span class="n">mn_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec_data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">freqs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lower_freqs</span><span class="p">,</span> <span class="n">upper_freqs</span><span class="p">):</span>
        <span class="n">freq_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">E</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">E</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">mean_power</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec_data</span><span class="p">[:,</span> <span class="n">freq_mask</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">mn_power</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">meanfreq_powerAx</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">mean_power</span><span class="p">,</span>
            <span class="n">channel_map</span><span class="p">,</span>
            <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; - &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">)</span>
    <span class="n">meanfreq_powerAx</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Mean freq. band power(dB)&quot;</span><span class="p">)</span>
    <span class="n">meanfreq_powerAx</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span>
        <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.02</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.102</span><span class="p">),</span>
        <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower left&quot;</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;expand&quot;</span><span class="p">,</span>
        <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;x-small&quot;</span><span class="p">,</span>
        <span class="n">ncol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;saveas&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">saveas</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;saveas&quot;</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">saveas</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_acorr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_acorr</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the autocorrelogram for the specified cluster(s) and channel.</p>
<p>Args:
    cluster (int): The cluster(s) to get the autocorrelogram
        for.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="k">def</span> <span class="nf">plot_acorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the autocorrelogram for the specified cluster(s) and channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster(s) to get the autocorrelogram</span>
<span class="sd">            for.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getXCorrPlot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_eb_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_eb_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the ego-centric boundary map for the specified cluster(s) and
channel.</p>
<p>Args:
    cluster (int): The cluster(s) to get the ego-centric
        boundary map for.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="nd">@stripAxes</span>
<span class="k">def</span> <span class="nf">plot_eb_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the ego-centric boundary map for the specified cluster(s) and</span>
<span class="sd">    channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster(s) to get the ego-centric</span>
<span class="sd">            boundary map for.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_ratemap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;return_ratemap&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_eb_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s2">&quot;polar&quot;</span><span class="p">)</span>
    <span class="c1"># sanitise kwargs before passing on to pcolormesh</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">clean_kwargs</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span>
        <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>
    <span class="c1"># ax.set_xticklabels(np.arange(0, 2*np.pi, np.pi/4))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Angle (deg)&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Distance (cm)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_ratemap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ax</span><span class="p">,</span> <span class="n">rmap</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_eb_spikes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_eb_spikes</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the ego-centric boundary spikes for the specified cluster(s)
and channel.</p>
<p>Args:
    cluster (int): The cluster(s) to get the ego-centric
        boundary spikes for.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="nd">@stripAxes</span>
<span class="k">def</span> <span class="nf">plot_eb_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the ego-centric boundary spikes for the specified cluster(s)</span>
<span class="sd">    and channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster(s) to get the ego-centric</span>
<span class="sd">            boundary spikes for.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
    <span class="c1"># Parse kwargs</span>
    <span class="n">num_dir_bins</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dir_bins&quot;</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">rect_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ms&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">add_colour_wheel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;add_colour_wheel&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">dir_colours</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hls&quot;</span><span class="p">,</span> <span class="n">num_dir_bins</span><span class="p">)</span>
    <span class="c1"># Process dirrectional data</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spike_pos_idx</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
    <span class="n">dir_spike_fired_at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">dir</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">idx_of_dir_to_colour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
        <span class="n">dir_spike_fired_at</span> <span class="o">/</span> <span class="p">(</span><span class="mi">360</span> <span class="o">/</span> <span class="n">num_dir_bins</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">rects</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">Rectangle</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
            <span class="n">width</span><span class="o">=</span><span class="n">rect_size</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">rect_size</span><span class="p">,</span>
            <span class="n">clip_box</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">,</span>
            <span class="n">facecolor</span><span class="o">=</span><span class="n">dir_colours</span><span class="p">[</span><span class="n">idx_of_dir_to_colour</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
            <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">c</span><span class="o">=</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">PatchCollection</span><span class="p">(</span><span class="n">rects</span><span class="p">,</span> <span class="n">match_original</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">add_colour_wheel</span><span class="p">:</span>
        <span class="n">ax_col</span> <span class="o">=</span> <span class="n">inset_axes</span><span class="p">(</span>
            <span class="n">ax</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="s2">&quot;100%&quot;</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="s2">&quot;100%&quot;</span><span class="p">,</span>
            <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">),</span>
            <span class="n">axes_class</span><span class="o">=</span><span class="n">get_projection_class</span><span class="p">(</span><span class="s2">&quot;polar&quot;</span><span class="p">),</span>
            <span class="n">bbox_transform</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">transFigure</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax_col</span><span class="o">.</span><span class="n">set_theta_zero_location</span><span class="p">(</span><span class="s2">&quot;N&quot;</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">col_map</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hls&quot;</span><span class="p">,</span> <span class="n">as_cmap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax_col</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">col_map</span><span class="p">)</span>
        <span class="n">ax_col</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([])</span>
        <span class="n">ax_col</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;polar&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax_col</span><span class="o">.</span><span class="n">set_thetagrids</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_hd_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_hd_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the head direction map for the specified cluster(s) and channel.</p>
<p>Args:
    cluster (int): The cluster(s) to get the head direction map
        for.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="nd">@stripAxes</span>
<span class="k">def</span> <span class="nf">plot_hd_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the head direction map for the specified cluster(s) and channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster(s) to get the head direction map</span>
<span class="sd">            for.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hd_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">add_mrv</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_mrv&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">add_guides</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_guides&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">fill</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fill&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">clean_kwargs</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;polar&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_theta_zero_location</span><span class="p">(</span><span class="s2">&quot;N&quot;</span><span class="p">)</span>
    <span class="c1"># need to deal with the case where the axis is supplied but</span>
    <span class="c1"># is not polar. deal with polar first</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span>
    <span class="p">)</span>  <span class="c1"># in samples so * pos sample_rate</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">hasData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;polar&quot;</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="n">hasData</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">add_guides</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_rgrids</span><span class="p">([])</span>

    <span class="c1"># See if we should add the mean resultant vector (mrv)</span>
    <span class="k">if</span> <span class="n">add_mrv</span> <span class="ow">and</span> <span class="n">hasData</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.common.statscalcs</span> <span class="kn">import</span> <span class="n">mean_resultant_vector</span>

        <span class="n">veclen</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">get_mean_resultant_length</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">th</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">get_mean_resultant_angle</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">th</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">veclen</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">],</span>
            <span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;polar&quot;</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_thetagrids</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_power_spectrum" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_power_spectrum</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the power spectrum.</p>
<p>Args:
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="k">def</span> <span class="nf">plot_power_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the power spectrum.</span>

<span class="sd">    Args:</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGCalcs</span><span class="o">.</span><span class="n">calcEEGPowerSpectrum</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPowerSpectrumPlot</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_raster" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_raster</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the raster plot for the specified cluster(s) and channel.</p>
<p>Args:
    cluster (int | list): The cluster(s) to get the raster plot for.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="k">def</span> <span class="nf">plot_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the raster plot for the specified cluster(s) and channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int | list): The cluster(s) to get the raster plot for.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRasterPlot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_rate_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_rate_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots the rate map for the specified cluster(s) and channel.</p>
<p>Args:
    cluster (int): The cluster(s) to get the rate map for.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="nd">@stripAxes</span>
<span class="k">def</span> <span class="nf">plot_rate_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the rate map for the specified cluster(s) and channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster(s) to get the rate map for.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rate_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">clean_kwargs</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># TODO: doesn&#39;t deal with multiple clusters being binned</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">cmap</span><span class="o">=</span><span class="n">jet_cmap</span><span class="p">,</span>
        <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span>
        <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
        <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_sac" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_sac</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the spatial autocorrelation for the specified cluster(s) and
channel.</p>
<p>Args:
    cluster (int): The cluster(s) to get the spatial
        autocorrelation for.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="nd">@stripAxes</span>
<span class="k">def</span> <span class="nf">plot_sac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the spatial autocorrelation for the specified cluster(s) and</span>
<span class="sd">    channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster(s) to get the spatial</span>
<span class="sd">            autocorrelation for.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
    <span class="n">measures</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">grid_field_props</span><span class="p">(</span><span class="n">sac</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">Am</span> <span class="o">=</span> <span class="n">sac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Am</span><span class="p">[</span><span class="o">~</span><span class="n">measures</span><span class="p">[</span><span class="s2">&quot;dist_to_centre&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">Am</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Am</span><span class="p">))</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">sac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
        <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="n">sac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">cmap</span><span class="o">=</span><span class="n">grey_cmap</span><span class="p">,</span>
        <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span>
        <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
        <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="kn">import</span> <span class="nn">copy</span>

    <span class="n">cmap</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">jet_cmap</span><span class="p">)</span>
    <span class="n">cmap</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
        <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="n">Am</span><span class="p">,</span>
        <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
        <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span>
        <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
        <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># horizontal green line at 3 o&#39;clock</span>
    <span class="n">_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="n">_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">)</span>
    <span class="n">mag</span> <span class="o">=</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.75</span>
    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">],</span> <span class="mi">50</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">ephysiopy.common.utils</span> <span class="kn">import</span> <span class="n">rect</span>

    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">rect</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># angle subtended by orientation</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># plot lines from centre to peaks above middle</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;closest_peak_coords&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;dist_to_centre&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
    <span class="n">all_ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">axes</span>
    <span class="n">all_ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_speed_v_hd" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_speed_v_hd</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the speed versus head direction plot for the specified cluster(s)
and channel.</p>
<p>Args:
    cluster (int): The cluster(s) to get the speed versus head
        direction plot for.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="k">def</span> <span class="nf">plot_speed_v_hd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the speed versus head direction plot for the specified cluster(s)</span>
<span class="sd">    and channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster(s) to get the speed versus head</span>
<span class="sd">            direction plot for.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_speed_v_hd_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="c1"># mask low rates...</span>
    <span class="c1"># im = np.ma.masked_where(im &lt;= 1, im)</span>
    <span class="c1"># ... and where less than 0.5% of data is accounted for</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">jet_cmap</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;face&quot;</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span>
        <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;90&quot;</span><span class="p">,</span> <span class="s2">&quot;180&quot;</span><span class="p">,</span> <span class="s2">&quot;270&quot;</span><span class="p">],</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span>
        <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span>
        <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;20&quot;</span><span class="p">,</span> <span class="s2">&quot;30&quot;</span><span class="p">,</span> <span class="s2">&quot;40&quot;</span><span class="p">],</span>
        <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Heading&quot;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_speed_v_rate" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_speed_v_rate</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the speed versus rate plot for the specified cluster(s) and
channel.</p>
<p>By default the distribution of speeds will be plotted as a twin
axis. To disable set add_speed_hist = False</p>
<p>Args:
    cluster (int): The cluster(s) to get the speed versus rate
        plot for.
    channel (int): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="k">def</span> <span class="nf">plot_speed_v_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the speed versus rate plot for the specified cluster(s) and</span>
<span class="sd">    channel.</span>

<span class="sd">    By default the distribution of speeds will be plotted as a twin</span>
<span class="sd">    axis. To disable set add_speed_hist = False</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster(s) to get the speed versus rate</span>
<span class="sd">            plot for.</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">add_speed_hist</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_speed_hist&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_speed_v_rate_map</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># rmap is linear</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">clean_kwargs</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax_colour</span> <span class="o">=</span> <span class="s2">&quot;cornflowerblue&quot;</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">ax_colour</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Speed (cm/s)&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Rate (Hz)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">add_speed_hist</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ax_colour</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">ax_colour</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ax_colour</span><span class="p">)</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
        <span class="n">ax2_colour</span> <span class="o">=</span> <span class="s2">&quot;grey&quot;</span>
        <span class="n">pos_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span>
        <span class="p">)</span>
        <span class="n">speed_bincounts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span><span class="p">,</span> <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">pos_weights</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">speed_bincounts</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
            <span class="n">ec</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span>
            <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Duration (s)&quot;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ax2_colour</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">ax2_colour</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ax2_colour</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_spike_path" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_spike_path</span><span class="p">(</span><span class="n">cluster</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the spike path for the specified cluster(s) and channel.</p>
<p>Args:
    cluster (int | None): The cluster(s) to get the spike path
        for.
    channel (int | None): The channel number.
    **kwargs: Additional keyword arguments for the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="nd">@stripAxes</span>
<span class="k">def</span> <span class="nf">plot_spike_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the spike path for the specified cluster(s) and channel.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int | None): The cluster(s) to get the spike path</span>
<span class="sd">            for.</span>
<span class="sd">        channel (int | None): The channel number.</span>
<span class="sd">        **kwargs: Additional keyword arguments for the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">marker</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;marker&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
        <span class="n">color</span><span class="o">=</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cluster</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spike_pos_idx</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">],</span>
            <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.visualise.plotting.FigureMaker.plot_xcorr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_xcorr</span><span class="p">(</span><span class="n">cluster_a</span><span class="p">,</span> <span class="n">channel_a</span><span class="p">,</span> <span class="n">cluster_b</span><span class="p">,</span> <span class="n">channel_b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots the temporal cross-correlogram between cluster_a and cluster_b</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster_a</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel_a</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>cluster_b</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel_b</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>plt.Axes : matplotlib.Axes instance</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/visualise/plotting.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="k">def</span> <span class="nf">plot_xcorr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">cluster_a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel_a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cluster_b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">channel_b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the temporal cross-correlogram between cluster_a and cluster_b</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster_a (int) : first cluster</span>
<span class="sd">    channel_a (int) : first channel</span>
<span class="sd">    cluster_b (int) : second cluster</span>
<span class="sd">    channel_b (int) : second channel</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    plt.Axes : matplotlib.Axes instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;strip_axes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">strip_axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;strip_axes&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strip_axes</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;binsize&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;binsize&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">binsize</span> <span class="o">=</span> <span class="mf">0.001</span>
    <span class="k">if</span> <span class="s2">&quot;Trange&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">xrange</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;Trange&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xrange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>

    <span class="n">a_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster_a</span><span class="p">,</span> <span class="n">channel_a</span><span class="p">)</span>
    <span class="n">b_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spike_times</span><span class="p">(</span><span class="n">cluster_b</span><span class="p">,</span> <span class="n">channel_b</span><span class="p">)</span>
    <span class="n">xcorr_binned</span> <span class="o">=</span> <span class="n">xcorr</span><span class="p">(</span><span class="n">a_times</span><span class="p">,</span> <span class="n">b_times</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">xrange</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">xcorr_binned</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">xcorr_binned</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xrange</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span>
        <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s2">&quot;bottom&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strip_axes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stripAxes</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">axtrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;lightgrey&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axtrans</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h2 id="binning-up-data">Binning up data</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.common.binning"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.binning.RateMap" class="doc doc-heading">
            <code>RateMap</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Bins up positional data (xy, head direction etc) and produces rate maps
of the relevant kind. This is a generic class meant to be independent of
any particular recording format.</p>
<p>Args:
    xy (ndarray): The xy data as a 2 x n_samples numpy array.
    hdir (ndarray): The head direction data a 1 x n_samples numpy array.
    speed (ndarray): Similar to hdir.
    pos_weights (ndarray): A 1 x n_samples numpy array used to weight a particular
        position samples when binning data. For example, if there were 5
        positions recorded and a cell spiked once in position 2 and 5 times
        in position 3 and nothing anywhere else then pos_weights looks like:
        [0 0 1 5 0]
        In the case of binning up position this will be an array of mostly 1's
        unless there are some positions you want excluded.
    ppm (int, optional): Pixels per metre. Specifies how many camera pixels per metre so this,
        in combination with cmsPerBin, will determine how many bins there are
        in the rate map. Defaults to None.
    xyInCms (bool, optional): Whether the positional data is in cms. Defaults to False.
    cmsPerBin (int, optional): How many cms on a side each bin is in a rate map OR the number of
        degrees per bin in the case of directional binning. Defaults to 3.
    smooth_sz (int, optional): The width of the smoothing kernel for smoothing rate maps. Defaults to 5.</p>
<p>Notes:
    There are several instance variables you can set, see below.</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  28</span>
<span class="normal">  29</span>
<span class="normal">  30</span>
<span class="normal">  31</span>
<span class="normal">  32</span>
<span class="normal">  33</span>
<span class="normal">  34</span>
<span class="normal">  35</span>
<span class="normal">  36</span>
<span class="normal">  37</span>
<span class="normal">  38</span>
<span class="normal">  39</span>
<span class="normal">  40</span>
<span class="normal">  41</span>
<span class="normal">  42</span>
<span class="normal">  43</span>
<span class="normal">  44</span>
<span class="normal">  45</span>
<span class="normal">  46</span>
<span class="normal">  47</span>
<span class="normal">  48</span>
<span class="normal">  49</span>
<span class="normal">  50</span>
<span class="normal">  51</span>
<span class="normal">  52</span>
<span class="normal">  53</span>
<span class="normal">  54</span>
<span class="normal">  55</span>
<span class="normal">  56</span>
<span class="normal">  57</span>
<span class="normal">  58</span>
<span class="normal">  59</span>
<span class="normal">  60</span>
<span class="normal">  61</span>
<span class="normal">  62</span>
<span class="normal">  63</span>
<span class="normal">  64</span>
<span class="normal">  65</span>
<span class="normal">  66</span>
<span class="normal">  67</span>
<span class="normal">  68</span>
<span class="normal">  69</span>
<span class="normal">  70</span>
<span class="normal">  71</span>
<span class="normal">  72</span>
<span class="normal">  73</span>
<span class="normal">  74</span>
<span class="normal">  75</span>
<span class="normal">  76</span>
<span class="normal">  77</span>
<span class="normal">  78</span>
<span class="normal">  79</span>
<span class="normal">  80</span>
<span class="normal">  81</span>
<span class="normal">  82</span>
<span class="normal">  83</span>
<span class="normal">  84</span>
<span class="normal">  85</span>
<span class="normal">  86</span>
<span class="normal">  87</span>
<span class="normal">  88</span>
<span class="normal">  89</span>
<span class="normal">  90</span>
<span class="normal">  91</span>
<span class="normal">  92</span>
<span class="normal">  93</span>
<span class="normal">  94</span>
<span class="normal">  95</span>
<span class="normal">  96</span>
<span class="normal">  97</span>
<span class="normal">  98</span>
<span class="normal">  99</span>
<span class="normal"> 100</span>
<span class="normal"> 101</span>
<span class="normal"> 102</span>
<span class="normal"> 103</span>
<span class="normal"> 104</span>
<span class="normal"> 105</span>
<span class="normal"> 106</span>
<span class="normal"> 107</span>
<span class="normal"> 108</span>
<span class="normal"> 109</span>
<span class="normal"> 110</span>
<span class="normal"> 111</span>
<span class="normal"> 112</span>
<span class="normal"> 113</span>
<span class="normal"> 114</span>
<span class="normal"> 115</span>
<span class="normal"> 116</span>
<span class="normal"> 117</span>
<span class="normal"> 118</span>
<span class="normal"> 119</span>
<span class="normal"> 120</span>
<span class="normal"> 121</span>
<span class="normal"> 122</span>
<span class="normal"> 123</span>
<span class="normal"> 124</span>
<span class="normal"> 125</span>
<span class="normal"> 126</span>
<span class="normal"> 127</span>
<span class="normal"> 128</span>
<span class="normal"> 129</span>
<span class="normal"> 130</span>
<span class="normal"> 131</span>
<span class="normal"> 132</span>
<span class="normal"> 133</span>
<span class="normal"> 134</span>
<span class="normal"> 135</span>
<span class="normal"> 136</span>
<span class="normal"> 137</span>
<span class="normal"> 138</span>
<span class="normal"> 139</span>
<span class="normal"> 140</span>
<span class="normal"> 141</span>
<span class="normal"> 142</span>
<span class="normal"> 143</span>
<span class="normal"> 144</span>
<span class="normal"> 145</span>
<span class="normal"> 146</span>
<span class="normal"> 147</span>
<span class="normal"> 148</span>
<span class="normal"> 149</span>
<span class="normal"> 150</span>
<span class="normal"> 151</span>
<span class="normal"> 152</span>
<span class="normal"> 153</span>
<span class="normal"> 154</span>
<span class="normal"> 155</span>
<span class="normal"> 156</span>
<span class="normal"> 157</span>
<span class="normal"> 158</span>
<span class="normal"> 159</span>
<span class="normal"> 160</span>
<span class="normal"> 161</span>
<span class="normal"> 162</span>
<span class="normal"> 163</span>
<span class="normal"> 164</span>
<span class="normal"> 165</span>
<span class="normal"> 166</span>
<span class="normal"> 167</span>
<span class="normal"> 168</span>
<span class="normal"> 169</span>
<span class="normal"> 170</span>
<span class="normal"> 171</span>
<span class="normal"> 172</span>
<span class="normal"> 173</span>
<span class="normal"> 174</span>
<span class="normal"> 175</span>
<span class="normal"> 176</span>
<span class="normal"> 177</span>
<span class="normal"> 178</span>
<span class="normal"> 179</span>
<span class="normal"> 180</span>
<span class="normal"> 181</span>
<span class="normal"> 182</span>
<span class="normal"> 183</span>
<span class="normal"> 184</span>
<span class="normal"> 185</span>
<span class="normal"> 186</span>
<span class="normal"> 187</span>
<span class="normal"> 188</span>
<span class="normal"> 189</span>
<span class="normal"> 190</span>
<span class="normal"> 191</span>
<span class="normal"> 192</span>
<span class="normal"> 193</span>
<span class="normal"> 194</span>
<span class="normal"> 195</span>
<span class="normal"> 196</span>
<span class="normal"> 197</span>
<span class="normal"> 198</span>
<span class="normal"> 199</span>
<span class="normal"> 200</span>
<span class="normal"> 201</span>
<span class="normal"> 202</span>
<span class="normal"> 203</span>
<span class="normal"> 204</span>
<span class="normal"> 205</span>
<span class="normal"> 206</span>
<span class="normal"> 207</span>
<span class="normal"> 208</span>
<span class="normal"> 209</span>
<span class="normal"> 210</span>
<span class="normal"> 211</span>
<span class="normal"> 212</span>
<span class="normal"> 213</span>
<span class="normal"> 214</span>
<span class="normal"> 215</span>
<span class="normal"> 216</span>
<span class="normal"> 217</span>
<span class="normal"> 218</span>
<span class="normal"> 219</span>
<span class="normal"> 220</span>
<span class="normal"> 221</span>
<span class="normal"> 222</span>
<span class="normal"> 223</span>
<span class="normal"> 224</span>
<span class="normal"> 225</span>
<span class="normal"> 226</span>
<span class="normal"> 227</span>
<span class="normal"> 228</span>
<span class="normal"> 229</span>
<span class="normal"> 230</span>
<span class="normal"> 231</span>
<span class="normal"> 232</span>
<span class="normal"> 233</span>
<span class="normal"> 234</span>
<span class="normal"> 235</span>
<span class="normal"> 236</span>
<span class="normal"> 237</span>
<span class="normal"> 238</span>
<span class="normal"> 239</span>
<span class="normal"> 240</span>
<span class="normal"> 241</span>
<span class="normal"> 242</span>
<span class="normal"> 243</span>
<span class="normal"> 244</span>
<span class="normal"> 245</span>
<span class="normal"> 246</span>
<span class="normal"> 247</span>
<span class="normal"> 248</span>
<span class="normal"> 249</span>
<span class="normal"> 250</span>
<span class="normal"> 251</span>
<span class="normal"> 252</span>
<span class="normal"> 253</span>
<span class="normal"> 254</span>
<span class="normal"> 255</span>
<span class="normal"> 256</span>
<span class="normal"> 257</span>
<span class="normal"> 258</span>
<span class="normal"> 259</span>
<span class="normal"> 260</span>
<span class="normal"> 261</span>
<span class="normal"> 262</span>
<span class="normal"> 263</span>
<span class="normal"> 264</span>
<span class="normal"> 265</span>
<span class="normal"> 266</span>
<span class="normal"> 267</span>
<span class="normal"> 268</span>
<span class="normal"> 269</span>
<span class="normal"> 270</span>
<span class="normal"> 271</span>
<span class="normal"> 272</span>
<span class="normal"> 273</span>
<span class="normal"> 274</span>
<span class="normal"> 275</span>
<span class="normal"> 276</span>
<span class="normal"> 277</span>
<span class="normal"> 278</span>
<span class="normal"> 279</span>
<span class="normal"> 280</span>
<span class="normal"> 281</span>
<span class="normal"> 282</span>
<span class="normal"> 283</span>
<span class="normal"> 284</span>
<span class="normal"> 285</span>
<span class="normal"> 286</span>
<span class="normal"> 287</span>
<span class="normal"> 288</span>
<span class="normal"> 289</span>
<span class="normal"> 290</span>
<span class="normal"> 291</span>
<span class="normal"> 292</span>
<span class="normal"> 293</span>
<span class="normal"> 294</span>
<span class="normal"> 295</span>
<span class="normal"> 296</span>
<span class="normal"> 297</span>
<span class="normal"> 298</span>
<span class="normal"> 299</span>
<span class="normal"> 300</span>
<span class="normal"> 301</span>
<span class="normal"> 302</span>
<span class="normal"> 303</span>
<span class="normal"> 304</span>
<span class="normal"> 305</span>
<span class="normal"> 306</span>
<span class="normal"> 307</span>
<span class="normal"> 308</span>
<span class="normal"> 309</span>
<span class="normal"> 310</span>
<span class="normal"> 311</span>
<span class="normal"> 312</span>
<span class="normal"> 313</span>
<span class="normal"> 314</span>
<span class="normal"> 315</span>
<span class="normal"> 316</span>
<span class="normal"> 317</span>
<span class="normal"> 318</span>
<span class="normal"> 319</span>
<span class="normal"> 320</span>
<span class="normal"> 321</span>
<span class="normal"> 322</span>
<span class="normal"> 323</span>
<span class="normal"> 324</span>
<span class="normal"> 325</span>
<span class="normal"> 326</span>
<span class="normal"> 327</span>
<span class="normal"> 328</span>
<span class="normal"> 329</span>
<span class="normal"> 330</span>
<span class="normal"> 331</span>
<span class="normal"> 332</span>
<span class="normal"> 333</span>
<span class="normal"> 334</span>
<span class="normal"> 335</span>
<span class="normal"> 336</span>
<span class="normal"> 337</span>
<span class="normal"> 338</span>
<span class="normal"> 339</span>
<span class="normal"> 340</span>
<span class="normal"> 341</span>
<span class="normal"> 342</span>
<span class="normal"> 343</span>
<span class="normal"> 344</span>
<span class="normal"> 345</span>
<span class="normal"> 346</span>
<span class="normal"> 347</span>
<span class="normal"> 348</span>
<span class="normal"> 349</span>
<span class="normal"> 350</span>
<span class="normal"> 351</span>
<span class="normal"> 352</span>
<span class="normal"> 353</span>
<span class="normal"> 354</span>
<span class="normal"> 355</span>
<span class="normal"> 356</span>
<span class="normal"> 357</span>
<span class="normal"> 358</span>
<span class="normal"> 359</span>
<span class="normal"> 360</span>
<span class="normal"> 361</span>
<span class="normal"> 362</span>
<span class="normal"> 363</span>
<span class="normal"> 364</span>
<span class="normal"> 365</span>
<span class="normal"> 366</span>
<span class="normal"> 367</span>
<span class="normal"> 368</span>
<span class="normal"> 369</span>
<span class="normal"> 370</span>
<span class="normal"> 371</span>
<span class="normal"> 372</span>
<span class="normal"> 373</span>
<span class="normal"> 374</span>
<span class="normal"> 375</span>
<span class="normal"> 376</span>
<span class="normal"> 377</span>
<span class="normal"> 378</span>
<span class="normal"> 379</span>
<span class="normal"> 380</span>
<span class="normal"> 381</span>
<span class="normal"> 382</span>
<span class="normal"> 383</span>
<span class="normal"> 384</span>
<span class="normal"> 385</span>
<span class="normal"> 386</span>
<span class="normal"> 387</span>
<span class="normal"> 388</span>
<span class="normal"> 389</span>
<span class="normal"> 390</span>
<span class="normal"> 391</span>
<span class="normal"> 392</span>
<span class="normal"> 393</span>
<span class="normal"> 394</span>
<span class="normal"> 395</span>
<span class="normal"> 396</span>
<span class="normal"> 397</span>
<span class="normal"> 398</span>
<span class="normal"> 399</span>
<span class="normal"> 400</span>
<span class="normal"> 401</span>
<span class="normal"> 402</span>
<span class="normal"> 403</span>
<span class="normal"> 404</span>
<span class="normal"> 405</span>
<span class="normal"> 406</span>
<span class="normal"> 407</span>
<span class="normal"> 408</span>
<span class="normal"> 409</span>
<span class="normal"> 410</span>
<span class="normal"> 411</span>
<span class="normal"> 412</span>
<span class="normal"> 413</span>
<span class="normal"> 414</span>
<span class="normal"> 415</span>
<span class="normal"> 416</span>
<span class="normal"> 417</span>
<span class="normal"> 418</span>
<span class="normal"> 419</span>
<span class="normal"> 420</span>
<span class="normal"> 421</span>
<span class="normal"> 422</span>
<span class="normal"> 423</span>
<span class="normal"> 424</span>
<span class="normal"> 425</span>
<span class="normal"> 426</span>
<span class="normal"> 427</span>
<span class="normal"> 428</span>
<span class="normal"> 429</span>
<span class="normal"> 430</span>
<span class="normal"> 431</span>
<span class="normal"> 432</span>
<span class="normal"> 433</span>
<span class="normal"> 434</span>
<span class="normal"> 435</span>
<span class="normal"> 436</span>
<span class="normal"> 437</span>
<span class="normal"> 438</span>
<span class="normal"> 439</span>
<span class="normal"> 440</span>
<span class="normal"> 441</span>
<span class="normal"> 442</span>
<span class="normal"> 443</span>
<span class="normal"> 444</span>
<span class="normal"> 445</span>
<span class="normal"> 446</span>
<span class="normal"> 447</span>
<span class="normal"> 448</span>
<span class="normal"> 449</span>
<span class="normal"> 450</span>
<span class="normal"> 451</span>
<span class="normal"> 452</span>
<span class="normal"> 453</span>
<span class="normal"> 454</span>
<span class="normal"> 455</span>
<span class="normal"> 456</span>
<span class="normal"> 457</span>
<span class="normal"> 458</span>
<span class="normal"> 459</span>
<span class="normal"> 460</span>
<span class="normal"> 461</span>
<span class="normal"> 462</span>
<span class="normal"> 463</span>
<span class="normal"> 464</span>
<span class="normal"> 465</span>
<span class="normal"> 466</span>
<span class="normal"> 467</span>
<span class="normal"> 468</span>
<span class="normal"> 469</span>
<span class="normal"> 470</span>
<span class="normal"> 471</span>
<span class="normal"> 472</span>
<span class="normal"> 473</span>
<span class="normal"> 474</span>
<span class="normal"> 475</span>
<span class="normal"> 476</span>
<span class="normal"> 477</span>
<span class="normal"> 478</span>
<span class="normal"> 479</span>
<span class="normal"> 480</span>
<span class="normal"> 481</span>
<span class="normal"> 482</span>
<span class="normal"> 483</span>
<span class="normal"> 484</span>
<span class="normal"> 485</span>
<span class="normal"> 486</span>
<span class="normal"> 487</span>
<span class="normal"> 488</span>
<span class="normal"> 489</span>
<span class="normal"> 490</span>
<span class="normal"> 491</span>
<span class="normal"> 492</span>
<span class="normal"> 493</span>
<span class="normal"> 494</span>
<span class="normal"> 495</span>
<span class="normal"> 496</span>
<span class="normal"> 497</span>
<span class="normal"> 498</span>
<span class="normal"> 499</span>
<span class="normal"> 500</span>
<span class="normal"> 501</span>
<span class="normal"> 502</span>
<span class="normal"> 503</span>
<span class="normal"> 504</span>
<span class="normal"> 505</span>
<span class="normal"> 506</span>
<span class="normal"> 507</span>
<span class="normal"> 508</span>
<span class="normal"> 509</span>
<span class="normal"> 510</span>
<span class="normal"> 511</span>
<span class="normal"> 512</span>
<span class="normal"> 513</span>
<span class="normal"> 514</span>
<span class="normal"> 515</span>
<span class="normal"> 516</span>
<span class="normal"> 517</span>
<span class="normal"> 518</span>
<span class="normal"> 519</span>
<span class="normal"> 520</span>
<span class="normal"> 521</span>
<span class="normal"> 522</span>
<span class="normal"> 523</span>
<span class="normal"> 524</span>
<span class="normal"> 525</span>
<span class="normal"> 526</span>
<span class="normal"> 527</span>
<span class="normal"> 528</span>
<span class="normal"> 529</span>
<span class="normal"> 530</span>
<span class="normal"> 531</span>
<span class="normal"> 532</span>
<span class="normal"> 533</span>
<span class="normal"> 534</span>
<span class="normal"> 535</span>
<span class="normal"> 536</span>
<span class="normal"> 537</span>
<span class="normal"> 538</span>
<span class="normal"> 539</span>
<span class="normal"> 540</span>
<span class="normal"> 541</span>
<span class="normal"> 542</span>
<span class="normal"> 543</span>
<span class="normal"> 544</span>
<span class="normal"> 545</span>
<span class="normal"> 546</span>
<span class="normal"> 547</span>
<span class="normal"> 548</span>
<span class="normal"> 549</span>
<span class="normal"> 550</span>
<span class="normal"> 551</span>
<span class="normal"> 552</span>
<span class="normal"> 553</span>
<span class="normal"> 554</span>
<span class="normal"> 555</span>
<span class="normal"> 556</span>
<span class="normal"> 557</span>
<span class="normal"> 558</span>
<span class="normal"> 559</span>
<span class="normal"> 560</span>
<span class="normal"> 561</span>
<span class="normal"> 562</span>
<span class="normal"> 563</span>
<span class="normal"> 564</span>
<span class="normal"> 565</span>
<span class="normal"> 566</span>
<span class="normal"> 567</span>
<span class="normal"> 568</span>
<span class="normal"> 569</span>
<span class="normal"> 570</span>
<span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">RateMap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bins up positional data (xy, head direction etc) and produces rate maps</span>
<span class="sd">    of the relevant kind. This is a generic class meant to be independent of</span>
<span class="sd">    any particular recording format.</span>

<span class="sd">    Args:</span>
<span class="sd">        xy (ndarray): The xy data as a 2 x n_samples numpy array.</span>
<span class="sd">        hdir (ndarray): The head direction data a 1 x n_samples numpy array.</span>
<span class="sd">        speed (ndarray): Similar to hdir.</span>
<span class="sd">        pos_weights (ndarray): A 1 x n_samples numpy array used to weight a particular</span>
<span class="sd">            position samples when binning data. For example, if there were 5</span>
<span class="sd">            positions recorded and a cell spiked once in position 2 and 5 times</span>
<span class="sd">            in position 3 and nothing anywhere else then pos_weights looks like:</span>
<span class="sd">            [0 0 1 5 0]</span>
<span class="sd">            In the case of binning up position this will be an array of mostly 1&#39;s</span>
<span class="sd">            unless there are some positions you want excluded.</span>
<span class="sd">        ppm (int, optional): Pixels per metre. Specifies how many camera pixels per metre so this,</span>
<span class="sd">            in combination with cmsPerBin, will determine how many bins there are</span>
<span class="sd">            in the rate map. Defaults to None.</span>
<span class="sd">        xyInCms (bool, optional): Whether the positional data is in cms. Defaults to False.</span>
<span class="sd">        cmsPerBin (int, optional): How many cms on a side each bin is in a rate map OR the number of</span>
<span class="sd">            degrees per bin in the case of directional binning. Defaults to 3.</span>
<span class="sd">        smooth_sz (int, optional): The width of the smoothing kernel for smoothing rate maps. Defaults to 5.</span>

<span class="sd">    Notes:</span>
<span class="sd">        There are several instance variables you can set, see below.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">PosCalcs</span><span class="p">:</span> <span class="n">PosCalcsGeneric</span><span class="p">,</span>
        <span class="n">pos_weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">xyInCms</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">binsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">smooth_sz</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span> <span class="o">=</span> <span class="n">PosCalcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_weights</span> <span class="o">=</span> <span class="n">pos_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_time_splits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spike_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binsize</span> <span class="o">=</span> <span class="n">binsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binsize2d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inCms</span> <span class="o">=</span> <span class="n">xyInCms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binedges</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># has setter and getter - see below</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_lims</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y_lims</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smooth_sz</span> <span class="o">=</span> <span class="n">smooth_sz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothingType</span> <span class="o">=</span> <span class="s2">&quot;gaussian&quot;</span>  <span class="c1"># &#39;boxcar&#39; or &#39;gaussian&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whenToSmooth</span> <span class="o">=</span> <span class="s2">&quot;before&quot;</span>  <span class="c1"># or &#39;after&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var2Bin</span> <span class="o">=</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mapType</span> <span class="o">=</span> <span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bin_edges</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">dir</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">speed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">speed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xyTS</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inCms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Whether the units are in cms or not</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inCms</span>

    <span class="nd">@inCms</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inCms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inCms</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1"># will trigger a recalculation of position vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">convert2cm</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ppm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Get the current pixels per metre (ppm)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">ppm</span>

    <span class="nd">@ppm</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ppm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># will trigger a recalculation of position vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">ppm</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var2Bin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var2Bin</span>

    <span class="nd">@var2Bin</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">var2Bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var2Bin</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mapType</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapType</span>

    <span class="nd">@mapType</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mapType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mapType</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">binedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binedges</span>

    <span class="nd">@binedges</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">binedges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binedges</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x_lims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_lims</span>

    <span class="nd">@x_lims</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x_lims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_lims</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y_lims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y_lims</span>

    <span class="nd">@y_lims</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">y_lims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y_lims</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The &#39;weights&#39; used as an argument to np.histogram* for binning up</span>
<span class="sd">        position</span>
<span class="sd">        Mostly this is just an array of 1&#39;s equal to the length of the pos</span>
<span class="sd">        data, but usefully can be adjusted when masking data in the trial</span>
<span class="sd">        by</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">npos</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_weights</span>

    <span class="nd">@pos_weights</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pos_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_weights</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spike_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spike_weights</span>

    <span class="nd">@spike_weights</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">spike_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spike_weights</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">binsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The number of cms per bin of the binned up map</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binsize</span>

    <span class="nd">@binsize</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">binsize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binsize</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binedges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bin_edges</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smooth_sz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The size of the smoothing window applied to the binned data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smooth_sz</span>

    <span class="nd">@smooth_sz</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">smooth_sz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smooth_sz</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smoothingType</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The type of smoothing to do - legal values are &#39;boxcar&#39; or &#39;gaussian&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothingType</span>

    <span class="nd">@smoothingType</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">smoothingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothingType</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="c1"># self.PosCalcs.apply_mask(mask)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_weights</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">_getXYLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the min/max of the x/y data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_lims</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;x_lims&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">y_lims</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;y_lims&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_lims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_lims</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">y_lims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_lims</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_lims</span> <span class="o">=</span> <span class="n">x_lims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_lims</span> <span class="o">=</span> <span class="n">y_lims</span>
        <span class="k">return</span> <span class="n">x_lims</span><span class="p">,</span> <span class="n">y_lims</span>

    <span class="k">def</span> <span class="nf">_calc_bin_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_binDims</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binedges</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_binDims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_binedges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aims to get the right number of bins for the variable to be binned</span>

<span class="sd">        Args:</span>
<span class="sd">            binsize (int | tuple, optional): The number of cms per bin for XY OR degrees for DIR OR cm/s for SPEED. Defaults to 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: each member an array of bin edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">DIR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">360</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">maxspeed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
            <span class="c1"># assume min speed = 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxspeed</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxspeed</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">x_lims</span><span class="p">,</span> <span class="n">y_lims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getXYLimits</span><span class="p">()</span>
            <span class="n">nxbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
            <span class="n">nybins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nxbins</span><span class="p">)</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nybins</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_x</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY_TIME</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_time_splits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need pos times to bin up XY_TIME&quot;</span><span class="p">)</span>
            <span class="n">x_lims</span><span class="p">,</span> <span class="n">y_lims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getXYLimits</span><span class="p">()</span>
            <span class="n">nxbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
            <span class="n">nybins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nxbins</span><span class="p">)</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nybins</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_time_splits</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED_DIR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">maxspeed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxspeed</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxspeed</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">360</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxspeed</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxspeed</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">360</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">EGO_BOUNDARY</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">50</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bin_dims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span>

    <span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spk_weights</span><span class="p">,</span>
        <span class="n">var_type</span><span class="o">=</span><span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
        <span class="n">map_type</span><span class="o">=</span><span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span><span class="p">,</span>
        <span class="n">smoothing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bins up the variable type var_type and returns a tuple of</span>
<span class="sd">        (rmap, binnedPositionDir) or</span>
<span class="sd">        (rmap, binnedPostionX, binnedPositionY)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spk_weights (np.ndarray) - Shape equal to number of positions samples captured and consists of</span>
<span class="sd">            position weights. For example, if there were 5 positions</span>
<span class="sd">            recorded and a cell spiked once in position 2 and 5 times in</span>
<span class="sd">            position 3 and nothing anywhere else then pos_weights looks</span>
<span class="sd">            like: [0 0 1 5 0].</span>
<span class="sd">            spk_weights can also be list-like where each entry in the list is a different set of</span>
<span class="sd">            weights - these are enumerated through in a list comp in the ._bin_data function. In</span>
<span class="sd">            this case the returned tuple will consist of a 2-tuple where the first entry is an</span>
<span class="sd">            array of the ratemaps (binned_spk / binned_pos) and the second part is the binned pos data (as it&#39;s common to all</span>
<span class="sd">            the spike weights)</span>

<span class="sd">        var_type (Variable2Bin) - The variable to bin. See ephysiopy.common.utils for legal values.</span>


<span class="sd">        map_type (MapType) - The kind of map returned. See ephysiopy.common.utils for legal values.</span>

<span class="sd">        smoothing (bool, optional): Smooth the data or not. Default True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        binned_data (BinnedData): An instance of BinnedData containing the binned data, the bin edges, the variable binned and</span>
<span class="sd">                                  the map type. See ephysiopy.common.utils for details of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="s2">&quot;extend&quot;</span>
        <span class="n">pos_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_weights</span>
        <span class="k">if</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">DIR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir</span>
            <span class="n">boundary</span> <span class="o">=</span> <span class="s2">&quot;wrap&quot;</span>
        <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">speed</span>
        <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>
        <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY_TIME</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_times</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED_DIR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">EGO_BOUNDARY</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">arena_shape</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;arena_shape&quot;</span><span class="p">,</span> <span class="s2">&quot;circle&quot;</span><span class="p">)</span>
            <span class="n">boundary</span> <span class="o">=</span> <span class="s2">&quot;wrap&quot;</span>
            <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;binsize&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">binsize</span> <span class="o">=</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># breakpoint()</span>
            <span class="n">ego_angles</span><span class="p">,</span> <span class="n">arena_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_ego_angles</span><span class="p">(</span><span class="n">arena_shape</span><span class="p">,</span> <span class="n">binsize</span><span class="p">)</span>
            <span class="n">ego_dists</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">arena_xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ego_angles</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ego_dists</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span>
            <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">)</span>
            <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="n">arena_xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">pos_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_weights</span><span class="p">,</span> <span class="n">arena_xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">hist_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;range&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;range&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hist_range</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized variable to bin.&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span> <span class="o">=</span> <span class="n">var_type</span>
        <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;binsize&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">binsize</span><span class="p">)</span>
        <span class="n">hist_range</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;range&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hist_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bin_edges</span><span class="p">(</span><span class="n">binsize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">binned_pos</span><span class="p">,</span> <span class="n">binned_pos_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_data</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">pos_weights</span><span class="p">)</span>
        <span class="n">binned_pos</span> <span class="o">=</span> <span class="n">binned_pos</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span>
        <span class="n">nanIdx</span> <span class="o">=</span> <span class="n">binned_pos</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">var_type</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">POS</span><span class="p">,</span> <span class="p">[</span><span class="n">binned_pos</span><span class="p">],</span> <span class="n">binned_pos_edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">map_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>  <span class="c1"># return binned up position</span>
            <span class="k">if</span> <span class="n">smoothing</span><span class="p">:</span>
                <span class="n">sm_pos</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span>
                    <span class="n">pos</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
                    <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
                    <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
                <span class="n">sm_pos</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">nanIdx</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">sm_pos</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">nanIdx</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">pos</span>

        <span class="n">binned_spk</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_data</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">spk_weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binned_spk</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">binned_spk</span> <span class="o">=</span> <span class="p">[</span><span class="n">binned_spk</span><span class="p">]</span>
        <span class="n">spk</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">var_type</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">SPK</span><span class="p">,</span> <span class="n">binned_spk</span><span class="p">,</span> <span class="n">binned_pos_edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">map_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">SPK</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">smoothing</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">blur_image</span><span class="p">(</span>
                    <span class="n">spk</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
                    <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
                    <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">spk</span>
        <span class="k">if</span> <span class="n">map_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">ADAPTIVE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="c1"># deal with a stack of binned maps</span>
            <span class="k">if</span> <span class="n">binned_spk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">smthd_rate</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">binned_spk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">smthd_rate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getAdaptiveMap</span><span class="p">(</span><span class="n">binned_pos</span><span class="p">,</span> <span class="n">binned_spk</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">alpha</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">smthd_rate</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAdaptiveMap</span><span class="p">(</span><span class="n">binned_pos</span><span class="p">,</span> <span class="n">binned_spk</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">var_type</span><span class="p">,</span> <span class="n">map_type</span><span class="p">,</span> <span class="n">smthd_rate</span><span class="p">,</span> <span class="n">binned_pos_edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">smoothing</span><span class="p">:</span>
            <span class="n">rmap</span> <span class="o">=</span> <span class="n">spk</span> <span class="o">/</span> <span class="n">pos</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">map_type</span> <span class="o">=</span> <span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span>
            <span class="n">rmap</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">nanIdx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rmap</span>

        <span class="k">if</span> <span class="s2">&quot;after&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">whenToSmooth</span><span class="p">:</span>
            <span class="n">rmap</span> <span class="o">=</span> <span class="n">spk</span> <span class="o">/</span> <span class="n">pos</span>
            <span class="n">rmap</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span>
                <span class="n">rmap</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
                <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
                <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># default case</span>
            <span class="n">sm_pos</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span>
                <span class="n">pos</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
                <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
                <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="n">sm_spk</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span>
                <span class="n">spk</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
                <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
                <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="n">rmap</span> <span class="o">=</span> <span class="n">sm_spk</span> <span class="o">/</span> <span class="n">sm_pos</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">nanIdx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rmap</span>

    <span class="k">def</span> <span class="nf">_bin_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bins data taking account of possible multi-dimensionality</span>

<span class="sd">        Args:</span>
<span class="sd">            var (array_like): The variable to bin</span>
<span class="sd">            bin_edges (array_like): The edges of the data - see numpys histogramdd for more</span>
<span class="sd">            weights (array_like): The weights attributed to the samples in var</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndhist (2-tuple): Returns a two-tuple of the binned variable and</span>
<span class="sd">                the bin edges</span>

<span class="sd">        Notes:</span>
<span class="sd">            This breaks compatability with numpys histogramdd</span>
<span class="sd">            In the 2d histogram case below I swap the axes around so that x and y</span>
<span class="sd">            are binned in the &#39;normal&#39; format i.e. so x appears horizontally and y</span>
<span class="sd">            vertically.</span>
<span class="sd">            Multi-binning issue is dealt with awkwardly through checking</span>
<span class="sd">            the dimensionality of the weights array.</span>
<span class="sd">            &#39;normally&#39; this would be 1 dim but when multiple clusters are being</span>
<span class="sd">            binned it will be 2 dim.</span>
<span class="sd">            In that case np.apply_along_axis functionality is applied.</span>
<span class="sd">            The spike weights in that case might be created like so:</span>

<span class="sd">            &gt;&gt;&gt; spk_W = np.zeros(shape=[len(trial.nClusters), trial.npos])</span>
<span class="sd">            &gt;&gt;&gt; for i, cluster in enumerate(trial.clusters):</span>
<span class="sd">            &gt;&gt;&gt;		x1 = trial.getClusterIdx(cluster)</span>
<span class="sd">            &gt;&gt;&gt;		spk_W[i, :] = np.bincount(x1, minlength=trial.npos)</span>

<span class="sd">            This can then be fed into this fcn something like so:</span>

<span class="sd">            &gt;&gt;&gt; rng = np.array((np.ma.min(</span>
<span class="sd">                trial.POS.xy, 1).data, np.ma.max(rial.POS.xy, 1).data))</span>
<span class="sd">            &gt;&gt;&gt; h = _bin_data(</span>
<span class="sd">                var=trial.POS.xy, bin_edges=np.array([64, 64]),</span>
<span class="sd">                weights=spk_W, rng=rng)</span>

<span class="sd">            Returned will be a tuple containing the binned up data and</span>
<span class="sd">            the bin edges for x and y (obv this will be the same for all</span>
<span class="sd">            entries of h)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dims</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># needed for list comp below</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">bh</span><span class="o">.</span><span class="n">Histogram</span><span class="p">(</span>
                <span class="n">bh</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">Regular</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">bh</span><span class="o">.</span><span class="n">Histogram</span><span class="p">(</span>
                <span class="n">bh</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">Regular</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">bh</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">Regular</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">)</span>
        <span class="n">ndhist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>
            <span class="n">hist</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
            <span class="n">ndhist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">hist</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">hist</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">edges</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">hist</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">weights</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ndhist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ndhist</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ndhist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getAdaptiveMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_binned</span><span class="p">,</span> <span class="n">spk_binned</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces a ratemap that has been adaptively binned according to the</span>
<span class="sd">        algorithm described in Skaggs et al., 1996) [1]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pos_binned (array_like): The binned positional data. For example that returned from get_map</span>
<span class="sd">            above with mapType as &#39;pos&#39;</span>
<span class="sd">        spk_binned (array_like): The binned spikes</span>
<span class="sd">        alpha (int, optional): A scaling parameter determing the amount of occupancy to aim at</span>
<span class="sd">            in each bin. Defaults to 4. In the original paper this was set to 200.</span>
<span class="sd">            This is 4 here as the pos data is binned in seconds (the original data was in pos</span>
<span class="sd">            samples so this is a factor of 50 smaller than the original paper&#39;s value, given 50Hz sample rate)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Returns adaptively binned spike and pos maps. Use to generate Skaggs</span>
<span class="sd">        information measure</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Positions with high rates mean proportionately less error than those</span>
<span class="sd">        with low rates, so this tries to even the playing field. This type</span>
<span class="sd">        of binning should be used for calculations of spatial info</span>
<span class="sd">        as with the skaggs_info method in the fieldcalcs class (see below)</span>
<span class="sd">        alpha is a scaling parameter that might need tweaking for different</span>
<span class="sd">        data sets.</span>

<span class="sd">        From the paper:</span>
<span class="sd">            The data [are] first binned</span>
<span class="sd">            into a 64 X 64 grid of spatial locations, and then the firing rate</span>
<span class="sd">            at each point in this grid was calculated by expanding a circle</span>
<span class="sd">            around the point until the following criterion was met:</span>
<span class="sd">                Nspks &gt; alpha / (Nocc^2 * r^2)</span>
<span class="sd">            where Nspks is the number of spikes emitted in a circle of radius</span>
<span class="sd">            r (in bins), Nocc is the number of occupancy samples, alpha is the</span>
<span class="sd">            scaling parameter</span>
<span class="sd">            The firing rate in the given bin is then calculated as:</span>
<span class="sd">                sample_rate * (Nspks / Nocc)</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] W. E. Skaggs, B. L. McNaughton, K. M. Gothard &amp; E. J. Markus</span>
<span class="sd">            &quot;An Information-Theoretic Approach to Deciphering the Hippocampal</span>
<span class="sd">            Code&quot;</span>
<span class="sd">            Neural Information Processing Systems, 1993.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  assign output arrays</span>
        <span class="n">smthdpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">)</span>
        <span class="n">smthdspk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">spk_binned</span><span class="p">)</span>
        <span class="n">smthdrate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pos_binned</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">pos_binned</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">spk_binned</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">)</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">pos_binned</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># array to check which bins have made it</span>
        <span class="n">bincheck</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">bincheck</span><span class="p">):</span>
            <span class="c1"># create the filter kernel</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;=</span> <span class="n">pos_binned</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># filter the arrays using astropys convolution</span>
            <span class="n">filtpos</span> <span class="o">=</span> <span class="n">convolution</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="n">filtspk</span> <span class="o">=</span> <span class="n">convolution</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">spk_binned</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="n">filtvisited</span> <span class="o">=</span> <span class="n">convolution</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="c1"># get the bins which made it through this iteration</span>
            <span class="n">truebins</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">filtspk</span><span class="p">)</span> <span class="o">*</span> <span class="n">filtpos</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span>
            <span class="n">truebins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">truebins</span><span class="p">,</span> <span class="o">~</span><span class="n">bincheck</span><span class="p">)</span>
            <span class="c1"># insert values where true</span>
            <span class="n">smthdpos</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtpos</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">/</span> <span class="n">filtvisited</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span>
            <span class="n">smthdspk</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtspk</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">/</span> <span class="n">filtvisited</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span>
            <span class="n">bincheck</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">smthdrate</span> <span class="o">=</span> <span class="n">smthdspk</span> <span class="o">/</span> <span class="n">smthdpos</span>
        <span class="n">smthdrate</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">smthdspk</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">smthdpos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">smthdrate</span><span class="p">,</span> <span class="n">smthdspk</span><span class="p">,</span> <span class="n">smthdpos</span>

    <span class="k">def</span> <span class="nf">autoCorr2D</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span> <span class="n">nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs autocorrelations on all the maps in an instance of BinnedData.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A (BinnedData) - instance of BinnedData</span>
<span class="sd">        nodwell (np.ndarray) - array with NaNs where there was no position sampled.</span>
<span class="sd">        tol (float) - values below this are set to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BinnedData - the data in A with the maps replaced by autocorrelograms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">AUTO_CORR</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rmap</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">binned_data</span><span class="p">:</span>
            <span class="n">rr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoCorr2D</span><span class="p">(</span><span class="n">rmap</span><span class="p">,</span> <span class="n">nodwell</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">binned_data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">rr</span><span class="p">]</span>
        <span class="n">xlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">ylen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">result</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">xlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">ylen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ylen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_autoCorr2D</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a spatial autocorrelation on the array A</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A (array_like): Either 2 or 3D. In the former it is simply the binned up ratemap</span>
<span class="sd">            where the two dimensions correspond to x and y.</span>
<span class="sd">            If 3D then the first two dimensions are x</span>
<span class="sd">            and y and the third (last dimension) is &#39;stack&#39; of ratemaps</span>
<span class="sd">        nodwell (array_like): A boolean array corresponding the bins in the ratemap that</span>
<span class="sd">            weren&#39;t visited. See Notes below.</span>
<span class="sd">        tol (float, optional): Values below this are set to zero to deal with v small values</span>
<span class="sd">            thrown up by the fft. Default 1e-10</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sac (array_like): The spatial autocorrelation in the relevant dimensionality</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The nodwell input can usually be generated by:</span>

<span class="sd">        &gt;&gt;&gt; nodwell = ~np.isfinite(A)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nodwell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nodwell</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
        <span class="n">x</span><span class="p">[</span><span class="n">nodwell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># [Step 1] Obtain FFTs of x, the sum of squares and bins visited</span>
        <span class="n">Fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">FsumOfSquares_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">Fn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">nodwell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># [Step 2] Multiply the relevant transforms and invert to obtain the</span>
        <span class="c1"># equivalent convolutions</span>
        <span class="n">rawCorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fx</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
            <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">sums_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fx</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
            <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">sumOfSquares_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">FsumOfSquares_x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
            <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="c1"># [Step 3] Account for rounding errors.</span>
        <span class="n">rawCorr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rawCorr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sums_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sums_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sumOfSquares_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumOfSquares_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">N</span><span class="p">[</span><span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># [Step 4] Compute correlation matrix</span>
        <span class="n">mapStd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sumOfSquares_x</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mapCovar</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawCorr</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_x</span> <span class="o">*</span> <span class="n">sums_x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mapCovar</span> <span class="o">/</span> <span class="n">mapStd</span> <span class="o">/</span> <span class="n">mapStd</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">:,</span> <span class="p">:])</span>

    <span class="k">def</span> <span class="nf">crossCorr2D</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">A</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span>
        <span class="n">A_nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">B_nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs crosscorrelations between the maps in two instances of BinnedData, A and B.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A, B (BinnedData) - instance of BinnedData</span>
<span class="sd">        A_nodwell, B_nodwell (np.ndarray) - array with NaNs where there was no position sampled.</span>
<span class="sd">        tol (float) - values below this are set to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BinnedData - the data in A with the maps replaced by autocorrelograms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">CROSS_CORR</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rmap</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rmap2</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
                <span class="n">rr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crossCorr2D</span><span class="p">(</span><span class="n">rmap</span><span class="p">,</span> <span class="n">rmap2</span><span class="p">,</span> <span class="n">A_nodwell</span><span class="p">,</span> <span class="n">B_nodwell</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">binned_data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">rr</span><span class="p">]</span>
        <span class="n">xlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ylen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">xlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">ylen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ylen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_crossCorr2D</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">A</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span>
        <span class="n">A_nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">B_nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs crosscorrelations between the maps in two instances of BinnedData, A and B.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A, B (BinnedData) - instance of BinnedData</span>
<span class="sd">        A_nodwell, B_nodwell (np.ndarray) - array with NaNs where there was no position sampled.</span>
<span class="sd">        tol (float) - values below this are set to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BinnedData - the data in A with the maps replaced by autocorrelograms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">BinnedData</span><span class="p">):</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">BinnedData</span><span class="p">):</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both arrays must have the same dimensionality&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">ma</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">mb</span><span class="p">,</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">oa</span> <span class="o">=</span> <span class="n">ob</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">oa</span><span class="p">))</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">ob</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">A_nodwell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A_nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">B_nodwell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">B_nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">A_nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A_nodwell</span><span class="p">,</span> <span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">oa</span><span class="p">))</span>
        <span class="n">B_nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B_nodwell</span><span class="p">,</span> <span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">ob</span><span class="p">))</span>
        <span class="n">A</span><span class="p">[</span><span class="n">A_nodwell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">B</span><span class="p">[</span><span class="n">B_nodwell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># [Step 1] Obtain FFTs of x, the sum of squares and bins visited</span>
        <span class="n">Fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">FsumOfSquares_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">Fn_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">A_nodwell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">Fb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">na</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">FsumOfSquares_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">na</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">Fn_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">B_nodwell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">na</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># [Step 2] Multiply the relevant transforms and invert to obtain the</span>
        <span class="c1"># equivalent convolutions</span>
        <span class="n">rawCorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fb</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">sums_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">sums_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fb</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">sumOfSquares_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">FsumOfSquares_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">sumOfSquares_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">FsumOfSquares_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># [Step 3] Account for rounding errors.</span>
        <span class="n">rawCorr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rawCorr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sums_a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sums_a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sums_b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sums_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sumOfSquares_a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumOfSquares_a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sumOfSquares_b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumOfSquares_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">N</span><span class="p">[</span><span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># [Step 4] Compute correlation matrix</span>
        <span class="n">mapStd_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sumOfSquares_a</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mapStd_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sumOfSquares_b</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mapCovar</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawCorr</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_a</span> <span class="o">*</span> <span class="n">sums_b</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mapCovar</span> <span class="o">/</span> <span class="p">(</span><span class="n">mapStd_a</span> <span class="o">*</span> <span class="n">mapStd_b</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">tWinSAC</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xy</span><span class="p">,</span>
        <span class="n">spkIdx</span><span class="p">,</span>
        <span class="n">ppm</span><span class="o">=</span><span class="mi">365</span><span class="p">,</span>
        <span class="n">winSize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">pos_sample_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">nbins</span><span class="o">=</span><span class="mi">71</span><span class="p">,</span>
        <span class="n">boxcar</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">Pthresh</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">downsampfreq</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a temporal windowed spatial autocorrelation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy (array_like): The position data</span>
<span class="sd">        spkIdx (array_like): The indices in xy where the cell fired</span>
<span class="sd">        ppm (int, optional): The camera pixels per metre. Default 365</span>
<span class="sd">        winSize (int, optional): The window size for the temporal search</span>
<span class="sd">        pos_sample_rate (int, optional): The rate at which position was sampled. Default 50</span>
<span class="sd">        nbins (int, optional): The number of bins for creating the resulting ratemap. Default 71</span>
<span class="sd">        boxcar (int, optional): The size of the smoothing kernel to smooth ratemaps. Default 5</span>
<span class="sd">        Pthresh (int, optional): The cut-off for values in the ratemap; values &lt; Pthresh become nans. Default 100</span>
<span class="sd">        downsampfreq (int, optional): How much to downsample. Default 50</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H (array_like): The temporal windowed SAC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># [Stage 0] Get some numbers</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">/</span> <span class="n">ppm</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">n_samps</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n_spks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">)</span>
        <span class="n">winSizeBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">winSize</span> <span class="o">*</span> <span class="n">pos_sample_rate</span><span class="p">,</span> <span class="n">n_samps</span><span class="p">])</span>
        <span class="c1"># factor by which positions are downsampled</span>
        <span class="n">downsample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">pos_sample_rate</span> <span class="o">/</span> <span class="n">downsampfreq</span><span class="p">)</span>
        <span class="n">Pthresh</span> <span class="o">=</span> <span class="n">Pthresh</span> <span class="o">/</span> <span class="n">downsample</span>  <span class="c1"># take account of downsampling</span>

        <span class="c1"># [Stage 1] Calculate number of spikes in the window for each spikeInd</span>
        <span class="c1"># (ignoring spike itself)</span>
        <span class="c1"># 1a. Loop preparation</span>
        <span class="n">nSpikesInWin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_spks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># 1b. Keep looping until we have dealt with all spikes</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">winSizeBins</span><span class="p">))</span>
            <span class="n">nSpikesInWin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># ignore ith spike</span>

        <span class="c1"># [Stage 2] Prepare for main loop</span>
        <span class="c1"># 2a. Work out offset inidices to be used when storing spike data</span>
        <span class="n">off_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">nSpikesInWin</span><span class="p">])</span>
        <span class="n">off_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">off_spike</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># 2b. Work out number of downsampled pos bins in window and</span>
        <span class="c1"># offset indices for storing data</span>
        <span class="n">nPosInWindow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">winSizeBins</span><span class="p">,</span> <span class="n">n_samps</span> <span class="o">-</span> <span class="n">spkIdx</span><span class="p">)</span>
        <span class="n">nDownsampInWin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">nPosInWindow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">downsample</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">off_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">nDownsampInWin</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">off_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">off_dwell</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># 2c. Pre-allocate dwell and spike arrays, singles for speed</span>
        <span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">off_dwell</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">off_spike</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">filled_pvals</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">filled_svals</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spks</span><span class="p">):</span>
            <span class="c1"># calculate dwell displacements</span>
            <span class="n">winInd_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">winSizeBins</span><span class="p">,</span> <span class="n">n_samps</span><span class="p">),</span>
                <span class="n">downsample</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">WL</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">winInd_dwell</span><span class="p">)</span>
            <span class="n">dwell</span><span class="p">[:,</span> <span class="n">filled_pvals</span> <span class="p">:</span> <span class="n">filled_pvals</span> <span class="o">+</span> <span class="n">WL</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">winInd_dwell</span><span class="p">])</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[:,</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="p">)</span>
            <span class="n">filled_pvals</span> <span class="o">=</span> <span class="n">filled_pvals</span> <span class="o">+</span> <span class="n">WL</span>
            <span class="c1"># calculate spike displacements</span>
            <span class="n">winInd_spks</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">i</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">n_spks</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">winSizeBins</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">WL</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">winInd_spks</span><span class="p">)</span>
            <span class="n">spike</span><span class="p">[:,</span> <span class="n">filled_svals</span> <span class="p">:</span> <span class="n">filled_svals</span> <span class="o">+</span> <span class="n">WL</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">winInd_spks</span><span class="p">]])</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[:,</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="p">)</span>
            <span class="n">filled_svals</span> <span class="o">=</span> <span class="n">filled_svals</span> <span class="o">+</span> <span class="n">WL</span>

        <span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dwell</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">spike</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spike</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dwell</span><span class="p">,</span> <span class="o">-</span><span class="n">dwell</span><span class="p">))</span>
        <span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spike</span><span class="p">,</span> <span class="o">-</span><span class="n">spike</span><span class="p">))</span>

        <span class="n">dwell_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dwell_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">binsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">dwell_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dwell_min</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">nbins</span>

        <span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
            <span class="p">(</span><span class="n">dwell</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">dwell</span><span class="p">)</span> <span class="o">*</span> <span class="n">dwell_min</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span>
        <span class="p">)</span>
        <span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
            <span class="p">(</span><span class="n">spike</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">spike</span><span class="p">)</span> <span class="o">*</span> <span class="n">dwell_min</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span>
        <span class="p">)</span>

        <span class="n">binsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">binsize</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Hp</span><span class="p">,</span> <span class="n">Hpe_y</span><span class="p">,</span> <span class="n">Hpe_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span>
            <span class="n">dwell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dwell</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="nb">range</span><span class="o">=</span><span class="n">binedges</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binsize</span>
        <span class="p">)</span>
        <span class="n">Hs</span><span class="p">,</span> <span class="n">Hse_y</span><span class="p">,</span> <span class="n">Hse_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span>
            <span class="n">spike</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">spike</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="nb">range</span><span class="o">=</span><span class="n">binedges</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binsize</span>
        <span class="p">)</span>

        <span class="c1"># reverse y,x order</span>
        <span class="n">Hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">Hp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">Hp</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span><span class="p">,</span> <span class="p">[</span><span class="n">Hp</span><span class="p">],</span> <span class="p">[</span><span class="n">Hpe_x</span><span class="p">,</span> <span class="n">Hpe_y</span><span class="p">])</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span><span class="p">,</span> <span class="p">[</span><span class="n">Hs</span><span class="p">],</span> <span class="p">[</span><span class="n">Hse_x</span><span class="p">,</span> <span class="n">Hse_y</span><span class="p">])</span>

        <span class="c1"># smooth the maps</span>
        <span class="n">fHp</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span><span class="n">Hp</span><span class="p">,</span> <span class="n">boxcar</span><span class="p">)</span>
        <span class="n">fHs</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">boxcar</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">fHs</span> <span class="o">/</span> <span class="n">fHp</span>
        <span class="n">H</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">Hp</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Pthresh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H</span>

    <span class="k">def</span> <span class="nf">_calc_ego_angles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">arena_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;circle&quot;</span><span class="p">,</span> <span class="n">xy_binsize</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the angles between the segments of the arena wall</span>
<span class="sd">        and the positions of the animal throughout the trial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arena_shape (str) - the shape of the arena, &#39;circle&#39; or &#39;square&#39;.</span>
<span class="sd">        xy_binsize (float) - the binsize</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of np.ndarray - the angles as well as the arena x-y coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Angles are in radians.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arena_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">arena_width</span> <span class="o">=</span> <span class="n">arena_width</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">arena_centre</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">arena_width</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;circle&quot;</span> <span class="ow">in</span> <span class="n">arena_shape</span><span class="p">:</span>
            <span class="n">arena_boundary</span> <span class="o">=</span> <span class="n">arena_centre</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">arena_width</span><span class="p">)</span><span class="o">.</span><span class="n">boundary</span>
        <span class="k">elif</span> <span class="s2">&quot;square&quot;</span> <span class="ow">in</span> <span class="n">arena_shape</span><span class="p">:</span>
            <span class="n">arena_boundary</span> <span class="o">=</span> <span class="n">arena_centre</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">arena_width</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">boundary</span>
        <span class="n">arena_boundary</span> <span class="o">=</span> <span class="n">arena_boundary</span><span class="o">.</span><span class="n">segmentize</span><span class="p">(</span><span class="n">max_segment_length</span><span class="o">=</span><span class="n">xy_binsize</span><span class="p">)</span>
        <span class="n">arena_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arena_boundary</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">animal_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">animal_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arena_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">animal_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arena_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># make sure angles are in range [0-2PI]</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">animal_hd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">)</span>
        <span class="n">ego_angles</span> <span class="o">=</span> <span class="p">(</span><span class="n">angles</span> <span class="o">-</span> <span class="n">animal_hd</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># ego_angles in range [0-2PI]</span>
        <span class="c1"># and with size arena_xy_ncoords x npos</span>
        <span class="k">return</span> <span class="n">ego_angles</span><span class="p">,</span> <span class="n">arena_xy</span>

    <span class="k">def</span> <span class="nf">get_disperion_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pos_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to write a faster version of creating an overdispersion</span>
<span class="sd">        map. A cell will sometimes fire too much or too little on a given</span>
<span class="sd">        run through its receptive field. This function quantifies that.</span>

<span class="sd">        This shows the amount of &#39;observed&#39; variance in spiking around</span>
<span class="sd">        the mean spiking in a bin...</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spk_times (np.ndarray) - a vector of spike times (in seconds)</span>
<span class="sd">        pos_times (np.ndarray) - vector of position times (seconds)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BinnedData - the overdispersion map in an instance of BinnedData</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pos_times</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">spike_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_times</span><span class="p">))</span>
        <span class="n">expected_spikes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">spike_weights</span><span class="p">,</span> <span class="n">map_type</span><span class="o">=</span><span class="n">MapType</span><span class="o">.</span><span class="n">SPK</span><span class="p">)</span>
        <span class="c1"># bin_edges[1] is x, bin_edges[0] is y</span>
        <span class="n">x_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expected_spikes</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">y_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">expected_spikes</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">map_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">expected_spikes</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pos_bins_linear_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">y_bins</span><span class="p">,</span> <span class="n">x_bins</span><span class="p">],</span> <span class="n">map_shape</span><span class="p">)</span>
        <span class="n">expected_spikes_xy</span> <span class="o">=</span> <span class="n">expected_spikes</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y_bins</span><span class="p">,</span> <span class="n">x_bins</span><span class="p">]</span>
        <span class="n">min_rate_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">expected_spikes</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.25</span>
        <span class="n">x_bins_with_firing</span> <span class="o">=</span> <span class="n">x_bins</span><span class="p">[</span><span class="n">spike_weights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y_bins_with_firing</span> <span class="o">=</span> <span class="n">y_bins</span><span class="p">[</span><span class="n">spike_weights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">bins_with_firing_linear_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span>
            <span class="p">[</span><span class="n">y_bins_with_firing</span><span class="p">,</span> <span class="n">x_bins_with_firing</span><span class="p">],</span> <span class="n">map_shape</span>
        <span class="p">)</span>

        <span class="n">observed_spikes</span> <span class="o">=</span> <span class="n">expected_spikes</span>
        <span class="k">return</span> <span class="n">observed_spikes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.common.binning.RateMap.pos_weights" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">pos_weights</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>The 'weights' used as an argument to np.histogram* for binning up
position
Mostly this is just an array of 1's equal to the length of the pos
data, but usefully can be adjusted when masking data in the trial
by</p>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap._autoCorr2D" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_autoCorr2D</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">nodwell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Performs a spatial autocorrelation on the array A</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>A</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>where the two dimensions correspond to x and y.
If 3D then the first two dimensions are x
and y and the third (last dimension) is 'stack' of ratemaps</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>nodwell</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>weren't visited. See Notes below.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tol</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>thrown up by the fft. Default 1e-10</p>
              </div>
            </td>
            <td>
                  <code>1e-10</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>sac (array_like): The spatial autocorrelation in the relevant dimensionality</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Notes</summary>
  <p>The nodwell input can usually be generated by:</p>
<blockquote>
<blockquote>
<blockquote>
<p>nodwell = ~np.isfinite(A)</p>
</blockquote>
</blockquote>
</blockquote>
</details>
            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_autoCorr2D</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs a spatial autocorrelation on the array A</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A (array_like): Either 2 or 3D. In the former it is simply the binned up ratemap</span>
<span class="sd">        where the two dimensions correspond to x and y.</span>
<span class="sd">        If 3D then the first two dimensions are x</span>
<span class="sd">        and y and the third (last dimension) is &#39;stack&#39; of ratemaps</span>
<span class="sd">    nodwell (array_like): A boolean array corresponding the bins in the ratemap that</span>
<span class="sd">        weren&#39;t visited. See Notes below.</span>
<span class="sd">    tol (float, optional): Values below this are set to zero to deal with v small values</span>
<span class="sd">        thrown up by the fft. Default 1e-10</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sac (array_like): The spatial autocorrelation in the relevant dimensionality</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The nodwell input can usually be generated by:</span>

<span class="sd">    &gt;&gt;&gt; nodwell = ~np.isfinite(A)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">o</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">nodwell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nodwell</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
    <span class="n">x</span><span class="p">[</span><span class="n">nodwell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># [Step 1] Obtain FFTs of x, the sum of squares and bins visited</span>
    <span class="n">Fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">FsumOfSquares_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">Fn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">nodwell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># [Step 2] Multiply the relevant transforms and invert to obtain the</span>
    <span class="c1"># equivalent convolutions</span>
    <span class="n">rawCorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fx</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">sums_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fx</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">sumOfSquares_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">FsumOfSquares_x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="c1"># [Step 3] Account for rounding errors.</span>
    <span class="n">rawCorr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rawCorr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sums_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sums_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sumOfSquares_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumOfSquares_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">N</span><span class="p">[</span><span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># [Step 4] Compute correlation matrix</span>
    <span class="n">mapStd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sumOfSquares_x</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">mapCovar</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawCorr</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_x</span> <span class="o">*</span> <span class="n">sums_x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mapCovar</span> <span class="o">/</span> <span class="n">mapStd</span> <span class="o">/</span> <span class="n">mapStd</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">:,</span> <span class="p">:])</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap._bin_data" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_bin_data</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Bins data taking account of possible multi-dimensionality</p>
<p>Args:
    var (array_like): The variable to bin
    bin_edges (array_like): The edges of the data - see numpys histogramdd for more
    weights (array_like): The weights attributed to the samples in var</p>
<p>Returns:
    ndhist (2-tuple): Returns a two-tuple of the binned variable and
        the bin edges</p>
<p>Notes:
    This breaks compatability with numpys histogramdd
    In the 2d histogram case below I swap the axes around so that x and y
    are binned in the 'normal' format i.e. so x appears horizontally and y
    vertically.
    Multi-binning issue is dealt with awkwardly through checking
    the dimensionality of the weights array.
    'normally' this would be 1 dim but when multiple clusters are being
    binned it will be 2 dim.
    In that case np.apply_along_axis functionality is applied.
    The spike weights in that case might be created like so:</p>
<pre><code>&gt;&gt;&gt; spk_W = np.zeros(shape=[len(trial.nClusters), trial.npos])
&gt;&gt;&gt; for i, cluster in enumerate(trial.clusters):
&gt;&gt;&gt;         x1 = trial.getClusterIdx(cluster)
&gt;&gt;&gt;         spk_W[i, :] = np.bincount(x1, minlength=trial.npos)

This can then be fed into this fcn something like so:

&gt;&gt;&gt; rng = np.array((np.ma.min(
    trial.POS.xy, 1).data, np.ma.max(rial.POS.xy, 1).data))
&gt;&gt;&gt; h = _bin_data(
    var=trial.POS.xy, bin_edges=np.array([64, 64]),
    weights=spk_W, rng=rng)

Returned will be a tuple containing the binned up data and
the bin edges for x and y (obv this will be the same for all
entries of h)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_bin_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bins data taking account of possible multi-dimensionality</span>

<span class="sd">    Args:</span>
<span class="sd">        var (array_like): The variable to bin</span>
<span class="sd">        bin_edges (array_like): The edges of the data - see numpys histogramdd for more</span>
<span class="sd">        weights (array_like): The weights attributed to the samples in var</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndhist (2-tuple): Returns a two-tuple of the binned variable and</span>
<span class="sd">            the bin edges</span>

<span class="sd">    Notes:</span>
<span class="sd">        This breaks compatability with numpys histogramdd</span>
<span class="sd">        In the 2d histogram case below I swap the axes around so that x and y</span>
<span class="sd">        are binned in the &#39;normal&#39; format i.e. so x appears horizontally and y</span>
<span class="sd">        vertically.</span>
<span class="sd">        Multi-binning issue is dealt with awkwardly through checking</span>
<span class="sd">        the dimensionality of the weights array.</span>
<span class="sd">        &#39;normally&#39; this would be 1 dim but when multiple clusters are being</span>
<span class="sd">        binned it will be 2 dim.</span>
<span class="sd">        In that case np.apply_along_axis functionality is applied.</span>
<span class="sd">        The spike weights in that case might be created like so:</span>

<span class="sd">        &gt;&gt;&gt; spk_W = np.zeros(shape=[len(trial.nClusters), trial.npos])</span>
<span class="sd">        &gt;&gt;&gt; for i, cluster in enumerate(trial.clusters):</span>
<span class="sd">        &gt;&gt;&gt;		x1 = trial.getClusterIdx(cluster)</span>
<span class="sd">        &gt;&gt;&gt;		spk_W[i, :] = np.bincount(x1, minlength=trial.npos)</span>

<span class="sd">        This can then be fed into this fcn something like so:</span>

<span class="sd">        &gt;&gt;&gt; rng = np.array((np.ma.min(</span>
<span class="sd">            trial.POS.xy, 1).data, np.ma.max(rial.POS.xy, 1).data))</span>
<span class="sd">        &gt;&gt;&gt; h = _bin_data(</span>
<span class="sd">            var=trial.POS.xy, bin_edges=np.array([64, 64]),</span>
<span class="sd">            weights=spk_W, rng=rng)</span>

<span class="sd">        Returned will be a tuple containing the binned up data and</span>
<span class="sd">        the bin edges for x and y (obv this will be the same for all</span>
<span class="sd">        entries of h)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">dims</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dims</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># needed for list comp below</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">bh</span><span class="o">.</span><span class="n">Histogram</span><span class="p">(</span>
            <span class="n">bh</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">Regular</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">bh</span><span class="o">.</span><span class="n">Histogram</span><span class="p">(</span>
            <span class="n">bh</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">Regular</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">bh</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">Regular</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">)</span>
    <span class="n">ndhist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>
        <span class="n">hist</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="n">ndhist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span><span class="n">hist</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">hist</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">edges</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="n">hist</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">weights</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ndhist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ndhist</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ndhist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap._calc_bin_edges" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_calc_bin_edges</span><span class="p">(</span><span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Aims to get the right number of bins for the variable to be binned</p>
<p>Args:
    binsize (int | tuple, optional): The number of cms per bin for XY OR degrees for DIR OR cm/s for SPEED. Defaults to 3.</p>
<p>Returns:
    tuple: each member an array of bin edges</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_calc_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binsize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aims to get the right number of bins for the variable to be binned</span>

<span class="sd">    Args:</span>
<span class="sd">        binsize (int | tuple, optional): The number of cms per bin for XY OR degrees for DIR OR cm/s for SPEED. Defaults to 3.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: each member an array of bin edges</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">DIR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">360</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">maxspeed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
        <span class="c1"># assume min speed = 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxspeed</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxspeed</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">x_lims</span><span class="p">,</span> <span class="n">y_lims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getXYLimits</span><span class="p">()</span>
        <span class="n">nxbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
        <span class="n">nybins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nxbins</span><span class="p">)</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nybins</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_x</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY_TIME</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_time_splits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need pos times to bin up XY_TIME&quot;</span><span class="p">)</span>
        <span class="n">x_lims</span><span class="p">,</span> <span class="n">y_lims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getXYLimits</span><span class="p">()</span>
        <span class="n">nxbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
        <span class="n">nybins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nxbins</span><span class="p">)</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nybins</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_time_splits</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED_DIR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">maxspeed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxspeed</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxspeed</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">360</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxspeed</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxspeed</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">360</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">EGO_BOUNDARY</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">50</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bin_dims</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binedges</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap._calc_ego_angles" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_calc_ego_angles</span><span class="p">(</span><span class="n">arena_shape</span><span class="o">=</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="n">xy_binsize</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate the angles between the segments of the arena wall
and the positions of the animal throughout the trial.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>arena_shape</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>&#39;circle&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>xy_binsize</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>2.5</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple of np.ndarray - the angles as well as the arena x-y coordinates.</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Notes</summary>
  <p>Angles are in radians.</p>
</details>
            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_calc_ego_angles</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">arena_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;circle&quot;</span><span class="p">,</span> <span class="n">xy_binsize</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the angles between the segments of the arena wall</span>
<span class="sd">    and the positions of the animal throughout the trial.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arena_shape (str) - the shape of the arena, &#39;circle&#39; or &#39;square&#39;.</span>
<span class="sd">    xy_binsize (float) - the binsize</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of np.ndarray - the angles as well as the arena x-y coordinates.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Angles are in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arena_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">arena_width</span> <span class="o">=</span> <span class="n">arena_width</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">arena_centre</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">arena_width</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;circle&quot;</span> <span class="ow">in</span> <span class="n">arena_shape</span><span class="p">:</span>
        <span class="n">arena_boundary</span> <span class="o">=</span> <span class="n">arena_centre</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">arena_width</span><span class="p">)</span><span class="o">.</span><span class="n">boundary</span>
    <span class="k">elif</span> <span class="s2">&quot;square&quot;</span> <span class="ow">in</span> <span class="n">arena_shape</span><span class="p">:</span>
        <span class="n">arena_boundary</span> <span class="o">=</span> <span class="n">arena_centre</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">arena_width</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">boundary</span>
    <span class="n">arena_boundary</span> <span class="o">=</span> <span class="n">arena_boundary</span><span class="o">.</span><span class="n">segmentize</span><span class="p">(</span><span class="n">max_segment_length</span><span class="o">=</span><span class="n">xy_binsize</span><span class="p">)</span>
    <span class="n">arena_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arena_boundary</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">animal_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">animal_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arena_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">animal_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arena_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># make sure angles are in range [0-2PI]</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">animal_hd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">)</span>
    <span class="n">ego_angles</span> <span class="o">=</span> <span class="p">(</span><span class="n">angles</span> <span class="o">-</span> <span class="n">animal_hd</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># ego_angles in range [0-2PI]</span>
    <span class="c1"># and with size arena_xy_ncoords x npos</span>
    <span class="k">return</span> <span class="n">ego_angles</span><span class="p">,</span> <span class="n">arena_xy</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap._crossCorr2D" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_crossCorr2D</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">A_nodwell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">B_nodwell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Performs crosscorrelations between the maps in two instances of BinnedData, A and B.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>A</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="ephysiopy.common.utils.BinnedData" href="#ephysiopy.common.utils.BinnedData">BinnedData</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>B</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="ephysiopy.common.utils.BinnedData" href="#ephysiopy.common.utils.BinnedData">BinnedData</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>A_nodwell</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>B_nodwell</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tol</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>1e-10</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>BinnedData - the data in A with the maps replaced by autocorrelograms</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_crossCorr2D</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span>
    <span class="n">B</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span>
    <span class="n">A_nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">B_nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs crosscorrelations between the maps in two instances of BinnedData, A and B.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A, B (BinnedData) - instance of BinnedData</span>
<span class="sd">    A_nodwell, B_nodwell (np.ndarray) - array with NaNs where there was no position sampled.</span>
<span class="sd">    tol (float) - values below this are set to 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BinnedData - the data in A with the maps replaced by autocorrelograms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">BinnedData</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">BinnedData</span><span class="p">):</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both arrays must have the same dimensionality&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">ma</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">mb</span><span class="p">,</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">oa</span> <span class="o">=</span> <span class="n">ob</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">oa</span><span class="p">))</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">ob</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">A_nodwell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">A_nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">B_nodwell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">B_nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">A_nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A_nodwell</span><span class="p">,</span> <span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">oa</span><span class="p">))</span>
    <span class="n">B_nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B_nodwell</span><span class="p">,</span> <span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">ob</span><span class="p">))</span>
    <span class="n">A</span><span class="p">[</span><span class="n">A_nodwell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">B</span><span class="p">[</span><span class="n">B_nodwell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># [Step 1] Obtain FFTs of x, the sum of squares and bins visited</span>
    <span class="n">Fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">FsumOfSquares_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">Fn_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">A_nodwell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="mi">2</span> <span class="o">*</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">Fb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">na</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">FsumOfSquares_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">na</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">Fn_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">B_nodwell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="mi">2</span> <span class="o">*</span> <span class="n">na</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># [Step 2] Multiply the relevant transforms and invert to obtain the</span>
    <span class="c1"># equivalent convolutions</span>
    <span class="n">rawCorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fb</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">sums_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">sums_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fb</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">sumOfSquares_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">FsumOfSquares_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">sumOfSquares_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">FsumOfSquares_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="c1"># [Step 3] Account for rounding errors.</span>
    <span class="n">rawCorr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rawCorr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sums_a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sums_a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sums_b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sums_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sumOfSquares_a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumOfSquares_a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sumOfSquares_b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumOfSquares_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">N</span><span class="p">[</span><span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># [Step 4] Compute correlation matrix</span>
    <span class="n">mapStd_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sumOfSquares_a</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">mapStd_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sumOfSquares_b</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">mapCovar</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawCorr</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_a</span> <span class="o">*</span> <span class="n">sums_b</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mapCovar</span> <span class="o">/</span> <span class="p">(</span><span class="n">mapStd_a</span> <span class="o">*</span> <span class="n">mapStd_b</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap._getXYLimits" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_getXYLimits</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Gets the min/max of the x/y data</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_getXYLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the min/max of the x/y data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_lims</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;x_lims&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">y_lims</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;y_lims&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x_lims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x_lims</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">y_lims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y_lims</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x_lims</span> <span class="o">=</span> <span class="n">x_lims</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">y_lims</span> <span class="o">=</span> <span class="n">y_lims</span>
    <span class="k">return</span> <span class="n">x_lims</span><span class="p">,</span> <span class="n">y_lims</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap.autoCorr2D" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">autoCorr2D</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">nodwell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Performs autocorrelations on all the maps in an instance of BinnedData.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>A</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="ephysiopy.common.utils.BinnedData" href="#ephysiopy.common.utils.BinnedData">BinnedData</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>nodwell</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tol</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>1e-10</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>BinnedData - the data in A with the maps replaced by autocorrelograms</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">autoCorr2D</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span> <span class="n">nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs autocorrelations on all the maps in an instance of BinnedData.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A (BinnedData) - instance of BinnedData</span>
<span class="sd">    nodwell (np.ndarray) - array with NaNs where there was no position sampled.</span>
<span class="sd">    tol (float) - values below this are set to 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BinnedData - the data in A with the maps replaced by autocorrelograms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">AUTO_CORR</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">rmap</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">binned_data</span><span class="p">:</span>
        <span class="n">rr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoCorr2D</span><span class="p">(</span><span class="n">rmap</span><span class="p">,</span> <span class="n">nodwell</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">binned_data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">rr</span><span class="p">]</span>
    <span class="n">xlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">ylen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">result</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">xlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">ylen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ylen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap.crossCorr2D" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">crossCorr2D</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">A_nodwell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">B_nodwell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Performs crosscorrelations between the maps in two instances of BinnedData, A and B.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>A</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="ephysiopy.common.utils.BinnedData" href="#ephysiopy.common.utils.BinnedData">BinnedData</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>B</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="ephysiopy.common.utils.BinnedData" href="#ephysiopy.common.utils.BinnedData">BinnedData</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>A_nodwell</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>B_nodwell</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tol</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>1e-10</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>BinnedData - the data in A with the maps replaced by autocorrelograms</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">crossCorr2D</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span>
    <span class="n">B</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span>
    <span class="n">A_nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">B_nodwell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs crosscorrelations between the maps in two instances of BinnedData, A and B.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A, B (BinnedData) - instance of BinnedData</span>
<span class="sd">    A_nodwell, B_nodwell (np.ndarray) - array with NaNs where there was no position sampled.</span>
<span class="sd">    tol (float) - values below this are set to 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BinnedData - the data in A with the maps replaced by autocorrelograms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">CROSS_CORR</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">rmap</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rmap2</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
            <span class="n">rr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crossCorr2D</span><span class="p">(</span><span class="n">rmap</span><span class="p">,</span> <span class="n">rmap2</span><span class="p">,</span> <span class="n">A_nodwell</span><span class="p">,</span> <span class="n">B_nodwell</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">binned_data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">rr</span><span class="p">]</span>
    <span class="n">xlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ylen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">xlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">ylen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ylen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap.getAdaptiveMap" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getAdaptiveMap</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">,</span> <span class="n">spk_binned</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Produces a ratemap that has been adaptively binned according to the
algorithm described in Skaggs et al., 1996) [1]_.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>pos_binned</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>above with mapType as 'pos'</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>spk_binned</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>alpha</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>in each bin. Defaults to 4. In the original paper this was set to 200.
This is 4 here as the pos data is binned in seconds (the original data was in pos
samples so this is a factor of 50 smaller than the original paper's value, given 50Hz sample rate)</p>
              </div>
            </td>
            <td>
                  <code>4</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>Returns adaptively binned spike and pos maps. Use to generate Skaggs</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>information measure</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Notes</summary>
  <p>Positions with high rates mean proportionately less error than those
with low rates, so this tries to even the playing field. This type
of binning should be used for calculations of spatial info
as with the skaggs_info method in the fieldcalcs class (see below)
alpha is a scaling parameter that might need tweaking for different
data sets.</p>
<p>From the paper:
    The data [are] first binned
    into a 64 X 64 grid of spatial locations, and then the firing rate
    at each point in this grid was calculated by expanding a circle
    around the point until the following criterion was met:
        Nspks &gt; alpha / (Nocc^2 * r^2)
    where Nspks is the number of spikes emitted in a circle of radius
    r (in bins), Nocc is the number of occupancy samples, alpha is the
    scaling parameter
    The firing rate in the given bin is then calculated as:
        sample_rate * (Nspks / Nocc)</p>
</details>

<details class="references" open>
  <summary>References</summary>
  <p>.. [1] W. E. Skaggs, B. L. McNaughton, K. M. Gothard &amp; E. J. Markus
    "An Information-Theoretic Approach to Deciphering the Hippocampal
    Code"
    Neural Information Processing Systems, 1993.</p>
</details>
            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getAdaptiveMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_binned</span><span class="p">,</span> <span class="n">spk_binned</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produces a ratemap that has been adaptively binned according to the</span>
<span class="sd">    algorithm described in Skaggs et al., 1996) [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pos_binned (array_like): The binned positional data. For example that returned from get_map</span>
<span class="sd">        above with mapType as &#39;pos&#39;</span>
<span class="sd">    spk_binned (array_like): The binned spikes</span>
<span class="sd">    alpha (int, optional): A scaling parameter determing the amount of occupancy to aim at</span>
<span class="sd">        in each bin. Defaults to 4. In the original paper this was set to 200.</span>
<span class="sd">        This is 4 here as the pos data is binned in seconds (the original data was in pos</span>
<span class="sd">        samples so this is a factor of 50 smaller than the original paper&#39;s value, given 50Hz sample rate)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Returns adaptively binned spike and pos maps. Use to generate Skaggs</span>
<span class="sd">    information measure</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Positions with high rates mean proportionately less error than those</span>
<span class="sd">    with low rates, so this tries to even the playing field. This type</span>
<span class="sd">    of binning should be used for calculations of spatial info</span>
<span class="sd">    as with the skaggs_info method in the fieldcalcs class (see below)</span>
<span class="sd">    alpha is a scaling parameter that might need tweaking for different</span>
<span class="sd">    data sets.</span>

<span class="sd">    From the paper:</span>
<span class="sd">        The data [are] first binned</span>
<span class="sd">        into a 64 X 64 grid of spatial locations, and then the firing rate</span>
<span class="sd">        at each point in this grid was calculated by expanding a circle</span>
<span class="sd">        around the point until the following criterion was met:</span>
<span class="sd">            Nspks &gt; alpha / (Nocc^2 * r^2)</span>
<span class="sd">        where Nspks is the number of spikes emitted in a circle of radius</span>
<span class="sd">        r (in bins), Nocc is the number of occupancy samples, alpha is the</span>
<span class="sd">        scaling parameter</span>
<span class="sd">        The firing rate in the given bin is then calculated as:</span>
<span class="sd">            sample_rate * (Nspks / Nocc)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] W. E. Skaggs, B. L. McNaughton, K. M. Gothard &amp; E. J. Markus</span>
<span class="sd">        &quot;An Information-Theoretic Approach to Deciphering the Hippocampal</span>
<span class="sd">        Code&quot;</span>
<span class="sd">        Neural Information Processing Systems, 1993.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#  assign output arrays</span>
    <span class="n">smthdpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">)</span>
    <span class="n">smthdspk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">spk_binned</span><span class="p">)</span>
    <span class="n">smthdrate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">pos_binned</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">pos_binned</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">spk_binned</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">)</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">pos_binned</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># array to check which bins have made it</span>
    <span class="n">bincheck</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">bincheck</span><span class="p">):</span>
        <span class="c1"># create the filter kernel</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;=</span> <span class="n">pos_binned</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># filter the arrays using astropys convolution</span>
        <span class="n">filtpos</span> <span class="o">=</span> <span class="n">convolution</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">pos_binned</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">filtspk</span> <span class="o">=</span> <span class="n">convolution</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">spk_binned</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">filtvisited</span> <span class="o">=</span> <span class="n">convolution</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="c1"># get the bins which made it through this iteration</span>
        <span class="n">truebins</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">filtspk</span><span class="p">)</span> <span class="o">*</span> <span class="n">filtpos</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span>
        <span class="n">truebins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">truebins</span><span class="p">,</span> <span class="o">~</span><span class="n">bincheck</span><span class="p">)</span>
        <span class="c1"># insert values where true</span>
        <span class="n">smthdpos</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtpos</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">/</span> <span class="n">filtvisited</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span>
        <span class="n">smthdspk</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtspk</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">/</span> <span class="n">filtvisited</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span>
        <span class="n">bincheck</span><span class="p">[</span><span class="n">truebins</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">smthdrate</span> <span class="o">=</span> <span class="n">smthdspk</span> <span class="o">/</span> <span class="n">smthdpos</span>
    <span class="n">smthdrate</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">smthdspk</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">smthdpos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">smthdrate</span><span class="p">,</span> <span class="n">smthdspk</span><span class="p">,</span> <span class="n">smthdpos</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap.get_disperion_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_disperion_map</span><span class="p">(</span><span class="n">spk_times</span><span class="p">,</span> <span class="n">pos_times</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Attempt to write a faster version of creating an overdispersion
map. A cell will sometimes fire too much or too little on a given
run through its receptive field. This function quantifies that.</p>
<p>This shows the amount of 'observed' variance in spiking around
the mean spiking in a bin...</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spk_times</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>pos_times</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>BinnedData - the overdispersion map in an instance of BinnedData</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_disperion_map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pos_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempt to write a faster version of creating an overdispersion</span>
<span class="sd">    map. A cell will sometimes fire too much or too little on a given</span>
<span class="sd">    run through its receptive field. This function quantifies that.</span>

<span class="sd">    This shows the amount of &#39;observed&#39; variance in spiking around</span>
<span class="sd">    the mean spiking in a bin...</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spk_times (np.ndarray) - a vector of spike times (in seconds)</span>
<span class="sd">    pos_times (np.ndarray) - vector of position times (seconds)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BinnedData - the overdispersion map in an instance of BinnedData</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pos_times</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
    <span class="n">spike_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_times</span><span class="p">))</span>
    <span class="n">expected_spikes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">spike_weights</span><span class="p">,</span> <span class="n">map_type</span><span class="o">=</span><span class="n">MapType</span><span class="o">.</span><span class="n">SPK</span><span class="p">)</span>
    <span class="c1"># bin_edges[1] is x, bin_edges[0] is y</span>
    <span class="n">x_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expected_spikes</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">y_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">expected_spikes</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">map_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">expected_spikes</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">pos_bins_linear_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">y_bins</span><span class="p">,</span> <span class="n">x_bins</span><span class="p">],</span> <span class="n">map_shape</span><span class="p">)</span>
    <span class="n">expected_spikes_xy</span> <span class="o">=</span> <span class="n">expected_spikes</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y_bins</span><span class="p">,</span> <span class="n">x_bins</span><span class="p">]</span>
    <span class="n">min_rate_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">expected_spikes</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.25</span>
    <span class="n">x_bins_with_firing</span> <span class="o">=</span> <span class="n">x_bins</span><span class="p">[</span><span class="n">spike_weights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y_bins_with_firing</span> <span class="o">=</span> <span class="n">y_bins</span><span class="p">[</span><span class="n">spike_weights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">bins_with_firing_linear_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span>
        <span class="p">[</span><span class="n">y_bins_with_firing</span><span class="p">,</span> <span class="n">x_bins_with_firing</span><span class="p">],</span> <span class="n">map_shape</span>
    <span class="p">)</span>

    <span class="n">observed_spikes</span> <span class="o">=</span> <span class="n">expected_spikes</span>
    <span class="k">return</span> <span class="n">observed_spikes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap.get_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_map</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="n">var_type</span><span class="o">=</span><span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span> <span class="n">map_type</span><span class="o">=</span><span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Bins up the variable type var_type and returns a tuple of
(rmap, binnedPositionDir) or
(rmap, binnedPostionX, binnedPositionY)</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spk_weights</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>position weights. For example, if there were 5 positions
recorded and a cell spiked once in position 2 and 5 times in
position 3 and nothing anywhere else then pos_weights looks
like: [0 0 1 5 0].
spk_weights can also be list-like where each entry in the list is a different set of
weights - these are enumerated through in a list comp in the ._bin_data function. In
this case the returned tuple will consist of a 2-tuple where the first entry is an
array of the ratemaps (binned_spk / binned_pos) and the second part is the binned pos data (as it's common to all
the spike weights)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>var_type</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code><span title="ephysiopy.common.utils.VariableToBin.XY">XY</span></code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>map_type</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code><span title="ephysiopy.common.utils.MapType.RATE">RATE</span></code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>smoothing</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>binned_data (BinnedData): An instance of BinnedData containing the binned data, the bin edges, the variable binned and</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the map type. See ephysiopy.common.utils for details of the class.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">spk_weights</span><span class="p">,</span>
    <span class="n">var_type</span><span class="o">=</span><span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
    <span class="n">map_type</span><span class="o">=</span><span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span><span class="p">,</span>
    <span class="n">smoothing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bins up the variable type var_type and returns a tuple of</span>
<span class="sd">    (rmap, binnedPositionDir) or</span>
<span class="sd">    (rmap, binnedPostionX, binnedPositionY)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spk_weights (np.ndarray) - Shape equal to number of positions samples captured and consists of</span>
<span class="sd">        position weights. For example, if there were 5 positions</span>
<span class="sd">        recorded and a cell spiked once in position 2 and 5 times in</span>
<span class="sd">        position 3 and nothing anywhere else then pos_weights looks</span>
<span class="sd">        like: [0 0 1 5 0].</span>
<span class="sd">        spk_weights can also be list-like where each entry in the list is a different set of</span>
<span class="sd">        weights - these are enumerated through in a list comp in the ._bin_data function. In</span>
<span class="sd">        this case the returned tuple will consist of a 2-tuple where the first entry is an</span>
<span class="sd">        array of the ratemaps (binned_spk / binned_pos) and the second part is the binned pos data (as it&#39;s common to all</span>
<span class="sd">        the spike weights)</span>

<span class="sd">    var_type (Variable2Bin) - The variable to bin. See ephysiopy.common.utils for legal values.</span>


<span class="sd">    map_type (MapType) - The kind of map returned. See ephysiopy.common.utils for legal values.</span>

<span class="sd">    smoothing (bool, optional): Smooth the data or not. Default True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    binned_data (BinnedData): An instance of BinnedData containing the binned data, the bin edges, the variable binned and</span>
<span class="sd">                              the map type. See ephysiopy.common.utils for details of the class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="s2">&quot;extend&quot;</span>
    <span class="n">pos_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_weights</span>
    <span class="k">if</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">DIR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="s2">&quot;wrap&quot;</span>
    <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">speed</span>
    <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>
    <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY_TIME</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_times</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">SPEED_DIR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">var_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">EGO_BOUNDARY</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">arena_shape</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;arena_shape&quot;</span><span class="p">,</span> <span class="s2">&quot;circle&quot;</span><span class="p">)</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="s2">&quot;wrap&quot;</span>
        <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;binsize&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binsize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">binsize</span> <span class="o">=</span> <span class="n">binsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># breakpoint()</span>
        <span class="n">ego_angles</span><span class="p">,</span> <span class="n">arena_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_ego_angles</span><span class="p">(</span><span class="n">arena_shape</span><span class="p">,</span> <span class="n">binsize</span><span class="p">)</span>
        <span class="n">ego_dists</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">arena_xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ego_angles</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ego_dists</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span>
        <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">)</span>
        <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="n">arena_xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pos_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_weights</span><span class="p">,</span> <span class="n">arena_xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">hist_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;range&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;range&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hist_range</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized variable to bin.&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">var2Bin</span> <span class="o">=</span> <span class="n">var_type</span>
    <span class="n">binsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;binsize&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">binsize</span><span class="p">)</span>
    <span class="n">hist_range</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;range&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">hist_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bin_edges</span><span class="p">(</span><span class="n">binsize</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">binned_pos</span><span class="p">,</span> <span class="n">binned_pos_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_data</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">pos_weights</span><span class="p">)</span>
    <span class="n">binned_pos</span> <span class="o">=</span> <span class="n">binned_pos</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span>
    <span class="n">nanIdx</span> <span class="o">=</span> <span class="n">binned_pos</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">var_type</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">POS</span><span class="p">,</span> <span class="p">[</span><span class="n">binned_pos</span><span class="p">],</span> <span class="n">binned_pos_edges</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">map_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>  <span class="c1"># return binned up position</span>
        <span class="k">if</span> <span class="n">smoothing</span><span class="p">:</span>
            <span class="n">sm_pos</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span>
                <span class="n">pos</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
                <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
                <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="n">sm_pos</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">nanIdx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sm_pos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">nanIdx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pos</span>

    <span class="n">binned_spk</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_data</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">spk_weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binned_spk</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">binned_spk</span> <span class="o">=</span> <span class="p">[</span><span class="n">binned_spk</span><span class="p">]</span>
    <span class="n">spk</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">var_type</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">SPK</span><span class="p">,</span> <span class="n">binned_spk</span><span class="p">,</span> <span class="n">binned_pos_edges</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">map_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">SPK</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">smoothing</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">blur_image</span><span class="p">(</span>
                <span class="n">spk</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
                <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
                <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spk</span>
    <span class="k">if</span> <span class="n">map_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">ADAPTIVE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="c1"># deal with a stack of binned maps</span>
        <span class="k">if</span> <span class="n">binned_spk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">smthd_rate</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">binned_spk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">smthd_rate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getAdaptiveMap</span><span class="p">(</span><span class="n">binned_pos</span><span class="p">,</span> <span class="n">binned_spk</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">alpha</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">smthd_rate</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAdaptiveMap</span><span class="p">(</span><span class="n">binned_pos</span><span class="p">,</span> <span class="n">binned_spk</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">var_type</span><span class="p">,</span> <span class="n">map_type</span><span class="p">,</span> <span class="n">smthd_rate</span><span class="p">,</span> <span class="n">binned_pos_edges</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">smoothing</span><span class="p">:</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">spk</span> <span class="o">/</span> <span class="n">pos</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">map_type</span> <span class="o">=</span> <span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">nanIdx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rmap</span>

    <span class="k">if</span> <span class="s2">&quot;after&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">whenToSmooth</span><span class="p">:</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">spk</span> <span class="o">/</span> <span class="n">pos</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span>
            <span class="n">rmap</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
            <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
            <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># default case</span>
        <span class="n">sm_pos</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span>
            <span class="n">pos</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
            <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
            <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">sm_spk</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span>
            <span class="n">spk</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smooth_sz</span><span class="p">,</span>
            <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothingType</span><span class="p">,</span>
            <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">sm_spk</span> <span class="o">/</span> <span class="n">sm_pos</span>
    <span class="n">rmap</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">nanIdx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rmap</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.binning.RateMap.tWinSAC" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">tWinSAC</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">spkIdx</span><span class="p">,</span> <span class="n">ppm</span><span class="o">=</span><span class="mi">365</span><span class="p">,</span> <span class="n">winSize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pos_sample_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">71</span><span class="p">,</span> <span class="n">boxcar</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">Pthresh</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">downsampfreq</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Performs a temporal windowed spatial autocorrelation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>xy</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>spkIdx</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ppm</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>365</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>winSize</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>pos_sample_rate</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>50</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>nbins</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>71</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>boxcar</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>5</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>Pthresh</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>100</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>downsampfreq</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>50</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>H (array_like): The temporal windowed SAC</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/binning.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">tWinSAC</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">xy</span><span class="p">,</span>
    <span class="n">spkIdx</span><span class="p">,</span>
    <span class="n">ppm</span><span class="o">=</span><span class="mi">365</span><span class="p">,</span>
    <span class="n">winSize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">pos_sample_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="n">nbins</span><span class="o">=</span><span class="mi">71</span><span class="p">,</span>
    <span class="n">boxcar</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">Pthresh</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">downsampfreq</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs a temporal windowed spatial autocorrelation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xy (array_like): The position data</span>
<span class="sd">    spkIdx (array_like): The indices in xy where the cell fired</span>
<span class="sd">    ppm (int, optional): The camera pixels per metre. Default 365</span>
<span class="sd">    winSize (int, optional): The window size for the temporal search</span>
<span class="sd">    pos_sample_rate (int, optional): The rate at which position was sampled. Default 50</span>
<span class="sd">    nbins (int, optional): The number of bins for creating the resulting ratemap. Default 71</span>
<span class="sd">    boxcar (int, optional): The size of the smoothing kernel to smooth ratemaps. Default 5</span>
<span class="sd">    Pthresh (int, optional): The cut-off for values in the ratemap; values &lt; Pthresh become nans. Default 100</span>
<span class="sd">    downsampfreq (int, optional): How much to downsample. Default 50</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    H (array_like): The temporal windowed SAC</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># [Stage 0] Get some numbers</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">/</span> <span class="n">ppm</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">n_samps</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_spks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">)</span>
    <span class="n">winSizeBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">winSize</span> <span class="o">*</span> <span class="n">pos_sample_rate</span><span class="p">,</span> <span class="n">n_samps</span><span class="p">])</span>
    <span class="c1"># factor by which positions are downsampled</span>
    <span class="n">downsample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">pos_sample_rate</span> <span class="o">/</span> <span class="n">downsampfreq</span><span class="p">)</span>
    <span class="n">Pthresh</span> <span class="o">=</span> <span class="n">Pthresh</span> <span class="o">/</span> <span class="n">downsample</span>  <span class="c1"># take account of downsampling</span>

    <span class="c1"># [Stage 1] Calculate number of spikes in the window for each spikeInd</span>
    <span class="c1"># (ignoring spike itself)</span>
    <span class="c1"># 1a. Loop preparation</span>
    <span class="n">nSpikesInWin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_spks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># 1b. Keep looping until we have dealt with all spikes</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">winSizeBins</span><span class="p">))</span>
        <span class="n">nSpikesInWin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># ignore ith spike</span>

    <span class="c1"># [Stage 2] Prepare for main loop</span>
    <span class="c1"># 2a. Work out offset inidices to be used when storing spike data</span>
    <span class="n">off_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">nSpikesInWin</span><span class="p">])</span>
    <span class="n">off_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">off_spike</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># 2b. Work out number of downsampled pos bins in window and</span>
    <span class="c1"># offset indices for storing data</span>
    <span class="n">nPosInWindow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">winSizeBins</span><span class="p">,</span> <span class="n">n_samps</span> <span class="o">-</span> <span class="n">spkIdx</span><span class="p">)</span>
    <span class="n">nDownsampInWin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">nPosInWindow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">downsample</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">off_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">nDownsampInWin</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">off_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">off_dwell</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># 2c. Pre-allocate dwell and spike arrays, singles for speed</span>
    <span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">off_dwell</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">off_spike</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">filled_pvals</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">filled_svals</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spks</span><span class="p">):</span>
        <span class="c1"># calculate dwell displacements</span>
        <span class="n">winInd_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">winSizeBins</span><span class="p">,</span> <span class="n">n_samps</span><span class="p">),</span>
            <span class="n">downsample</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">WL</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">winInd_dwell</span><span class="p">)</span>
        <span class="n">dwell</span><span class="p">[:,</span> <span class="n">filled_pvals</span> <span class="p">:</span> <span class="n">filled_pvals</span> <span class="o">+</span> <span class="n">WL</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">winInd_dwell</span><span class="p">])</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[:,</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="p">)</span>
        <span class="n">filled_pvals</span> <span class="o">=</span> <span class="n">filled_pvals</span> <span class="o">+</span> <span class="n">WL</span>
        <span class="c1"># calculate spike displacements</span>
        <span class="n">winInd_spks</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">i</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">n_spks</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">winSizeBins</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">WL</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">winInd_spks</span><span class="p">)</span>
        <span class="n">spike</span><span class="p">[:,</span> <span class="n">filled_svals</span> <span class="p">:</span> <span class="n">filled_svals</span> <span class="o">+</span> <span class="n">WL</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">winInd_spks</span><span class="p">]])</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[:,</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="p">)</span>
        <span class="n">filled_svals</span> <span class="o">=</span> <span class="n">filled_svals</span> <span class="o">+</span> <span class="n">WL</span>

    <span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dwell</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">spike</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spike</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dwell</span><span class="p">,</span> <span class="o">-</span><span class="n">dwell</span><span class="p">))</span>
    <span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spike</span><span class="p">,</span> <span class="o">-</span><span class="n">spike</span><span class="p">))</span>

    <span class="n">dwell_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dwell_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">binsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">dwell_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dwell_min</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">nbins</span>

    <span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
        <span class="p">(</span><span class="n">dwell</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">dwell</span><span class="p">)</span> <span class="o">*</span> <span class="n">dwell_min</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span>
    <span class="p">)</span>
    <span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
        <span class="p">(</span><span class="n">spike</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">spike</span><span class="p">)</span> <span class="o">*</span> <span class="n">dwell_min</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span>
    <span class="p">)</span>

    <span class="n">binsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">binsize</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Hp</span><span class="p">,</span> <span class="n">Hpe_y</span><span class="p">,</span> <span class="n">Hpe_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span>
        <span class="n">dwell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dwell</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="nb">range</span><span class="o">=</span><span class="n">binedges</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binsize</span>
    <span class="p">)</span>
    <span class="n">Hs</span><span class="p">,</span> <span class="n">Hse_y</span><span class="p">,</span> <span class="n">Hse_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span>
        <span class="n">spike</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">spike</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="nb">range</span><span class="o">=</span><span class="n">binedges</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binsize</span>
    <span class="p">)</span>

    <span class="c1"># reverse y,x order</span>
    <span class="n">Hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">Hp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">Hp</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span><span class="p">,</span> <span class="p">[</span><span class="n">Hp</span><span class="p">],</span> <span class="p">[</span><span class="n">Hpe_x</span><span class="p">,</span> <span class="n">Hpe_y</span><span class="p">])</span>
    <span class="n">Hs</span> <span class="o">=</span> <span class="n">BinnedData</span><span class="p">(</span><span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span> <span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span><span class="p">,</span> <span class="p">[</span><span class="n">Hs</span><span class="p">],</span> <span class="p">[</span><span class="n">Hse_x</span><span class="p">,</span> <span class="n">Hse_y</span><span class="p">])</span>

    <span class="c1"># smooth the maps</span>
    <span class="n">fHp</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span><span class="n">Hp</span><span class="p">,</span> <span class="n">boxcar</span><span class="p">)</span>
    <span class="n">fHs</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">boxcar</span><span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">fHs</span> <span class="o">/</span> <span class="n">fHp</span>
    <span class="n">H</span><span class="o">.</span><span class="n">set_nan_indices</span><span class="p">(</span><span class="n">Hp</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Pthresh</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h2 id="field-calculations">Field calculations</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.common.fieldcalcs"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h2 id="ephysiopy.common.fieldcalcs.PROP_VALS" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">PROP_VALS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">PROPS</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>A custom class for dealing with segments of an LFP signal and how
they relate to specific runs (see RunProps below) through a 
receptive field (see FieldProps below)</p>
    </div>

</div>


<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.fieldcalcs.FieldProps" class="doc doc-heading">
            <code>FieldProps</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="skimage.measure._regionprops.RegionProperties">RegionProperties</span></code></p>







              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">FieldProps</span><span class="p">(</span><span class="n">RegionProperties</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">slice</span><span class="p">,</span>
        <span class="n">label</span><span class="p">,</span>
        <span class="n">label_image</span><span class="p">,</span>
        <span class="n">binned_data</span><span class="p">,</span>
        <span class="n">cache</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">extra_properties</span><span class="p">,</span>
        <span class="n">spacing</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">intensity_image</span> <span class="o">=</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="nb">slice</span><span class="p">,</span>
            <span class="n">label</span><span class="p">,</span>
            <span class="n">label_image</span><span class="p">,</span>
            <span class="n">intensity_image</span><span class="p">,</span>
            <span class="n">cache_active</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span>
            <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span>
            <span class="n">extra_properties</span><span class="o">=</span><span class="n">extra_properties</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span> <span class="o">=</span> <span class="n">binned_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_runs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_runs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">run_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_runs</span><span class="p">]</span>

    <span class="nd">@runs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">runs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_runs</span> <span class="o">=</span> <span class="n">r</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Field </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="si">}</span><span class="s2"> potential runs&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">run_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_image</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_require_intensity_image</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39; unavailable when `intensity_image` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;has not been specified.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_properties</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_properties</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="n">n_args</span> <span class="o">=</span> <span class="n">_infer_number_of_required_args</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="c1"># determine whether func requires intensity image</span>
            <span class="k">if</span> <span class="n">n_args</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multichannel</span><span class="p">:</span>
                        <span class="n">multichannel_list</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="p">]</span>
                        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">multichannel_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;intensity image required to calculate </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">n_args</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">func</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">xy_coords</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;intensity image required to calculate </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">n_args</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Custom regionprop function&#39;s number of arguments must &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;be 1, 2 or 3 but </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> takes </span><span class="si">{</span><span class="n">n_args</span><span class="si">}</span><span class="s2"> arguments.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">PROPS</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">attr</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_image</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">PROPS</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_require_intensity_image</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39; unavailable when `intensity_image` &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;has not been specified.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># retrieve deprecated property (excluding old CamelCase ones)</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PROPS</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Override the string representation printed to the console</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Field </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">)</span><span class="si">}</span><span class="s2"> runs&quot;</span>

    <span class="c1"># The maximum index of the intensity image for the region</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_runs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cumulative_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">cumulative_time</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runs_speed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">_speed</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runs_observed_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">observed_spikes</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">runs_expected_spikes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">expected_rate_at_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">expected_spikes</span><span class="p">(</span><span class="n">expected_rate_at_pos</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spike_position_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">spike_position_index</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="c1"># The x-y coordinate at the field peak</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy_at_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_index</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">mi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># The x-y coordinates zeroed with respect to the peak</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy_relative_to_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy_coords</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_at_peak</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># The angle each x-y coordinate makes to the field peak</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy_angle_to_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">xy_to_peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_relative_to_peak</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xy_to_peak</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy_to_peak</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># The distance of each x-y coordinate to the field peak</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy_dist_to_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">xy_to_peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_relative_to_peak</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xy_to_peak</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy_to_peak</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># The perimeter of the masked region as an array of bool</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bw_perim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bwperim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">perimeter_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bw_perim</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">global_perimeter_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">perim_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perimeter_coords</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">perim_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">perim_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">perimeter_minus_field_max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_index</span>
        <span class="n">perimeter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perimeter_coords</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">perimeter_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">perimeter_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mi</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="c1"># The angle each point on the perimeter makes to the field peak</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">perimeter_angle_from_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">perimeter_minus_field_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perimeter_minus_field_max</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">perimeter_minus_field_max</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">perimeter_minus_field_max</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># The distance of each point on the perimeter to the field peak</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">perimeter_dist_from_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">perimeter_minus_field_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perimeter_minus_field_max</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">perimeter_minus_field_max</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">perimeter_minus_field_max</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="o">.</span><span class="n">bin_edges</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]]</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the angular distance between the mean direction of each run and</span>
<span class="sd">        each position samples direction to the field centre</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">phi</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">rho</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">pos_xy</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the angular distance between the mean direction of each run and</span>
<span class="sd">        each position samples direction to the field centre</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">pos_phi</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_r</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the ratio of the distance from the field peak to the position sample</span>
<span class="sd">        and the distance from the field peak to the point on the perimeter that is most</span>
<span class="sd">        colinear with the position sample</span>

<span class="sd">        NB The values just before being returned can be &gt;= 1 so these are capped to 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">pos_r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r_and_phi_to_x_and_y</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">pol2cart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_phi</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">r_per_run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">perimeter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perimeter_coords</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">run</span><span class="o">.</span><span class="n">r</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xy_at_peak</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">perimeter_angle_from_peak</span><span class="p">,</span>
                    <span class="n">perimeter_coords</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_index</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">current_direction</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cumulative_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">cumulative_distance</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">projected_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        direction projected onto the mean run direction is just the x-coord</span>
<span class="sd">        when cartesian x and y is converted to from polar rho and phi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">pos_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">overdispersion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">spike_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">overdispersion</span><span class="p">(</span><span class="n">spike_train</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">])</span>

    <span class="c1"># Over-ride the next intensity_* functions so they use the</span>
    <span class="c1"># nan versions</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intensity_max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intensity_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intensity_min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intensity_std</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_intensity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">smooth_runs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">spatial_lp_cut</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth in x and y in preparation for converting the smoothed cartesian</span>
<span class="sd">        coordinates to polar ones</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k (float) - smoothing constant for the instantaneous firing rate</span>
<span class="sd">        spatial_lp_cut (int) - spatial lowpass cut off</span>
<span class="sd">        sample_rate (int) - position sample rate in Hz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">smooth_xy</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">spatial_lp_cut</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.common.fieldcalcs.FieldProps.phi" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">phi</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate the angular distance between the mean direction of each run and
each position samples direction to the field centre</p>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.common.fieldcalcs.FieldProps.pos_phi" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">pos_phi</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate the angular distance between the mean direction of each run and
each position samples direction to the field centre</p>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.common.fieldcalcs.FieldProps.pos_r" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">pos_r</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate the ratio of the distance from the field peak to the position sample
and the distance from the field peak to the point on the perimeter that is most
colinear with the position sample</p>
<p>NB The values just before being returned can be &gt;= 1 so these are capped to 1</p>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.common.fieldcalcs.FieldProps.projected_direction" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">projected_direction</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>direction projected onto the mean run direction is just the x-coord
when cartesian x and y is converted to from polar rho and phi</p>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.fieldcalcs.FieldProps.__str__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__str__</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Override the string representation printed to the console</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Override the string representation printed to the console</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Field </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">)</span><span class="si">}</span><span class="s2"> runs&quot;</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.fieldcalcs.FieldProps.smooth_runs" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">smooth_runs</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">spatial_lp_cut</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Smooth in x and y in preparation for converting the smoothed cartesian
coordinates to polar ones</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>k</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>spatial_lp_cut</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sample_rate</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">smooth_runs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">spatial_lp_cut</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth in x and y in preparation for converting the smoothed cartesian</span>
<span class="sd">    coordinates to polar ones</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k (float) - smoothing constant for the instantaneous firing rate</span>
<span class="sd">    spatial_lp_cut (int) - spatial lowpass cut off</span>
<span class="sd">    sample_rate (int) - position sample rate in Hz</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">smooth_xy</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">spatial_lp_cut</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.fieldcalcs.RunProps" class="doc doc-heading">
            <code>RunProps</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>







              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">RunProps</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">label</span><span class="p">,</span>
        <span class="nb">slice</span><span class="p">,</span>
        <span class="n">xy_coords</span><span class="p">,</span>
        <span class="n">spike_count</span><span class="p">,</span>
        <span class="n">speed</span><span class="p">,</span>
        <span class="n">peak_xy</span><span class="p">,</span>
        <span class="n">max_index</span><span class="p">,</span>
        <span class="n">perimeter_coords</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">assert</span> <span class="n">xy_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xy_coords</span> <span class="o">=</span> <span class="n">xy_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="o">=</span> <span class="nb">slice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spike_count</span> <span class="o">=</span> <span class="n">spike_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_speed</span> <span class="o">=</span> <span class="n">speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peak_xy</span> <span class="o">=</span> <span class="n">peak_xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_index</span> <span class="o">=</span> <span class="n">max_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter_coords</span> <span class="o">=</span> <span class="n">perimeter_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_is_smoothed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;id: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spike_count</span><span class="p">)</span><span class="si">}</span><span class="s2"> spikes&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy_coords</span>

    <span class="nd">@xy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xy_coords</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hdir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_speed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_speed</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">start</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cumulative_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">start</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spike_count</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">run_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">start</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">run_stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">stop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mean_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">circmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdir</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdir</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cumulative_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spike_position_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">stop</span><span class="p">),</span> <span class="n">repeat_ind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spike_count</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">observed_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spike_count</span>

    <span class="k">def</span> <span class="nf">expected_spikes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">expected_rate_at_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expected_rate_at_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">/</span> <span class="n">sample_rate</span>

    <span class="k">def</span> <span class="nf">overdispersion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spike_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">obs_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spike_count</span><span class="p">)</span>
        <span class="n">expt_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spike_train</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">])</span> <span class="o">/</span> <span class="n">sample_rate</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">obs_spikes</span> <span class="o">&gt;=</span> <span class="n">expt_spikes</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="p">(</span><span class="n">obs_spikes</span> <span class="o">-</span> <span class="n">expt_spikes</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">expt_spikes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="p">(</span><span class="n">obs_spikes</span> <span class="o">-</span> <span class="n">expt_spikes</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">expt_spikes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z</span>

    <span class="k">def</span> <span class="nf">smooth_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">spatial_lp_cut</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth in x and y in preparation for converting the smoothed cartesian</span>
<span class="sd">        coordinates to polar ones</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k (float) - smoothing constant for the instantaneous firing rate</span>
<span class="sd">        spatial_lp_cut (int) - spatial lowpass cut off</span>
<span class="sd">        sample_rate (int) - position sample rate in Hz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">run_stop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">f_len</span><span class="p">),</span>
            <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">cutoff</span><span class="o">=</span><span class="n">spatial_lp_cut</span> <span class="o">/</span> <span class="n">sample_rate</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="s2">&quot;blackman&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">padlen</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">padlen</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">padlen</span> <span class="o">=</span> <span class="n">padlen</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">padlen</span><span class="o">=</span><span class="n">padlen</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_is_smoothed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy_angle_to_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">xy_to_peak</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peak_xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xy_to_peak</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy_to_peak</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy_dist_to_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">xy_to_peak</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peak_xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xy_to_peak</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy_to_peak</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy_dist_to_peak_normed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_and_phi_to_x_and_y</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">perimeter_minus_field_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_index</span>
        <span class="n">perimeter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter_coords</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">perimeter_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">perimeter_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">perimeter_angle_from_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">perimeter_minus_field_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perimeter_minus_field_max</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">perimeter_minus_field_max</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">perimeter_minus_field_max</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span> <span class="o">=</span> <span class="n">pol2cart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">angle_df</span> <span class="o">=</span> <span class="n">circ_abs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">perimeter_angle_from_peak</span><span class="p">()[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_angle_to_peak</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">)</span>
        <span class="n">perimeter_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">angle_df</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">perimeter_idx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">perimeter_idx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">perimeter_dist_to_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_dist_to_peak</span> <span class="o">/</span> <span class="n">perimeter_dist_to_peak</span>
        <span class="n">capped_vals</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="n">r</span><span class="p">[</span><span class="n">capped_vals</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="c1"># calculate the angular distance between the runs main direction and the</span>
    <span class="c1"># pos&#39;s direction to the peak centre</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_angle_to_peak</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_direction</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rho</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cart2pol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">rho</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2pol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">phi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r_and_phi_to_x_and_y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">pol2cart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">))</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a measure of tortuosity to see how direct the run was</span>
<span class="sd">    from field entry to exit. It&#39;s jsut the ratio of the distance between</span>
<span class="sd">    a straight line joining the entry-exit points and the actual distance</span>
<span class="sd">    of the run</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tortuosity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">direct_line_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">xy_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span>
        <span class="n">traversed_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xy_df</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy_df</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">direct_line_distance</span> <span class="o">/</span> <span class="n">traversed_distance</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.fieldcalcs.RunProps.smooth_xy" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">smooth_xy</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">spatial_lp_cut</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Smooth in x and y in preparation for converting the smoothed cartesian
coordinates to polar ones</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>k</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>spatial_lp_cut</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sample_rate</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">smooth_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">spatial_lp_cut</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth in x and y in preparation for converting the smoothed cartesian</span>
<span class="sd">    coordinates to polar ones</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k (float) - smoothing constant for the instantaneous firing rate</span>
<span class="sd">    spatial_lp_cut (int) - spatial lowpass cut off</span>
<span class="sd">    sample_rate (int) - position sample rate in Hz</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">run_stop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">f_len</span><span class="p">),</span>
        <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="o">=</span><span class="n">spatial_lp_cut</span> <span class="o">/</span> <span class="n">sample_rate</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="s2">&quot;blackman&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">padlen</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">padlen</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">padlen</span> <span class="o">=</span> <span class="n">padlen</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">padlen</span><span class="o">=</span><span class="n">padlen</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">xy_is_smoothed</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs._get_field_labels" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_get_field_labels</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns a labeled version of A after finding the peaks
in A and finding the watershed basins from the markers
found from those peaks. Used in field_props() and
grid_field_props()</p>
<p>Args:
    A (np.ndarray): The array to process
    min_distance (float, optional): The distance in bins between fields to
    separate the regions of the image
    clear_border (bool, optional): Input to skimage.feature.peak_local_max.
    The number of
        pixels to ignore at the edge of the image</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1520</span>
<span class="normal">1521</span>
<span class="normal">1522</span>
<span class="normal">1523</span>
<span class="normal">1524</span>
<span class="normal">1525</span>
<span class="normal">1526</span>
<span class="normal">1527</span>
<span class="normal">1528</span>
<span class="normal">1529</span>
<span class="normal">1530</span>
<span class="normal">1531</span>
<span class="normal">1532</span>
<span class="normal">1533</span>
<span class="normal">1534</span>
<span class="normal">1535</span>
<span class="normal">1536</span>
<span class="normal">1537</span>
<span class="normal">1538</span>
<span class="normal">1539</span>
<span class="normal">1540</span>
<span class="normal">1541</span>
<span class="normal">1542</span>
<span class="normal">1543</span>
<span class="normal">1544</span>
<span class="normal">1545</span>
<span class="normal">1546</span>
<span class="normal">1547</span>
<span class="normal">1548</span>
<span class="normal">1549</span>
<span class="normal">1550</span>
<span class="normal">1551</span>
<span class="normal">1552</span>
<span class="normal">1553</span>
<span class="normal">1554</span>
<span class="normal">1555</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_get_field_labels</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a labeled version of A after finding the peaks</span>
<span class="sd">    in A and finding the watershed basins from the markers</span>
<span class="sd">    found from those peaks. Used in field_props() and</span>
<span class="sd">    grid_field_props()</span>

<span class="sd">    Args:</span>
<span class="sd">        A (np.ndarray): The array to process</span>
<span class="sd">        min_distance (float, optional): The distance in bins between fields to</span>
<span class="sd">        separate the regions of the image</span>
<span class="sd">        clear_border (bool, optional): Input to skimage.feature.peak_local_max.</span>
<span class="sd">        The number of</span>
<span class="sd">            pixels to ignore at the edge of the image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">clear_border</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="s2">&quot;clear_border&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">clear_border</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;clear_border&quot;</span><span class="p">)</span>

    <span class="n">min_distance</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="s2">&quot;min_distance&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">min_distance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;min_distance&quot;</span><span class="p">)</span>

    <span class="n">A</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">A</span><span class="p">[</span><span class="n">A</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">Ac_r</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">peak_coords</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span>
        <span class="n">Ac_r</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_distance</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="n">clear_border</span>
    <span class="p">)</span>
    <span class="n">peaksMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">peaksMask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">peak_coords</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">peaksLabel</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peaksMask</span><span class="p">)</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="n">peaksLabel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">peak_coords</span><span class="p">,</span> <span class="n">ws</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.border_score" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">border_score</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="n">fieldThresh</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">circumPrc</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">binSize</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">minArea</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates a border score totally dis-similar to that calculated in
Solstad et al (2008)</p>
<p>Args:
    A (array_like): Should be the ratemap
    B (array_like): This should be a boolean mask where True (1)
        is equivalent to the presence of a border and False (0)
        is equivalent to 'open space'. Naievely this will be the
        edges of the ratemap but could be used to take account of
        boundary insertions/ creations to check tuning to multiple
        environmental boundaries. Default None: when the mask is
        None then a mask is created that has 1's at the edges of the
        ratemap i.e. it is assumed that occupancy = environmental
        shape
    shape (str): description of environment shape. Currently
        only 'square' or 'circle' accepted. Used to calculate the
        proportion of the environmental boundaries to examine for
        firing
    fieldThresh (float): Between 0 and 1 this is the percentage
        amount of the maximum firing rate
        to remove from the ratemap (i.e. to remove noise)
    smthKernSig (float): the sigma value used in smoothing the ratemap
        (again!) with a gaussian kernel
    circumPrc (float): The percentage amount of the circumference
        of the environment that the field needs to be to count
        as long enough to make it through
    binSize (float): bin size in cm
    minArea (float): min area for a field to be considered
    debug (bool): If True then some plots and text will be output</p>
<p>Returns:
    float: the border score</p>
<p>Notes:
    If the cell is a border cell (BVC) then we know that it should
    fire at a fixed distance from a given boundary (possibly more
    than one). In essence this algorithm estimates the amount of
    variance in this distance i.e. if the cell is a border cell this
    number should be small. This is achieved by first doing a bunch of
    morphological operations to isolate individual fields in the
    ratemap (similar to the code used in phasePrecession.py - see
    the partitionFields method therein). These partitioned fields are then
    thinned out (using skimage's skeletonize) to a single pixel
    wide field which will lie more or less in the middle of the
    (highly smoothed) sub-field. It is the variance in distance from the
    nearest boundary along this pseudo-iso-line that is the boundary
    measure</p>
<pre><code>Other things to note are that the pixel-wide field has to have some
minimum length. In the case of a circular environment this is set to
20% of the circumference; in the case of a square environment markers
this is at least half the length of the longest side
</code></pre>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span>
<span class="normal">1506</span>
<span class="normal">1507</span>
<span class="normal">1508</span>
<span class="normal">1509</span>
<span class="normal">1510</span>
<span class="normal">1511</span>
<span class="normal">1512</span>
<span class="normal">1513</span>
<span class="normal">1514</span>
<span class="normal">1515</span>
<span class="normal">1516</span>
<span class="normal">1517</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">border_score</span><span class="p">(</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span>
    <span class="n">fieldThresh</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">circumPrc</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">binSize</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
    <span class="n">minArea</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculates a border score totally dis-similar to that calculated in</span>
<span class="sd">    Solstad et al (2008)</span>

<span class="sd">    Args:</span>
<span class="sd">        A (array_like): Should be the ratemap</span>
<span class="sd">        B (array_like): This should be a boolean mask where True (1)</span>
<span class="sd">            is equivalent to the presence of a border and False (0)</span>
<span class="sd">            is equivalent to &#39;open space&#39;. Naievely this will be the</span>
<span class="sd">            edges of the ratemap but could be used to take account of</span>
<span class="sd">            boundary insertions/ creations to check tuning to multiple</span>
<span class="sd">            environmental boundaries. Default None: when the mask is</span>
<span class="sd">            None then a mask is created that has 1&#39;s at the edges of the</span>
<span class="sd">            ratemap i.e. it is assumed that occupancy = environmental</span>
<span class="sd">            shape</span>
<span class="sd">        shape (str): description of environment shape. Currently</span>
<span class="sd">            only &#39;square&#39; or &#39;circle&#39; accepted. Used to calculate the</span>
<span class="sd">            proportion of the environmental boundaries to examine for</span>
<span class="sd">            firing</span>
<span class="sd">        fieldThresh (float): Between 0 and 1 this is the percentage</span>
<span class="sd">            amount of the maximum firing rate</span>
<span class="sd">            to remove from the ratemap (i.e. to remove noise)</span>
<span class="sd">        smthKernSig (float): the sigma value used in smoothing the ratemap</span>
<span class="sd">            (again!) with a gaussian kernel</span>
<span class="sd">        circumPrc (float): The percentage amount of the circumference</span>
<span class="sd">            of the environment that the field needs to be to count</span>
<span class="sd">            as long enough to make it through</span>
<span class="sd">        binSize (float): bin size in cm</span>
<span class="sd">        minArea (float): min area for a field to be considered</span>
<span class="sd">        debug (bool): If True then some plots and text will be output</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: the border score</span>

<span class="sd">    Notes:</span>
<span class="sd">        If the cell is a border cell (BVC) then we know that it should</span>
<span class="sd">        fire at a fixed distance from a given boundary (possibly more</span>
<span class="sd">        than one). In essence this algorithm estimates the amount of</span>
<span class="sd">        variance in this distance i.e. if the cell is a border cell this</span>
<span class="sd">        number should be small. This is achieved by first doing a bunch of</span>
<span class="sd">        morphological operations to isolate individual fields in the</span>
<span class="sd">        ratemap (similar to the code used in phasePrecession.py - see</span>
<span class="sd">        the partitionFields method therein). These partitioned fields are then</span>
<span class="sd">        thinned out (using skimage&#39;s skeletonize) to a single pixel</span>
<span class="sd">        wide field which will lie more or less in the middle of the</span>
<span class="sd">        (highly smoothed) sub-field. It is the variance in distance from the</span>
<span class="sd">        nearest boundary along this pseudo-iso-line that is the boundary</span>
<span class="sd">        measure</span>

<span class="sd">        Other things to note are that the pixel-wide field has to have some</span>
<span class="sd">        minimum length. In the case of a circular environment this is set to</span>
<span class="sd">        20% of the circumference; in the case of a square environment markers</span>
<span class="sd">        this is at least half the length of the longest side</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># need to know borders of the environment so we can see if a field</span>
    <span class="c1"># touches the edges, and the perimeter length of the environment</span>
    <span class="c1"># deal with square or circles differently</span>
    <span class="n">borderMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">A_rows</span><span class="p">,</span> <span class="n">A_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;circle&quot;</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">dist_mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">disk</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dist_mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
            <span class="n">dist_mask</span> <span class="o">=</span> <span class="n">dist_mask</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">A_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">A_cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">A_rows</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">A_cols</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_mask</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">distance_transform_bf</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">borderMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">dists</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dists</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># open up the border mask a little</span>
        <span class="n">borderMask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span>
            <span class="n">borderMask</span><span class="p">,</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">disk</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;square&quot;</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">borderMask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">borderMask</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">borderMask</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">borderMask</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">A_rows</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">A_cols</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">dist_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_mask</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">distance_transform_bf</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="c1"># remove edges to make same shape as input ratemap</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">A</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># get some morphological info about the fields in the ratemap</span>
    <span class="c1"># start image processing:</span>
    <span class="c1"># get some markers</span>
    <span class="c1"># NB I&#39;ve tried a variety of techniques to optimise this part and the</span>
    <span class="c1"># best seems to be the local adaptive thresholding technique which)</span>
    <span class="c1"># smooths locally with a gaussian - see the skimage docs for more</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">A</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">*</span> <span class="n">fieldThresh</span>
    <span class="n">A_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">A_thresh</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="c1"># label these markers so each blob has a unique id</span>
    <span class="n">labels</span><span class="p">,</span> <span class="n">nFields</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">A_thresh</span><span class="p">)</span>
    <span class="c1"># remove small objects</span>
    <span class="n">min_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">minArea</span> <span class="o">/</span> <span class="n">binSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">relabel_sequential</span><span class="p">(</span><span class="n">labels</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nFields</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Iterate over the labelled parts of the array labels calculating</span>
    <span class="c1"># how much of the total circumference of the environment edge it</span>
    <span class="c1"># covers</span>

    <span class="n">fieldAngularCoverage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">nFields</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">fractionOfPixelsOnBorder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">nFields</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">fieldsToKeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nFields</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">fieldMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="n">borderMask</span><span class="p">)</span>

        <span class="c1"># check the angle subtended by the fieldMask</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">fieldMask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span>
                <span class="n">fieldMask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">A_thresh</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">A_cols</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">A_rows</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="n">subtended_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">subtended_angle</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="n">circumPrc</span><span class="p">):</span>
                <span class="n">pixelsOnBorder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">fieldMask</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">fractionOfPixelsOnBorder</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixelsOnBorder</span>
                <span class="k">if</span> <span class="n">pixelsOnBorder</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">fieldAngularCoverage</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">subtended_angle</span>

            <span class="n">fieldsToKeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">fieldsToKeep</span><span class="p">,</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1"># Check the fields are big enough to qualify (minArea)</span>
    <span class="c1"># returning nan if not</span>
    <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="n">field_sizes</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">labeled_comprehension</span><span class="p">(</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nFields</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">fn</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="mi">0</span>
    <span class="p">)</span>
    <span class="n">field_sizes</span> <span class="o">/=</span> <span class="n">binSize</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">field_sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">minArea</span> <span class="o">/</span> <span class="n">binSize</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;No fields bigger than the minimum size of </span><span class="si">{</span><span class="n">minArea</span><span class="o">/</span><span class="n">binSize</span><span class="si">}</span><span class="s2"> (minArea/binSize) could be found&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">fieldAngularCoverage</span> <span class="o">=</span> <span class="n">fieldAngularCoverage</span> <span class="o">/</span> <span class="mf">360.0</span>
    <span class="n">rateInField</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">fieldsToKeep</span><span class="p">]</span>
    <span class="c1"># normalize firing rate in the field to sum to 1</span>
    <span class="n">rateInField</span> <span class="o">=</span> <span class="n">rateInField</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">rateInField</span><span class="p">)</span>
    <span class="n">dist2WallInField</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">fieldsToKeep</span><span class="p">]</span>
    <span class="n">Dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dist2WallInField</span><span class="p">,</span> <span class="n">rateInField</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;circle&quot;</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">Dm</span> <span class="o">=</span> <span class="n">Dm</span> <span class="o">/</span> <span class="n">radius</span>
    <span class="k">elif</span> <span class="s2">&quot;square&quot;</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">Dm</span> <span class="o">=</span> <span class="n">Dm</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">borderScore</span> <span class="o">=</span> <span class="p">(</span><span class="n">fractionOfPixelsOnBorder</span> <span class="o">-</span> <span class="n">Dm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fractionOfPixelsOnBorder</span> <span class="o">+</span> <span class="n">Dm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">borderScore</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.calc_angs" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">calc_angs</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates the angles for all triangles in a delaunay tesselation of
the peak points in the ratemap</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1702</span>
<span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span>
<span class="normal">1708</span>
<span class="normal">1709</span>
<span class="normal">1710</span>
<span class="normal">1711</span>
<span class="normal">1712</span>
<span class="normal">1713</span>
<span class="normal">1714</span>
<span class="normal">1715</span>
<span class="normal">1716</span>
<span class="normal">1717</span>
<span class="normal">1718</span>
<span class="normal">1719</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">calc_angs</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the angles for all triangles in a delaunay tesselation of</span>
<span class="sd">    the peak points in the ratemap</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate the lengths of the sides of the triangles</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">angs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">tri</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">tri</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">tri</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">B</span><span class="p">),</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="o">-</span><span class="n">C</span><span class="p">),</span> <span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="p">)):</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
            <span class="n">angs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.coherence" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">coherence</span><span class="p">(</span><span class="n">smthd_rate</span><span class="p">,</span> <span class="n">unsmthd_rate</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>calculates coherence of receptive field via correlation of smoothed
and unsmoothed ratemaps</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1761</span>
<span class="normal">1762</span>
<span class="normal">1763</span>
<span class="normal">1764</span>
<span class="normal">1765</span>
<span class="normal">1766</span>
<span class="normal">1767</span>
<span class="normal">1768</span>
<span class="normal">1769</span>
<span class="normal">1770</span>
<span class="normal">1771</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">coherence</span><span class="p">(</span><span class="n">smthd_rate</span><span class="p">,</span> <span class="n">unsmthd_rate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;calculates coherence of receptive field via correlation of smoothed</span>
<span class="sd">    and unsmoothed ratemaps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smthd</span> <span class="o">=</span> <span class="n">smthd_rate</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">unsmthd</span> <span class="o">=</span> <span class="n">unsmthd_rate</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">si</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">smthd</span><span class="p">)</span>
    <span class="n">ui</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unsmthd</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="n">si</span> <span class="o">|</span> <span class="o">~</span><span class="n">ui</span><span class="p">)</span>
    <span class="n">coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">unsmthd</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">smthd</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">coherence</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.deform_SAC" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">deform_SAC</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">circleXY</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ellipseXY</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Deforms a SAC that is non-circular to be more circular</p>
<p>Basically a blatant attempt to improve grid scores, possibly
introduced in a paper by Matt Nolan...</p>
<p>Args:
    A (array_like): The SAC
    circleXY (array_like, optional): The xy coordinates defining a circle.
    Default None.
    ellipseXY (array_like, optional): The xy coordinates defining an
    ellipse. Default None.</p>
<p>Returns:
    deformed_sac (array_like): The SAC deformed to be more circular</p>
<p>See Also:
    ephysiopy.common.ephys_generic.FieldCalcs.grid_field_props
    skimage.transform.AffineTransform
    skimage.transform.warp
    skimage.exposure.rescale_intensity</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2216</span>
<span class="normal">2217</span>
<span class="normal">2218</span>
<span class="normal">2219</span>
<span class="normal">2220</span>
<span class="normal">2221</span>
<span class="normal">2222</span>
<span class="normal">2223</span>
<span class="normal">2224</span>
<span class="normal">2225</span>
<span class="normal">2226</span>
<span class="normal">2227</span>
<span class="normal">2228</span>
<span class="normal">2229</span>
<span class="normal">2230</span>
<span class="normal">2231</span>
<span class="normal">2232</span>
<span class="normal">2233</span>
<span class="normal">2234</span>
<span class="normal">2235</span>
<span class="normal">2236</span>
<span class="normal">2237</span>
<span class="normal">2238</span>
<span class="normal">2239</span>
<span class="normal">2240</span>
<span class="normal">2241</span>
<span class="normal">2242</span>
<span class="normal">2243</span>
<span class="normal">2244</span>
<span class="normal">2245</span>
<span class="normal">2246</span>
<span class="normal">2247</span>
<span class="normal">2248</span>
<span class="normal">2249</span>
<span class="normal">2250</span>
<span class="normal">2251</span>
<span class="normal">2252</span>
<span class="normal">2253</span>
<span class="normal">2254</span>
<span class="normal">2255</span>
<span class="normal">2256</span>
<span class="normal">2257</span>
<span class="normal">2258</span>
<span class="normal">2259</span>
<span class="normal">2260</span>
<span class="normal">2261</span>
<span class="normal">2262</span>
<span class="normal">2263</span>
<span class="normal">2264</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">deform_SAC</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">circleXY</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ellipseXY</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deforms a SAC that is non-circular to be more circular</span>

<span class="sd">    Basically a blatant attempt to improve grid scores, possibly</span>
<span class="sd">    introduced in a paper by Matt Nolan...</span>

<span class="sd">    Args:</span>
<span class="sd">        A (array_like): The SAC</span>
<span class="sd">        circleXY (array_like, optional): The xy coordinates defining a circle.</span>
<span class="sd">        Default None.</span>
<span class="sd">        ellipseXY (array_like, optional): The xy coordinates defining an</span>
<span class="sd">        ellipse. Default None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        deformed_sac (array_like): The SAC deformed to be more circular</span>

<span class="sd">    See Also:</span>
<span class="sd">        ephysiopy.common.ephys_generic.FieldCalcs.grid_field_props</span>
<span class="sd">        skimage.transform.AffineTransform</span>
<span class="sd">        skimage.transform.warp</span>
<span class="sd">        skimage.exposure.rescale_intensity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">circleXY</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ellipseXY</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">SAC_stats</span> <span class="o">=</span> <span class="n">grid_field_props</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">circleXY</span> <span class="o">=</span> <span class="n">SAC_stats</span><span class="p">[</span><span class="s2">&quot;circleXY&quot;</span><span class="p">]</span>
        <span class="n">ellipseXY</span> <span class="o">=</span> <span class="n">SAC_stats</span><span class="p">[</span><span class="s2">&quot;ellipseXY&quot;</span><span class="p">]</span>
        <span class="c1"># The ellipse detection stuff might have failed, if so</span>
        <span class="c1"># return the original SAC</span>
        <span class="k">if</span> <span class="n">circleXY</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Ellipse detection failed. Returning original SAC&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">A</span>

    <span class="n">tform</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">AffineTransform</span><span class="p">()</span>
    <span class="n">tform</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">ellipseXY</span><span class="p">,</span> <span class="n">circleXY</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    the transformation algorithms used here crop values &lt; 0 to 0. Need to</span>
<span class="sd">    rescale the SAC values before doing the deformation and then rescale</span>
<span class="sd">    again so the values assume the same range as in the unadulterated SAC</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">SACmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="n">SACmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>  <span class="c1"># should be 1 if autocorr</span>
    <span class="n">AA</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">deformedSAC</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span>
        <span class="n">AA</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">AA</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">skimage</span><span class="o">.</span><span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">deformedSAC</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="n">SACmin</span><span class="p">,</span> <span class="n">SACmax</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.field_lims" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">field_lims</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns a labelled matrix of the ratemap A.
Uses anything greater than the half peak rate to select as a field.
Data is heavily smoothed.</p>
<p>Args:
    A (BinnedData): A BinnedData instance containing the ratemap</p>
<p>Returns:
    label (np.array): The labelled ratemap</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">field_lims</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a labelled matrix of the ratemap A.</span>
<span class="sd">    Uses anything greater than the half peak rate to select as a field.</span>
<span class="sd">    Data is heavily smoothed.</span>

<span class="sd">    Args:</span>
<span class="sd">        A (BinnedData): A BinnedData instance containing the ratemap</span>

<span class="sd">    Returns:</span>
<span class="sd">        label (np.array): The labelled ratemap</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nan_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Ac</span><span class="p">)</span>
    <span class="n">Ac</span><span class="p">[</span><span class="n">nan_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">sm_rmap</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sm_rmap</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">*</span> <span class="mf">0.2</span>  <span class="c1"># select area &gt; 20% of peak</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">sm_rmap</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span>
    <span class="n">peak_idx</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">sm_rmap</span> <span class="o">&gt;</span> <span class="n">thresh</span>
    <span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">peak_idx</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=-</span><span class="n">distance</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">sm_rmap</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">label</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.field_props" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">field_props</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">neighbours</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tri</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns a dictionary of properties of the field(s) in a ratemap A</p>
<p>Args:
    A (array_like): a ratemap (but could be any image)
    min_dist (float): the separation (in bins) between fields for measures
        such as field distance to make sense. Used to
        partition the image into separate fields in the call to
        feature.peak_local_max
    neighbours (int): the number of fields to consider as neighbours to
        any given field. Defaults to 2
    prc (float): percent of fields to consider
    ax (matplotlib.Axes): user supplied axis. If None a new figure window
    is created
    tri (bool): whether to do Delaunay triangulation between fields
        and add to plot
    verbose (bool): dumps the properties to the console
    plot (bool): whether to plot some output - currently consists of the
        ratemap A, the fields of which are outline in a black
        contour. Default False</p>
<p>Returns:
    result (dict): The properties of the field(s) in the input ratemap A</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1558</span>
<span class="normal">1559</span>
<span class="normal">1560</span>
<span class="normal">1561</span>
<span class="normal">1562</span>
<span class="normal">1563</span>
<span class="normal">1564</span>
<span class="normal">1565</span>
<span class="normal">1566</span>
<span class="normal">1567</span>
<span class="normal">1568</span>
<span class="normal">1569</span>
<span class="normal">1570</span>
<span class="normal">1571</span>
<span class="normal">1572</span>
<span class="normal">1573</span>
<span class="normal">1574</span>
<span class="normal">1575</span>
<span class="normal">1576</span>
<span class="normal">1577</span>
<span class="normal">1578</span>
<span class="normal">1579</span>
<span class="normal">1580</span>
<span class="normal">1581</span>
<span class="normal">1582</span>
<span class="normal">1583</span>
<span class="normal">1584</span>
<span class="normal">1585</span>
<span class="normal">1586</span>
<span class="normal">1587</span>
<span class="normal">1588</span>
<span class="normal">1589</span>
<span class="normal">1590</span>
<span class="normal">1591</span>
<span class="normal">1592</span>
<span class="normal">1593</span>
<span class="normal">1594</span>
<span class="normal">1595</span>
<span class="normal">1596</span>
<span class="normal">1597</span>
<span class="normal">1598</span>
<span class="normal">1599</span>
<span class="normal">1600</span>
<span class="normal">1601</span>
<span class="normal">1602</span>
<span class="normal">1603</span>
<span class="normal">1604</span>
<span class="normal">1605</span>
<span class="normal">1606</span>
<span class="normal">1607</span>
<span class="normal">1608</span>
<span class="normal">1609</span>
<span class="normal">1610</span>
<span class="normal">1611</span>
<span class="normal">1612</span>
<span class="normal">1613</span>
<span class="normal">1614</span>
<span class="normal">1615</span>
<span class="normal">1616</span>
<span class="normal">1617</span>
<span class="normal">1618</span>
<span class="normal">1619</span>
<span class="normal">1620</span>
<span class="normal">1621</span>
<span class="normal">1622</span>
<span class="normal">1623</span>
<span class="normal">1624</span>
<span class="normal">1625</span>
<span class="normal">1626</span>
<span class="normal">1627</span>
<span class="normal">1628</span>
<span class="normal">1629</span>
<span class="normal">1630</span>
<span class="normal">1631</span>
<span class="normal">1632</span>
<span class="normal">1633</span>
<span class="normal">1634</span>
<span class="normal">1635</span>
<span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span>
<span class="normal">1642</span>
<span class="normal">1643</span>
<span class="normal">1644</span>
<span class="normal">1645</span>
<span class="normal">1646</span>
<span class="normal">1647</span>
<span class="normal">1648</span>
<span class="normal">1649</span>
<span class="normal">1650</span>
<span class="normal">1651</span>
<span class="normal">1652</span>
<span class="normal">1653</span>
<span class="normal">1654</span>
<span class="normal">1655</span>
<span class="normal">1656</span>
<span class="normal">1657</span>
<span class="normal">1658</span>
<span class="normal">1659</span>
<span class="normal">1660</span>
<span class="normal">1661</span>
<span class="normal">1662</span>
<span class="normal">1663</span>
<span class="normal">1664</span>
<span class="normal">1665</span>
<span class="normal">1666</span>
<span class="normal">1667</span>
<span class="normal">1668</span>
<span class="normal">1669</span>
<span class="normal">1670</span>
<span class="normal">1671</span>
<span class="normal">1672</span>
<span class="normal">1673</span>
<span class="normal">1674</span>
<span class="normal">1675</span>
<span class="normal">1676</span>
<span class="normal">1677</span>
<span class="normal">1678</span>
<span class="normal">1679</span>
<span class="normal">1680</span>
<span class="normal">1681</span>
<span class="normal">1682</span>
<span class="normal">1683</span>
<span class="normal">1684</span>
<span class="normal">1685</span>
<span class="normal">1686</span>
<span class="normal">1687</span>
<span class="normal">1688</span>
<span class="normal">1689</span>
<span class="normal">1690</span>
<span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">field_props</span><span class="p">(</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">neighbours</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">tri</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a dictionary of properties of the field(s) in a ratemap A</span>

<span class="sd">    Args:</span>
<span class="sd">        A (array_like): a ratemap (but could be any image)</span>
<span class="sd">        min_dist (float): the separation (in bins) between fields for measures</span>
<span class="sd">            such as field distance to make sense. Used to</span>
<span class="sd">            partition the image into separate fields in the call to</span>
<span class="sd">            feature.peak_local_max</span>
<span class="sd">        neighbours (int): the number of fields to consider as neighbours to</span>
<span class="sd">            any given field. Defaults to 2</span>
<span class="sd">        prc (float): percent of fields to consider</span>
<span class="sd">        ax (matplotlib.Axes): user supplied axis. If None a new figure window</span>
<span class="sd">        is created</span>
<span class="sd">        tri (bool): whether to do Delaunay triangulation between fields</span>
<span class="sd">            and add to plot</span>
<span class="sd">        verbose (bool): dumps the properties to the console</span>
<span class="sd">        plot (bool): whether to plot some output - currently consists of the</span>
<span class="sd">            ratemap A, the fields of which are outline in a black</span>
<span class="sd">            contour. Default False</span>

<span class="sd">    Returns:</span>
<span class="sd">        result (dict): The properties of the field(s) in the input ratemap A</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">find_contours</span>
    <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>

    <span class="n">nan_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># smooth Ac more to remove local irregularities</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span> <span class="p">:</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Ac</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>

    <span class="n">peak_idx</span><span class="p">,</span> <span class="n">field_labels</span> <span class="o">=</span> <span class="n">_get_field_labels</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">field_labels</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">neighbours</span> <span class="o">&gt;</span> <span class="n">nFields</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;neighbours value of </span><span class="si">{0}</span><span class="s2"> &gt; the </span><span class="si">{1}</span><span class="s2"> peaks found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">neighbours</span><span class="p">,</span> <span class="n">nFields</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reducing neighbours to number of peaks found&quot;</span><span class="p">)</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="n">nFields</span>
    <span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nFields</span><span class="p">,</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">sub_field_props</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">field_labels</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">Ac</span><span class="p">)</span>
    <span class="n">sub_field_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sub_field_size</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">sub_field</span> <span class="ow">in</span> <span class="n">sub_field_props</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">tmp2</span> <span class="o">=</span> <span class="n">Ac</span> <span class="o">&gt;</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">max_intensity</span> <span class="o">*</span> <span class="p">(</span><span class="n">prc</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">sub_field_mask</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
        <span class="n">sub_field_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
        <span class="n">sub_field_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>  <span class="c1"># in bins</span>
    <span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">contours</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">find_contours</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="c1"># find the nearest neighbors to the peaks of each sub-field</span>
    <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">neighbours</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;ball_tree&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">)</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">)</span>
    <span class="n">mean_field_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">neighbours</span><span class="p">])</span>

    <span class="n">nValid_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">nan_idx</span><span class="p">)</span>
    <span class="c1"># calculate the amount of out of field firing</span>
    <span class="n">A_non_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">A_non_field</span><span class="p">[</span><span class="o">~</span><span class="n">sub_field_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">~</span><span class="n">sub_field_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>
    <span class="n">A_non_field</span><span class="p">[</span><span class="n">nan_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">out_of_field_firing_prc</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">A_non_field</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nValid_bins</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># get some stats about the field ellipticity</span>
    <span class="n">ellipse_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">central_field</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">limit_to_one</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

    <span class="n">contour_coords</span> <span class="o">=</span> <span class="n">find_contours</span><span class="p">(</span><span class="n">central_field</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">EllipseModel</span>

    <span class="n">E</span> <span class="o">=</span> <span class="n">EllipseModel</span><span class="p">()</span>
    <span class="n">E</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">contour_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ellipse_axes</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">ellipse_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ellipse_axes</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ellipse_axes</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot; using the peak_idx values calculate the angles of the triangles that</span>
<span class="sd">    make up a delaunay tesselation of the space if the calc_angles arg is</span>
<span class="sd">    in kwargs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;calc_angs&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">angs</span> <span class="o">=</span> <span class="n">calc_angs</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">angs</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">props</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Ac&quot;</span><span class="p">:</span> <span class="n">Ac</span><span class="p">,</span>
        <span class="s2">&quot;Peak_rate&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">A</span><span class="p">),</span>
        <span class="s2">&quot;Mean_rate&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">A</span><span class="p">),</span>
        <span class="s2">&quot;Field_size&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sub_field_size</span><span class="p">),</span>
        <span class="s2">&quot;Pct_bins_with_firing&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">nValid_bins</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;Out_of_field_firing_prc&quot;</span><span class="p">:</span> <span class="n">out_of_field_firing_prc</span><span class="p">,</span>
        <span class="s2">&quot;Dist_between_fields&quot;</span><span class="p">:</span> <span class="n">mean_field_distance</span><span class="p">,</span>
        <span class="s2">&quot;Num_fields&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">nFields</span><span class="p">),</span>
        <span class="s2">&quot;Sub_field_mask&quot;</span><span class="p">:</span> <span class="n">sub_field_mask</span><span class="p">,</span>
        <span class="s2">&quot;Smoothed_map&quot;</span><span class="p">:</span> <span class="n">Ac</span><span class="p">,</span>
        <span class="s2">&quot;field_labels&quot;</span><span class="p">:</span> <span class="n">field_labels</span><span class="p">,</span>
        <span class="s2">&quot;Peak_idx&quot;</span><span class="p">:</span> <span class="n">peak_idx</span><span class="p">,</span>
        <span class="s2">&quot;angles&quot;</span><span class="p">:</span> <span class="n">angs</span><span class="p">,</span>
        <span class="s2">&quot;contours&quot;</span><span class="p">:</span> <span class="n">contours</span><span class="p">,</span>
        <span class="s2">&quot;ellipse_ratio&quot;</span><span class="p">:</span> <span class="n">ellipse_ratio</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Percentage of bins with firing: </span><span class="si">{:.2%}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">nValid_bins</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Percentage out of field firing: </span><span class="si">{:.2%}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">A_non_field</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nValid_bins</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Peak firing rate: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="si">}</span><span class="s2"> Hz&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean firing rate: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="si">}</span><span class="s2"> Hz&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of fields: </span><span class="si">{</span><span class="n">nFields</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean field size: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sub_field_size</span><span class="p">)</span><span class="si">}</span><span class="s2"> cm&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean inter-peak distance between fields: </span><span class="si">{</span><span class="n">mean_field_distance</span><span class="si">}</span><span class="s2"> cm&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">props</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.fieldprops" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">fieldprops</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span> <span class="n">binned_data</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">spikes_per_pos</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">extra_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Measure properties of labeled image regions.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>label_image</code>
            </td>
            <td>
                  <code>(M, N[, P]) ndarray</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Labeled input image. Labels with value 0 are ignored.</p>
<p>.. versionchanged:: 0.14.1
    Previously, <code>label_image</code> was processed by <code>numpy.squeeze</code> and
    so any number of singleton dimensions was allowed. This resulted in
    inconsistent handling of images with singleton dimensions. To
    recover the old behaviour, use
    <code>regionprops(np.squeeze(label_image), ...)</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>xy</code>
            </td>
            <td>
                  <code>(2 x N) ndarray</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The x-y coordinates for all runs through the field corresponding to
a particular label</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>binned_data</code>
            </td>
            <td>
                  <code>BinnedData instance from ephysiopy.common.utils</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>cache</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Determine whether to cache calculated properties. The computation is
much faster for cached properties, whereas the memory consumption
increases.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>extra_properties</code>
            </td>
            <td>
                  <code>Iterable of callables</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Add extra property computation functions that are not included with
skimage. The name of the property is derived from the function name,
the dtype is inferred by calling the function on a small sample.
If the name of an extra property clashes with the name of an existing
property the extra property will not be visible and a UserWarning is
issued. A property computation function must take a region mask as its
first argument. If the property requires an intensity image, it must
accept the intensity image as the second argument.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>spacing</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The pixel spacing along each axis of the image.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>offset</code>
            </td>
            <td>
                  <code>array-like of int, shape `(label_image.ndim,)`</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Coordinates of the origin ("top-left" corner) of the label image.
Normally this is ([0, ]0, 0), but it might be different if one wants
to obtain regionprops of subvolumes within a larger volume.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>properties</code></td>            <td>
                  <code>list of RegionProperties</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Each item describes one labeled region, and can be accessed using the
attributes listed below.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Notes</summary>
  <p>The following properties can be accessed as attributes or keys:</p>
<p><strong>area</strong> : float
    Area of the region i.e. number of pixels of the region scaled by pixel-area.
<strong>area_bbox</strong> : float
    Area of the bounding box i.e. number of pixels of bounding box scaled by pixel-area.
<strong>area_convex</strong> : float
    Area of the convex hull image, which is the smallest convex
    polygon that encloses the region.
<strong>area_filled</strong> : float
    Area of the region with all the holes filled in.
<strong>axis_major_length</strong> : float
    The length of the major axis of the ellipse that has the same
    normalized second central moments as the region.
<strong>axis_minor_length</strong> : float
    The length of the minor axis of the ellipse that has the same
    normalized second central moments as the region.
<strong>bbox</strong> : tuple
    Bounding box <code>(min_row, min_col, max_row, max_col)</code>.
    Pixels belonging to the bounding box are in the half-open interval
    <code>[min_row; max_row)</code> and <code>[min_col; max_col)</code>.
<strong>centroid</strong> : array
    Centroid coordinate tuple <code>(row, col)</code>.
<strong>centroid_local</strong> : array
    Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding
    box.
<strong>centroid_weighted</strong> : array
    Centroid coordinate tuple <code>(row, col)</code> weighted with intensity
    image.
<strong>centroid_weighted_local</strong> : array
    Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding
    box, weighted with intensity image.
<strong>coords_scaled</strong> : (K, 2) ndarray
    Coordinate list <code>(row, col)</code> of the region scaled by <code>spacing</code>.
<strong>coords</strong> : (K, 2) ndarray
    Coordinate list <code>(row, col)</code> of the region.
<strong>eccentricity</strong> : float
    Eccentricity of the ellipse that has the same second-moments as the
    region. The eccentricity is the ratio of the focal distance
    (distance between focal points) over the major axis length.
    The value is in the interval [0, 1).
    When it is 0, the ellipse becomes a circle.
<strong>equivalent_diameter_area</strong> : float
    The diameter of a circle with the same area as the region.
<strong>euler_number</strong> : int
    Euler characteristic of the set of non-zero pixels.
    Computed as number of connected components subtracted by number of
    holes (input.ndim connectivity). In 3D, number of connected
    components plus number of holes subtracted by number of tunnels.
<strong>extent</strong> : float
    Ratio of pixels in the region to pixels in the total bounding box.
    Computed as <code>area / (rows * cols)</code>
<strong>feret_diameter_max</strong> : float
    Maximum Feret's diameter computed as the longest distance between
    points around a region's convex hull contour as determined by
    <code>find_contours</code>. [5]_
<strong>image</strong> : (H, J) ndarray
    Sliced binary region image which has the same size as bounding box.
<strong>image_convex</strong> : (H, J) ndarray
    Binary convex hull image which has the same size as bounding box.
<strong>image_filled</strong> : (H, J) ndarray
    Binary region image with filled holes which has the same size as
    bounding box.
<strong>image_intensity</strong> : ndarray
    Image inside region bounding box.
<strong>inertia_tensor</strong> : ndarray
    Inertia tensor of the region for the rotation around its mass.
<strong>inertia_tensor_eigvals</strong> : tuple
    The eigenvalues of the inertia tensor in decreasing order.
<strong>intensity_max</strong> : float
    Value with the greatest intensity in the region.
<strong>intensity_mean</strong> : float
    Value with the mean intensity in the region.
<strong>intensity_min</strong> : float
    Value with the least intensity in the region.
<strong>intensity_std</strong> : float
    Standard deviation of the intensity in the region.
<strong>label</strong> : int
    The label in the labeled input image.
<strong>moments</strong> : (3, 3) ndarray
    Spatial moments up to 3rd order::</p>
<pre><code>    m_ij = sum{ array(row, col) * row^i * col^j }

where the sum is over the `row`, `col` coordinates of the region.
</code></pre>
<p><strong>moments_central</strong> : (3, 3) ndarray
    Central moments (translation invariant) up to 3rd order::</p>
<pre><code>    mu_ij = sum{ array(row, col) * (row - row_c)^i * (col - col_c)^j }

where the sum is over the `row`, `col` coordinates of the region,
and `row_c` and `col_c` are the coordinates of the region's centroid.
</code></pre>
<p><strong>moments_hu</strong> : tuple
    Hu moments (translation, scale and rotation invariant).
<strong>moments_normalized</strong> : (3, 3) ndarray
    Normalized moments (translation and scale invariant) up to 3rd order::</p>
<pre><code>    nu_ij = mu_ij / m_00^[(i+j)/2 + 1]

where `m_00` is the zeroth spatial moment.
</code></pre>
<p><strong>moments_weighted</strong> : (3, 3) ndarray
    Spatial moments of intensity image up to 3rd order::</p>
<pre><code>    wm_ij = sum{ array(row, col) * row^i * col^j }

where the sum is over the `row`, `col` coordinates of the region.
</code></pre>
<p><strong>moments_weighted_central</strong> : (3, 3) ndarray
    Central moments (translation invariant) of intensity image up to
    3rd order::</p>
<pre><code>    wmu_ij = sum{ array(row, col) * (row - row_c)^i * (col - col_c)^j }

where the sum is over the `row`, `col` coordinates of the region,
and `row_c` and `col_c` are the coordinates of the region's weighted
centroid.
</code></pre>
<p><strong>moments_weighted_hu</strong> : tuple
    Hu moments (translation, scale and rotation invariant) of intensity
    image.
<strong>moments_weighted_normalized</strong> : (3, 3) ndarray
    Normalized moments (translation and scale invariant) of intensity
    image up to 3rd order::</p>
<pre><code>    wnu_ij = wmu_ij / wm_00^[(i+j)/2 + 1]

where ``wm_00`` is the zeroth spatial moment (intensity-weighted area).
</code></pre>
<p><strong>num_pixels</strong> : int
    Number of foreground pixels.
<strong>orientation</strong> : float
    Angle between the 0th axis (rows) and the major
    axis of the ellipse that has the same second moments as the region,
    ranging from <code>-pi/2</code> to <code>pi/2</code> counter-clockwise.
<strong>perimeter</strong> : float
    Perimeter of object which approximates the contour as a line
    through the centers of border pixels using a 4-connectivity.
<strong>perimeter_crofton</strong> : float
    Perimeter of object approximated by the Crofton formula in 4
    directions.
<strong>slice</strong> : tuple of slices
    A slice to extract the object from the source image.
<strong>solidity</strong> : float
    Ratio of pixels in the region to pixels of the convex hull image.</p>
<p>Each region also supports iteration, so that you can do::</p>
<p>for prop in region:
      print(prop, region[prop])</p>
</details>

<details class="see-also" open>
  <summary>See Also</summary>
  <p>label</p>
</details>

<details class="references" open>
  <summary>References</summary>
  <p>.. [1] Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
       Core Algorithms. Springer-Verlag, London, 2009.
.. [2] B. Jhne. Digital Image Processing. Springer-Verlag,
       Berlin-Heidelberg, 6. edition, 2005.
.. [3] T. H. Reiss. Recognizing Planar Objects Using Invariant Image
       Features, from Lecture notes in computer science, p. 676. Springer,
       Berlin, 1993.
.. [4] https://en.wikipedia.org/wiki/Image_moment
.. [5] W. Pabst, E. Gregorov. Characterization of particles and particle
       systems, pp. 27-28. ICT Prague, 2007.
       https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf</p>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;centroid&#39;</span><span class="p">]</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
</code></pre></div>
    <p>Add custom measurements by passing functions as <code>extra_properties</code></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pixelcount</span><span class="p">(</span><span class="n">regionmask</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regionmask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">,</span> <span class="n">extra_properties</span><span class="o">=</span><span class="p">(</span><span class="n">pixelcount</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelcount</span>
<span class="go">7741</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;pixelcount&#39;</span><span class="p">]</span>
<span class="go">42</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span>
<span class="normal">944</span>
<span class="normal">945</span>
<span class="normal">946</span>
<span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span>
<span class="normal">957</span>
<span class="normal">958</span>
<span class="normal">959</span>
<span class="normal">960</span>
<span class="normal">961</span>
<span class="normal">962</span>
<span class="normal">963</span>
<span class="normal">964</span>
<span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span>
<span class="normal">968</span>
<span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span>
<span class="normal">983</span>
<span class="normal">984</span>
<span class="normal">985</span>
<span class="normal">986</span>
<span class="normal">987</span>
<span class="normal">988</span>
<span class="normal">989</span>
<span class="normal">990</span>
<span class="normal">991</span>
<span class="normal">992</span>
<span class="normal">993</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">fieldprops</span><span class="p">(</span>
    <span class="n">label_image</span><span class="p">,</span>
    <span class="n">binned_data</span><span class="p">,</span>
    <span class="n">xy</span><span class="p">,</span>
    <span class="n">spikes_per_pos</span><span class="p">,</span>
    <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">extra_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Measure properties of labeled image regions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    label_image : (M, N[, P]) ndarray</span>
<span class="sd">        Labeled input image. Labels with value 0 are ignored.</span>

<span class="sd">        .. versionchanged:: 0.14.1</span>
<span class="sd">            Previously, ``label_image`` was processed by ``numpy.squeeze`` and</span>
<span class="sd">            so any number of singleton dimensions was allowed. This resulted in</span>
<span class="sd">            inconsistent handling of images with singleton dimensions. To</span>
<span class="sd">            recover the old behaviour, use</span>
<span class="sd">            ``regionprops(np.squeeze(label_image), ...)``.</span>
<span class="sd">    xy : (2 x N) ndarray</span>
<span class="sd">        The x-y coordinates for all runs through the field corresponding to</span>
<span class="sd">        a particular label</span>
<span class="sd">    binned_data : BinnedData instance from ephysiopy.common.utils</span>
<span class="sd">    cache : bool, optional</span>
<span class="sd">        Determine whether to cache calculated properties. The computation is</span>
<span class="sd">        much faster for cached properties, whereas the memory consumption</span>
<span class="sd">        increases.</span>
<span class="sd">    extra_properties : Iterable of callables</span>
<span class="sd">        Add extra property computation functions that are not included with</span>
<span class="sd">        skimage. The name of the property is derived from the function name,</span>
<span class="sd">        the dtype is inferred by calling the function on a small sample.</span>
<span class="sd">        If the name of an extra property clashes with the name of an existing</span>
<span class="sd">        property the extra property will not be visible and a UserWarning is</span>
<span class="sd">        issued. A property computation function must take a region mask as its</span>
<span class="sd">        first argument. If the property requires an intensity image, it must</span>
<span class="sd">        accept the intensity image as the second argument.</span>
<span class="sd">    spacing: tuple of float, shape (ndim,)</span>
<span class="sd">        The pixel spacing along each axis of the image.</span>
<span class="sd">    offset : array-like of int, shape `(label_image.ndim,)`, optional</span>
<span class="sd">        Coordinates of the origin (&quot;top-left&quot; corner) of the label image.</span>
<span class="sd">        Normally this is ([0, ]0, 0), but it might be different if one wants</span>
<span class="sd">        to obtain regionprops of subvolumes within a larger volume.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    properties : list of RegionProperties</span>
<span class="sd">        Each item describes one labeled region, and can be accessed using the</span>
<span class="sd">        attributes listed below.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following properties can be accessed as attributes or keys:</span>

<span class="sd">    **area** : float</span>
<span class="sd">        Area of the region i.e. number of pixels of the region scaled by pixel-area.</span>
<span class="sd">    **area_bbox** : float</span>
<span class="sd">        Area of the bounding box i.e. number of pixels of bounding box scaled by pixel-area.</span>
<span class="sd">    **area_convex** : float</span>
<span class="sd">        Area of the convex hull image, which is the smallest convex</span>
<span class="sd">        polygon that encloses the region.</span>
<span class="sd">    **area_filled** : float</span>
<span class="sd">        Area of the region with all the holes filled in.</span>
<span class="sd">    **axis_major_length** : float</span>
<span class="sd">        The length of the major axis of the ellipse that has the same</span>
<span class="sd">        normalized second central moments as the region.</span>
<span class="sd">    **axis_minor_length** : float</span>
<span class="sd">        The length of the minor axis of the ellipse that has the same</span>
<span class="sd">        normalized second central moments as the region.</span>
<span class="sd">    **bbox** : tuple</span>
<span class="sd">        Bounding box ``(min_row, min_col, max_row, max_col)``.</span>
<span class="sd">        Pixels belonging to the bounding box are in the half-open interval</span>
<span class="sd">        ``[min_row; max_row)`` and ``[min_col; max_col)``.</span>
<span class="sd">    **centroid** : array</span>
<span class="sd">        Centroid coordinate tuple ``(row, col)``.</span>
<span class="sd">    **centroid_local** : array</span>
<span class="sd">        Centroid coordinate tuple ``(row, col)``, relative to region bounding</span>
<span class="sd">        box.</span>
<span class="sd">    **centroid_weighted** : array</span>
<span class="sd">        Centroid coordinate tuple ``(row, col)`` weighted with intensity</span>
<span class="sd">        image.</span>
<span class="sd">    **centroid_weighted_local** : array</span>
<span class="sd">        Centroid coordinate tuple ``(row, col)``, relative to region bounding</span>
<span class="sd">        box, weighted with intensity image.</span>
<span class="sd">    **coords_scaled** : (K, 2) ndarray</span>
<span class="sd">        Coordinate list ``(row, col)`` of the region scaled by ``spacing``.</span>
<span class="sd">    **coords** : (K, 2) ndarray</span>
<span class="sd">        Coordinate list ``(row, col)`` of the region.</span>
<span class="sd">    **eccentricity** : float</span>
<span class="sd">        Eccentricity of the ellipse that has the same second-moments as the</span>
<span class="sd">        region. The eccentricity is the ratio of the focal distance</span>
<span class="sd">        (distance between focal points) over the major axis length.</span>
<span class="sd">        The value is in the interval [0, 1).</span>
<span class="sd">        When it is 0, the ellipse becomes a circle.</span>
<span class="sd">    **equivalent_diameter_area** : float</span>
<span class="sd">        The diameter of a circle with the same area as the region.</span>
<span class="sd">    **euler_number** : int</span>
<span class="sd">        Euler characteristic of the set of non-zero pixels.</span>
<span class="sd">        Computed as number of connected components subtracted by number of</span>
<span class="sd">        holes (input.ndim connectivity). In 3D, number of connected</span>
<span class="sd">        components plus number of holes subtracted by number of tunnels.</span>
<span class="sd">    **extent** : float</span>
<span class="sd">        Ratio of pixels in the region to pixels in the total bounding box.</span>
<span class="sd">        Computed as ``area / (rows * cols)``</span>
<span class="sd">    **feret_diameter_max** : float</span>
<span class="sd">        Maximum Feret&#39;s diameter computed as the longest distance between</span>
<span class="sd">        points around a region&#39;s convex hull contour as determined by</span>
<span class="sd">        ``find_contours``. [5]_</span>
<span class="sd">    **image** : (H, J) ndarray</span>
<span class="sd">        Sliced binary region image which has the same size as bounding box.</span>
<span class="sd">    **image_convex** : (H, J) ndarray</span>
<span class="sd">        Binary convex hull image which has the same size as bounding box.</span>
<span class="sd">    **image_filled** : (H, J) ndarray</span>
<span class="sd">        Binary region image with filled holes which has the same size as</span>
<span class="sd">        bounding box.</span>
<span class="sd">    **image_intensity** : ndarray</span>
<span class="sd">        Image inside region bounding box.</span>
<span class="sd">    **inertia_tensor** : ndarray</span>
<span class="sd">        Inertia tensor of the region for the rotation around its mass.</span>
<span class="sd">    **inertia_tensor_eigvals** : tuple</span>
<span class="sd">        The eigenvalues of the inertia tensor in decreasing order.</span>
<span class="sd">    **intensity_max** : float</span>
<span class="sd">        Value with the greatest intensity in the region.</span>
<span class="sd">    **intensity_mean** : float</span>
<span class="sd">        Value with the mean intensity in the region.</span>
<span class="sd">    **intensity_min** : float</span>
<span class="sd">        Value with the least intensity in the region.</span>
<span class="sd">    **intensity_std** : float</span>
<span class="sd">        Standard deviation of the intensity in the region.</span>
<span class="sd">    **label** : int</span>
<span class="sd">        The label in the labeled input image.</span>
<span class="sd">    **moments** : (3, 3) ndarray</span>
<span class="sd">        Spatial moments up to 3rd order::</span>

<span class="sd">            m_ij = sum{ array(row, col) * row^i * col^j }</span>

<span class="sd">        where the sum is over the `row`, `col` coordinates of the region.</span>
<span class="sd">    **moments_central** : (3, 3) ndarray</span>
<span class="sd">        Central moments (translation invariant) up to 3rd order::</span>

<span class="sd">            mu_ij = sum{ array(row, col) * (row - row_c)^i * (col - col_c)^j }</span>

<span class="sd">        where the sum is over the `row`, `col` coordinates of the region,</span>
<span class="sd">        and `row_c` and `col_c` are the coordinates of the region&#39;s centroid.</span>
<span class="sd">    **moments_hu** : tuple</span>
<span class="sd">        Hu moments (translation, scale and rotation invariant).</span>
<span class="sd">    **moments_normalized** : (3, 3) ndarray</span>
<span class="sd">        Normalized moments (translation and scale invariant) up to 3rd order::</span>

<span class="sd">            nu_ij = mu_ij / m_00^[(i+j)/2 + 1]</span>

<span class="sd">        where `m_00` is the zeroth spatial moment.</span>
<span class="sd">    **moments_weighted** : (3, 3) ndarray</span>
<span class="sd">        Spatial moments of intensity image up to 3rd order::</span>

<span class="sd">            wm_ij = sum{ array(row, col) * row^i * col^j }</span>

<span class="sd">        where the sum is over the `row`, `col` coordinates of the region.</span>
<span class="sd">    **moments_weighted_central** : (3, 3) ndarray</span>
<span class="sd">        Central moments (translation invariant) of intensity image up to</span>
<span class="sd">        3rd order::</span>

<span class="sd">            wmu_ij = sum{ array(row, col) * (row - row_c)^i * (col - col_c)^j }</span>

<span class="sd">        where the sum is over the `row`, `col` coordinates of the region,</span>
<span class="sd">        and `row_c` and `col_c` are the coordinates of the region&#39;s weighted</span>
<span class="sd">        centroid.</span>
<span class="sd">    **moments_weighted_hu** : tuple</span>
<span class="sd">        Hu moments (translation, scale and rotation invariant) of intensity</span>
<span class="sd">        image.</span>
<span class="sd">    **moments_weighted_normalized** : (3, 3) ndarray</span>
<span class="sd">        Normalized moments (translation and scale invariant) of intensity</span>
<span class="sd">        image up to 3rd order::</span>

<span class="sd">            wnu_ij = wmu_ij / wm_00^[(i+j)/2 + 1]</span>

<span class="sd">        where ``wm_00`` is the zeroth spatial moment (intensity-weighted area).</span>
<span class="sd">    **num_pixels** : int</span>
<span class="sd">        Number of foreground pixels.</span>
<span class="sd">    **orientation** : float</span>
<span class="sd">        Angle between the 0th axis (rows) and the major</span>
<span class="sd">        axis of the ellipse that has the same second moments as the region,</span>
<span class="sd">        ranging from `-pi/2` to `pi/2` counter-clockwise.</span>
<span class="sd">    **perimeter** : float</span>
<span class="sd">        Perimeter of object which approximates the contour as a line</span>
<span class="sd">        through the centers of border pixels using a 4-connectivity.</span>
<span class="sd">    **perimeter_crofton** : float</span>
<span class="sd">        Perimeter of object approximated by the Crofton formula in 4</span>
<span class="sd">        directions.</span>
<span class="sd">    **slice** : tuple of slices</span>
<span class="sd">        A slice to extract the object from the source image.</span>
<span class="sd">    **solidity** : float</span>
<span class="sd">        Ratio of pixels in the region to pixels of the convex hull image.</span>

<span class="sd">    Each region also supports iteration, so that you can do::</span>

<span class="sd">      for prop in region:</span>
<span class="sd">          print(prop, region[prop])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    label</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:</span>
<span class="sd">           Core Algorithms. Springer-Verlag, London, 2009.</span>
<span class="sd">    .. [2] B. Jhne. Digital Image Processing. Springer-Verlag,</span>
<span class="sd">           Berlin-Heidelberg, 6. edition, 2005.</span>
<span class="sd">    .. [3] T. H. Reiss. Recognizing Planar Objects Using Invariant Image</span>
<span class="sd">           Features, from Lecture notes in computer science, p. 676. Springer,</span>
<span class="sd">           Berlin, 1993.</span>
<span class="sd">    .. [4] https://en.wikipedia.org/wiki/Image_moment</span>
<span class="sd">    .. [5] W. Pabst, E. Gregorov. Characterization of particles and particle</span>
<span class="sd">           systems, pp. 27-28. ICT Prague, 2007.</span>
<span class="sd">           https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from skimage import data, util</span>
<span class="sd">    &gt;&gt;&gt; from skimage.measure import label, regionprops</span>
<span class="sd">    &gt;&gt;&gt; img = util.img_as_ubyte(data.coins()) &gt; 110</span>
<span class="sd">    &gt;&gt;&gt; label_img = label(img, connectivity=img.ndim)</span>
<span class="sd">    &gt;&gt;&gt; props = regionprops(label_img)</span>
<span class="sd">    &gt;&gt;&gt; # centroid of first labeled object</span>
<span class="sd">    &gt;&gt;&gt; props[0].centroid</span>
<span class="sd">    (22.72987986048314, 81.91228523446583)</span>
<span class="sd">    &gt;&gt;&gt; # centroid of first labeled object</span>
<span class="sd">    &gt;&gt;&gt; props[0][&#39;centroid&#39;]</span>
<span class="sd">    (22.72987986048314, 81.91228523446583)</span>

<span class="sd">    Add custom measurements by passing functions as ``extra_properties``</span>

<span class="sd">    &gt;&gt;&gt; from skimage import data, util</span>
<span class="sd">    &gt;&gt;&gt; from skimage.measure import label, regionprops</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; img = util.img_as_ubyte(data.coins()) &gt; 110</span>
<span class="sd">    &gt;&gt;&gt; label_img = label(img, connectivity=img.ndim)</span>
<span class="sd">    &gt;&gt;&gt; def pixelcount(regionmask):</span>
<span class="sd">    ...     return np.sum(regionmask)</span>
<span class="sd">    &gt;&gt;&gt; props = regionprops(label_img, extra_properties=(pixelcount,))</span>
<span class="sd">    &gt;&gt;&gt; props[0].pixelcount</span>
<span class="sd">    7741</span>
<span class="sd">    &gt;&gt;&gt; props[1][&#39;pixelcount&#39;]</span>
<span class="sd">    42</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">label_image</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">spikes_per_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikes_per_pos</span><span class="p">)</span> <span class="o">==</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only 2-D and 3-D images supported.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">label_image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">label_image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Non-integer image types are ambiguous: &quot;</span>
                <span class="s2">&quot;use skimage.measure.label to label the connected &quot;</span>
                <span class="s2">&quot;components of label_image, &quot;</span>
                <span class="s2">&quot;or label_image.astype(np.uint8) to interpret &quot;</span>
                <span class="s2">&quot;the True values as a single label.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Non-integer label_image types are ambiguous&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">offset_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">offset_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Offset should be an array-like of integers &quot;</span>
                <span class="s2">&quot;of shape (label_image.ndim,); &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2"> was provided.&quot;</span>
            <span class="p">)</span>

    <span class="n">pos_sample_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pos_sample_rate&quot;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
    <span class="n">ye</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">bin_edges</span>
    <span class="n">x_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xe</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ye</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">xy_field_label</span> <span class="o">=</span> <span class="n">label_image</span><span class="p">[</span><span class="n">y_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">labelled_runs</span> <span class="o">=</span> <span class="n">labelContigNonZeroRuns</span><span class="p">(</span><span class="n">xy_field_label</span><span class="p">)</span>
    <span class="n">run_starts</span> <span class="o">=</span> <span class="n">getLabelStarts</span><span class="p">(</span><span class="n">labelled_runs</span><span class="p">)</span>
    <span class="n">run_stops</span> <span class="o">=</span> <span class="n">getLabelEnds</span><span class="p">(</span><span class="n">labelled_runs</span><span class="p">)</span>

    <span class="c1"># calculate the speed for possibly filtering runs later</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">pos_sample_rate</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">speed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">regions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">run_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">objects</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">objects</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">label</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># get the runs through this field and filter for min run length</span>
        <span class="n">run_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labelled_runs</span><span class="p">[</span><span class="n">xy_field_label</span> <span class="o">==</span> <span class="n">label</span><span class="p">])</span>
        <span class="n">run_slices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">slice</span><span class="p">(</span><span class="n">run_starts</span><span class="p">[</span><span class="n">ri</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">run_stops</span><span class="p">[</span><span class="n">ri</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">run_index</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">run_stops</span><span class="p">[</span><span class="n">ri</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">run_starts</span><span class="p">[</span><span class="n">ri</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span>
        <span class="p">]</span>
        <span class="n">props</span> <span class="o">=</span> <span class="n">FieldProps</span><span class="p">(</span>
            <span class="n">sl</span><span class="p">,</span>
            <span class="n">label</span><span class="p">,</span>
            <span class="n">label_image</span><span class="p">,</span>
            <span class="n">binned_data</span><span class="p">,</span>
            <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span>
            <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span>
            <span class="n">extra_properties</span><span class="o">=</span><span class="n">extra_properties</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset_arr</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># extract a few metrics for instantiating the RunProps objects...</span>
        <span class="n">peak_xy</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">xy_at_peak</span>
        <span class="n">max_index</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">max_index</span>
        <span class="n">perimeter_coords</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">perimeter_coords</span>
        <span class="n">runs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rs</span> <span class="ow">in</span> <span class="n">run_slices</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">RunProps</span><span class="p">(</span>
                <span class="n">run_id</span><span class="p">,</span>
                <span class="n">rs</span><span class="p">,</span>
                <span class="n">xy</span><span class="p">[:,</span> <span class="n">rs</span><span class="p">],</span>
                <span class="n">spikes_per_pos</span><span class="p">[</span><span class="n">rs</span><span class="p">],</span>
                <span class="n">speed</span><span class="p">[</span><span class="n">rs</span><span class="p">],</span>
                <span class="n">peak_xy</span><span class="p">,</span>
                <span class="n">max_index</span><span class="p">,</span>
                <span class="n">perimeter_coords</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">run_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">runs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="c1"># ... and add the list of runs to the FieldProps instance</span>
        <span class="n">props</span><span class="o">.</span><span class="n">runs</span> <span class="o">=</span> <span class="n">runs</span>

        <span class="n">regions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">props</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">regions</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.get_circular_regions" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_circular_regions</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns a list of images which are expanding circular
regions centred on the middle of the image out to the
image edge. Used for calculating the grid score of each
image to find the one with the max grid score. Based on
some Moser paper I can't recall.</p>
<p>Args:
    A (np.ndarray): The SAC</p>
<p>Keyword Args:
    min_radius (int): The smallest radius circle to start with</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2267</span>
<span class="normal">2268</span>
<span class="normal">2269</span>
<span class="normal">2270</span>
<span class="normal">2271</span>
<span class="normal">2272</span>
<span class="normal">2273</span>
<span class="normal">2274</span>
<span class="normal">2275</span>
<span class="normal">2276</span>
<span class="normal">2277</span>
<span class="normal">2278</span>
<span class="normal">2279</span>
<span class="normal">2280</span>
<span class="normal">2281</span>
<span class="normal">2282</span>
<span class="normal">2283</span>
<span class="normal">2284</span>
<span class="normal">2285</span>
<span class="normal">2286</span>
<span class="normal">2287</span>
<span class="normal">2288</span>
<span class="normal">2289</span>
<span class="normal">2290</span>
<span class="normal">2291</span>
<span class="normal">2292</span>
<span class="normal">2293</span>
<span class="normal">2294</span>
<span class="normal">2295</span>
<span class="normal">2296</span>
<span class="normal">2297</span>
<span class="normal">2298</span>
<span class="normal">2299</span>
<span class="normal">2300</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_circular_regions</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of images which are expanding circular</span>
<span class="sd">    regions centred on the middle of the image out to the</span>
<span class="sd">    image edge. Used for calculating the grid score of each</span>
<span class="sd">    image to find the one with the max grid score. Based on</span>
<span class="sd">    some Moser paper I can&#39;t recall.</span>

<span class="sd">    Args:</span>
<span class="sd">        A (np.ndarray): The SAC</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        min_radius (int): The smallest radius circle to start with</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">CircleModel</span><span class="p">,</span> <span class="n">grid_points_in_poly</span>

    <span class="n">min_radius</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="k">if</span> <span class="s2">&quot;min_radius&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">min_radius</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;min_radius&quot;</span><span class="p">]</span>

    <span class="n">centre</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">d</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)])</span>
    <span class="n">max_radius</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">centre</span><span class="p">)))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span>
    <span class="n">circle</span> <span class="o">=</span> <span class="n">CircleModel</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">radius</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_radius</span><span class="p">,</span> <span class="n">max_radius</span><span class="p">):</span>
        <span class="n">circle</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">centre</span><span class="p">,</span> <span class="n">radius</span><span class="p">]</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">circle</span><span class="o">.</span><span class="n">predict_xy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">grid_points_in_poly</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">xy</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">im</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.get_deformed_sac_gridscore" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_deformed_sac_gridscore</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Deforms a non-circular SAC into a circular SAC (circular meaning
the ellipse drawn around the edges of the 6 nearest peaks to the
SAC centre) and returns get_basic_griscore() calculated on the
deformed (or re-formed?!) SAC</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2320</span>
<span class="normal">2321</span>
<span class="normal">2322</span>
<span class="normal">2323</span>
<span class="normal">2324</span>
<span class="normal">2325</span>
<span class="normal">2326</span>
<span class="normal">2327</span>
<span class="normal">2328</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_deformed_sac_gridscore</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deforms a non-circular SAC into a circular SAC (circular meaning</span>
<span class="sd">    the ellipse drawn around the edges of the 6 nearest peaks to the</span>
<span class="sd">    SAC centre) and returns get_basic_griscore() calculated on the</span>
<span class="sd">    deformed (or re-formed?!) SAC</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deformed_SAC</span> <span class="o">=</span> <span class="n">deform_SAC</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gridness</span><span class="p">(</span><span class="n">deformed_SAC</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.get_expanding_circle_gridscore" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_expanding_circle_gridscore</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates the gridscore for each circular sub-region of image A
where the circles are centred on the image centre and expanded to
the edge of the image. The maximum of the get_basic_gridscore() for
each of these circular sub-regions is returned as the gridscore</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2307</span>
<span class="normal">2308</span>
<span class="normal">2309</span>
<span class="normal">2310</span>
<span class="normal">2311</span>
<span class="normal">2312</span>
<span class="normal">2313</span>
<span class="normal">2314</span>
<span class="normal">2315</span>
<span class="normal">2316</span>
<span class="normal">2317</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_expanding_circle_gridscore</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the gridscore for each circular sub-region of image A</span>
<span class="sd">    where the circles are centred on the image centre and expanded to</span>
<span class="sd">    the edge of the image. The maximum of the get_basic_gridscore() for</span>
<span class="sd">    each of these circular sub-regions is returned as the gridscore</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">images</span> <span class="o">=</span> <span class="n">get_circular_regions</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">gridscores</span> <span class="o">=</span> <span class="p">[</span><span class="n">gridness</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">gridscores</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.get_mean_resultant" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_mean_resultant</span><span class="p">(</span><span class="n">ego_boundary_map</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates the mean resultant vector of a boundary map in egocentric coordinates</p>
<p>See Hinman et al., 2019 for more details</p>
<p>Args:
    ego_boundary_map (np.ndarray): The egocentric boundary map</p>
<p>Returns:
    float: The mean resultant vector of the egocentric boundary map</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_mean_resultant</span><span class="p">(</span><span class="n">ego_boundary_map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the mean resultant vector of a boundary map in egocentric coordinates</span>

<span class="sd">    See Hinman et al., 2019 for more details</span>

<span class="sd">    Args:</span>
<span class="sd">        ego_boundary_map (np.ndarray): The egocentric boundary map</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The mean resultant vector of the egocentric boundary map</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">ego_boundary_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ego_boundary_map</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">MR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">ego_boundary_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="n">angles</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
        <span class="n">n</span> <span class="o">*</span> <span class="n">m</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">MR</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.get_thigmotaxis_score" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_thigmotaxis_score</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;circle&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns a score which is the ratio of the time spent in the inner
portion of an environment to the time spent in the outer portion.
The portions are allocated so that they have equal area.</p>
<p>Args:
    xy (np.ndarray): The xy coordinates of the animal's position. 2 x nsamples
    shape (str): The shape of the environment. Legal values are 'circle'
    and 'square'. Default 'circle'</p>
<p>Returns:
thigmoxtaxis_score (float): Values closer to 1 indicate the
animal spent more time in the inner portion of the environment. Values closer to -1
indicates the animal spent more time in the outer portion of the environment.
A value of 0 indicates the animal spent equal time in both portions of the
environment.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2331</span>
<span class="normal">2332</span>
<span class="normal">2333</span>
<span class="normal">2334</span>
<span class="normal">2335</span>
<span class="normal">2336</span>
<span class="normal">2337</span>
<span class="normal">2338</span>
<span class="normal">2339</span>
<span class="normal">2340</span>
<span class="normal">2341</span>
<span class="normal">2342</span>
<span class="normal">2343</span>
<span class="normal">2344</span>
<span class="normal">2345</span>
<span class="normal">2346</span>
<span class="normal">2347</span>
<span class="normal">2348</span>
<span class="normal">2349</span>
<span class="normal">2350</span>
<span class="normal">2351</span>
<span class="normal">2352</span>
<span class="normal">2353</span>
<span class="normal">2354</span>
<span class="normal">2355</span>
<span class="normal">2356</span>
<span class="normal">2357</span>
<span class="normal">2358</span>
<span class="normal">2359</span>
<span class="normal">2360</span>
<span class="normal">2361</span>
<span class="normal">2362</span>
<span class="normal">2363</span>
<span class="normal">2364</span>
<span class="normal">2365</span>
<span class="normal">2366</span>
<span class="normal">2367</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_thigmotaxis_score</span><span class="p">(</span><span class="n">xy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;circle&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a score which is the ratio of the time spent in the inner</span>
<span class="sd">    portion of an environment to the time spent in the outer portion.</span>
<span class="sd">    The portions are allocated so that they have equal area.</span>

<span class="sd">    Args:</span>
<span class="sd">        xy (np.ndarray): The xy coordinates of the animal&#39;s position. 2 x nsamples</span>
<span class="sd">        shape (str): The shape of the environment. Legal values are &#39;circle&#39;</span>
<span class="sd">        and &#39;square&#39;. Default &#39;circle&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">    thigmoxtaxis_score (float): Values closer to 1 indicate the</span>
<span class="sd">    animal spent more time in the inner portion of the environment. Values closer to -1</span>
<span class="sd">    indicates the animal spent more time in the outer portion of the environment.</span>
<span class="sd">    A value of 0 indicates the animal spent equal time in both portions of the</span>
<span class="sd">    environment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># centre the coords to get the max distance from the centre</span>
    <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xc</span><span class="p">],</span> <span class="p">[</span><span class="n">yc</span><span class="p">]])</span>
    <span class="n">n_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xy</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">inner_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_pos</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;circle&quot;</span><span class="p">:</span>
        <span class="n">outer_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">inner_radius</span> <span class="o">=</span> <span class="n">outer_radius</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">inner_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">inner_radius</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">inner_mask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;square&quot;</span><span class="p">:</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">inner_width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">inner_height</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">x_gap</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="n">inner_width</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">y_gap</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="n">inner_height</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">x_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">x_gap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">x_gap</span><span class="p">)</span>
        <span class="n">y_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">y_gap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">y_gap</span><span class="p">)</span>
        <span class="n">inner_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x_mask</span><span class="p">,</span> <span class="n">y_mask</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">inner_mask</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">inner_mask</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">inner_mask</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_pos</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.global_threshold" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">global_threshold</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Globally thresholds a ratemap and counts number of fields found</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">global_threshold</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Globally thresholds a ratemap and counts number of fields found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span> <span class="p">:</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Ac</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
    <span class="n">maxRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">Ac</span><span class="p">))</span>
    <span class="n">Ac</span><span class="p">[</span><span class="n">Ac</span> <span class="o">&lt;</span> <span class="n">maxRate</span> <span class="o">*</span> <span class="p">(</span><span class="n">prc</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="p">))]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Ac_r</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span>
        <span class="n">Ac</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">peak_idx</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span>
        <span class="n">Ac_r</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">peak_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">peak_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">peak_idx</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">peak_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">field_labels</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">Ac</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="n">peak_labels</span><span class="p">)</span>
    <span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">field_labels</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nFields</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.grid_field_props" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grid_field_props</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">maxima</span><span class="o">=</span><span class="s1">&#39;centroid&#39;</span><span class="p">,</span> <span class="n">allProps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Extracts various measures from a spatial autocorrelogram</p>
<p>Args:
    A: BinnedData object containing the spatial autocorrelogram (SAC) in
        A.binned_data[0]
    maxima (str, optional): The method used to detect the peaks in the SAC.
        Legal values are 'single' and 'centroid'. Default 'centroid'
    allProps (bool, optional): Whether to return a dictionary that
    contains the attempt to fit an ellipse around the edges of the
    central size peaks. See below
        Default True</p>
<p>Returns:
    props (dict): A dictionary containing measures of the SAC.
    Keys include:
        * gridness score
        * scale
        * orientation
        * coordinates of the peaks (nominally 6) closest to SAC centre
        * a binary mask around the extent of the 6 central fields
        * values of the rotation procedure used to calculate gridness
        * ellipse axes and angle (if allProps is True and the it worked)</p>
<p>Notes:
    The output from this method can be used as input to the show() method
    of this class.
    When it is the plot produced will display a lot more informative.
    The coordinate system internally used is centred on the image centre.</p>
<p>See Also:
    ephysiopy.common.binning.autoCorr2D()</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1920</span>
<span class="normal">1921</span>
<span class="normal">1922</span>
<span class="normal">1923</span>
<span class="normal">1924</span>
<span class="normal">1925</span>
<span class="normal">1926</span>
<span class="normal">1927</span>
<span class="normal">1928</span>
<span class="normal">1929</span>
<span class="normal">1930</span>
<span class="normal">1931</span>
<span class="normal">1932</span>
<span class="normal">1933</span>
<span class="normal">1934</span>
<span class="normal">1935</span>
<span class="normal">1936</span>
<span class="normal">1937</span>
<span class="normal">1938</span>
<span class="normal">1939</span>
<span class="normal">1940</span>
<span class="normal">1941</span>
<span class="normal">1942</span>
<span class="normal">1943</span>
<span class="normal">1944</span>
<span class="normal">1945</span>
<span class="normal">1946</span>
<span class="normal">1947</span>
<span class="normal">1948</span>
<span class="normal">1949</span>
<span class="normal">1950</span>
<span class="normal">1951</span>
<span class="normal">1952</span>
<span class="normal">1953</span>
<span class="normal">1954</span>
<span class="normal">1955</span>
<span class="normal">1956</span>
<span class="normal">1957</span>
<span class="normal">1958</span>
<span class="normal">1959</span>
<span class="normal">1960</span>
<span class="normal">1961</span>
<span class="normal">1962</span>
<span class="normal">1963</span>
<span class="normal">1964</span>
<span class="normal">1965</span>
<span class="normal">1966</span>
<span class="normal">1967</span>
<span class="normal">1968</span>
<span class="normal">1969</span>
<span class="normal">1970</span>
<span class="normal">1971</span>
<span class="normal">1972</span>
<span class="normal">1973</span>
<span class="normal">1974</span>
<span class="normal">1975</span>
<span class="normal">1976</span>
<span class="normal">1977</span>
<span class="normal">1978</span>
<span class="normal">1979</span>
<span class="normal">1980</span>
<span class="normal">1981</span>
<span class="normal">1982</span>
<span class="normal">1983</span>
<span class="normal">1984</span>
<span class="normal">1985</span>
<span class="normal">1986</span>
<span class="normal">1987</span>
<span class="normal">1988</span>
<span class="normal">1989</span>
<span class="normal">1990</span>
<span class="normal">1991</span>
<span class="normal">1992</span>
<span class="normal">1993</span>
<span class="normal">1994</span>
<span class="normal">1995</span>
<span class="normal">1996</span>
<span class="normal">1997</span>
<span class="normal">1998</span>
<span class="normal">1999</span>
<span class="normal">2000</span>
<span class="normal">2001</span>
<span class="normal">2002</span>
<span class="normal">2003</span>
<span class="normal">2004</span>
<span class="normal">2005</span>
<span class="normal">2006</span>
<span class="normal">2007</span>
<span class="normal">2008</span>
<span class="normal">2009</span>
<span class="normal">2010</span>
<span class="normal">2011</span>
<span class="normal">2012</span>
<span class="normal">2013</span>
<span class="normal">2014</span>
<span class="normal">2015</span>
<span class="normal">2016</span>
<span class="normal">2017</span>
<span class="normal">2018</span>
<span class="normal">2019</span>
<span class="normal">2020</span>
<span class="normal">2021</span>
<span class="normal">2022</span>
<span class="normal">2023</span>
<span class="normal">2024</span>
<span class="normal">2025</span>
<span class="normal">2026</span>
<span class="normal">2027</span>
<span class="normal">2028</span>
<span class="normal">2029</span>
<span class="normal">2030</span>
<span class="normal">2031</span>
<span class="normal">2032</span>
<span class="normal">2033</span>
<span class="normal">2034</span>
<span class="normal">2035</span>
<span class="normal">2036</span>
<span class="normal">2037</span>
<span class="normal">2038</span>
<span class="normal">2039</span>
<span class="normal">2040</span>
<span class="normal">2041</span>
<span class="normal">2042</span>
<span class="normal">2043</span>
<span class="normal">2044</span>
<span class="normal">2045</span>
<span class="normal">2046</span>
<span class="normal">2047</span>
<span class="normal">2048</span>
<span class="normal">2049</span>
<span class="normal">2050</span>
<span class="normal">2051</span>
<span class="normal">2052</span>
<span class="normal">2053</span>
<span class="normal">2054</span>
<span class="normal">2055</span>
<span class="normal">2056</span>
<span class="normal">2057</span>
<span class="normal">2058</span>
<span class="normal">2059</span>
<span class="normal">2060</span>
<span class="normal">2061</span>
<span class="normal">2062</span>
<span class="normal">2063</span>
<span class="normal">2064</span>
<span class="normal">2065</span>
<span class="normal">2066</span>
<span class="normal">2067</span>
<span class="normal">2068</span>
<span class="normal">2069</span>
<span class="normal">2070</span>
<span class="normal">2071</span>
<span class="normal">2072</span>
<span class="normal">2073</span>
<span class="normal">2074</span>
<span class="normal">2075</span>
<span class="normal">2076</span>
<span class="normal">2077</span>
<span class="normal">2078</span>
<span class="normal">2079</span>
<span class="normal">2080</span>
<span class="normal">2081</span>
<span class="normal">2082</span>
<span class="normal">2083</span>
<span class="normal">2084</span>
<span class="normal">2085</span>
<span class="normal">2086</span>
<span class="normal">2087</span>
<span class="normal">2088</span>
<span class="normal">2089</span>
<span class="normal">2090</span>
<span class="normal">2091</span>
<span class="normal">2092</span>
<span class="normal">2093</span>
<span class="normal">2094</span>
<span class="normal">2095</span>
<span class="normal">2096</span>
<span class="normal">2097</span>
<span class="normal">2098</span>
<span class="normal">2099</span>
<span class="normal">2100</span>
<span class="normal">2101</span>
<span class="normal">2102</span>
<span class="normal">2103</span>
<span class="normal">2104</span>
<span class="normal">2105</span>
<span class="normal">2106</span>
<span class="normal">2107</span>
<span class="normal">2108</span>
<span class="normal">2109</span>
<span class="normal">2110</span>
<span class="normal">2111</span>
<span class="normal">2112</span>
<span class="normal">2113</span>
<span class="normal">2114</span>
<span class="normal">2115</span>
<span class="normal">2116</span>
<span class="normal">2117</span>
<span class="normal">2118</span>
<span class="normal">2119</span>
<span class="normal">2120</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">grid_field_props</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span> <span class="n">maxima</span><span class="o">=</span><span class="s2">&quot;centroid&quot;</span><span class="p">,</span> <span class="n">allProps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts various measures from a spatial autocorrelogram</span>

<span class="sd">    Args:</span>
<span class="sd">        A: BinnedData object containing the spatial autocorrelogram (SAC) in</span>
<span class="sd">            A.binned_data[0]</span>
<span class="sd">        maxima (str, optional): The method used to detect the peaks in the SAC.</span>
<span class="sd">            Legal values are &#39;single&#39; and &#39;centroid&#39;. Default &#39;centroid&#39;</span>
<span class="sd">        allProps (bool, optional): Whether to return a dictionary that</span>
<span class="sd">        contains the attempt to fit an ellipse around the edges of the</span>
<span class="sd">        central size peaks. See below</span>
<span class="sd">            Default True</span>

<span class="sd">    Returns:</span>
<span class="sd">        props (dict): A dictionary containing measures of the SAC.</span>
<span class="sd">        Keys include:</span>
<span class="sd">            * gridness score</span>
<span class="sd">            * scale</span>
<span class="sd">            * orientation</span>
<span class="sd">            * coordinates of the peaks (nominally 6) closest to SAC centre</span>
<span class="sd">            * a binary mask around the extent of the 6 central fields</span>
<span class="sd">            * values of the rotation procedure used to calculate gridness</span>
<span class="sd">            * ellipse axes and angle (if allProps is True and the it worked)</span>

<span class="sd">    Notes:</span>
<span class="sd">        The output from this method can be used as input to the show() method</span>
<span class="sd">        of this class.</span>
<span class="sd">        When it is the plot produced will display a lot more informative.</span>
<span class="sd">        The coordinate system internally used is centred on the image centre.</span>

<span class="sd">    See Also:</span>
<span class="sd">        ephysiopy.common.binning.autoCorr2D()</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign the output dictionary now as we want to return immediately if</span>
<span class="sd">    the input is bad</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dictKeys</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;gridscore&quot;</span><span class="p">,</span>
        <span class="s2">&quot;scale&quot;</span><span class="p">,</span>
        <span class="s2">&quot;orientation&quot;</span><span class="p">,</span>
        <span class="s2">&quot;closest_peak_coords&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dist_to_centre&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ellipse_axes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ellipse_angle&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ellipseXY&quot;</span><span class="p">,</span>
        <span class="s2">&quot;circleXY&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rotationArr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rotationCorrVals&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">outDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">dictKeys</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="n">A_tmp</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A_tmp</span><span class="p">)):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No data in SAC - returning nans in measures dict&quot;</span><span class="p">)</span>
        <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;dist_to_centre&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">outDict</span><span class="p">[</span><span class="s2">&quot;closest_peak_coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">outDict</span>

    <span class="n">A_tmp</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A_tmp</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">A_tmp</span><span class="p">[</span><span class="n">A_tmp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">A_sz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A_tmp</span><span class="p">))</span>
    <span class="c1"># [STAGE 1] find peaks &amp; identify 7 closest to centre</span>
    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">A_sz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;min_distance&quot;</span><span class="p">,</span> <span class="n">min_distance</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">field_labels</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partitionFields</span><span class="p">(</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">field_threshold_percent</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">field_rate_threshold</span><span class="o">=</span><span class="mf">0.001</span>
    <span class="p">)</span>
    <span class="c1"># peak_idx, field_labels = _get_field_labels(A_tmp, neighbours=7, **kwargs)</span>
    <span class="c1"># a fcn for the labeled_comprehension function that returns</span>
    <span class="c1"># linear indices in A where the values in A for each label are</span>
    <span class="c1"># greater than half the max in that labeled region</span>

    <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pos</span><span class="p">[</span><span class="n">val</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="n">nLbls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">field_labels</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">labeled_comprehension</span><span class="p">(</span>
        <span class="n">A_tmp</span><span class="p">,</span> <span class="n">field_labels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nLbls</span><span class="p">),</span> <span class="n">fn</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span>
    <span class="p">)</span>
    <span class="c1"># turn linear indices into coordinates</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">A_sz</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="n">half_peak_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">A_sz</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">peak_id</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="n">coord</span>
        <span class="n">half_peak_labels</span><span class="p">[</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">]</span> <span class="o">=</span> <span class="n">peak_id</span>

    <span class="c1"># Get some statistics about the labeled regions</span>
    <span class="n">lbl_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nLbls</span><span class="p">)</span>
    <span class="n">peak_coords</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">maximum_position</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">half_peak_labels</span><span class="p">,</span> <span class="n">lbl_range</span><span class="p">)</span>
    <span class="n">peak_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peak_coords</span><span class="p">)</span>
    <span class="c1"># Now convert the peak_coords to the image centre coordinate system</span>
    <span class="n">x_peaks</span><span class="p">,</span> <span class="n">y_peaks</span> <span class="o">=</span> <span class="n">peak_coords</span><span class="o">.</span><span class="n">T</span>
    <span class="n">x_peaks_ij</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x_peaks</span><span class="p">]</span>
    <span class="n">y_peaks_ij</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y_peaks</span><span class="p">]</span>
    <span class="n">peak_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_peaks_ij</span><span class="p">,</span> <span class="n">y_peaks_ij</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># Get some distance and morphology measures</span>
    <span class="n">peak_dist_to_centre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">peak_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">peak_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">closest_peak_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">peak_dist_to_centre</span><span class="p">)</span>
    <span class="n">central_peak_label</span> <span class="o">=</span> <span class="n">closest_peak_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">closest_peak_idx</span> <span class="o">=</span> <span class="n">closest_peak_idx</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_peak_idx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))]</span>
    <span class="c1"># closest_peak_idx should now the indices of the labeled 6 peaks</span>
    <span class="c1"># surrounding the central peak at the image centre</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">peak_dist_to_centre</span><span class="p">[</span><span class="n">closest_peak_idx</span><span class="p">])</span>
    <span class="n">orientation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">orientation</span> <span class="o">=</span> <span class="n">grid_orientation</span><span class="p">(</span><span class="n">peak_coords</span><span class="p">,</span> <span class="n">closest_peak_idx</span><span class="p">)</span>

    <span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>
    <span class="n">xv</span> <span class="o">=</span> <span class="n">xv</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># remove last row and column</span>
    <span class="n">yv</span> <span class="o">=</span> <span class="n">yv</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># remove last row and column</span>
    <span class="n">dist_to_centre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">)</span>
    <span class="c1"># get the max distance of the half-peak width labeled fields</span>
    <span class="c1"># from the centre of the image</span>
    <span class="n">max_dist_from_centre</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">peak_id</span><span class="p">,</span> <span class="n">_coords</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">peak_id</span> <span class="ow">in</span> <span class="n">closest_peak_idx</span><span class="p">:</span>
            <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="n">_coords</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">yc</span><span class="p">):</span>
                <span class="n">xc</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">xc</span><span class="p">]</span>
                <span class="n">yc</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">yc</span><span class="p">]</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">max_dist_from_centre</span><span class="p">:</span>
                    <span class="n">max_dist_from_centre</span> <span class="o">=</span> <span class="n">d</span>

    <span class="c1"># Set the outer bits and the central region of the SAC to nans</span>
    <span class="c1"># getting ready for the correlation procedure</span>
    <span class="n">dist_to_centre</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist_to_centre</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_dist_from_centre</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dist_to_centre</span><span class="p">[</span><span class="n">half_peak_labels</span> <span class="o">==</span> <span class="n">central_peak_label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dist_to_centre</span><span class="p">[</span><span class="n">dist_to_centre</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">dist_to_centre</span> <span class="o">=</span> <span class="n">dist_to_centre</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">sac_middle</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">sac_middle</span><span class="p">[</span><span class="o">~</span><span class="n">dist_to_centre</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="s2">&quot;step&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">gridscore</span><span class="p">,</span> <span class="n">rotationCorrVals</span><span class="p">,</span> <span class="n">rotationArr</span> <span class="o">=</span> <span class="n">gridness</span><span class="p">(</span><span class="n">sac_middle</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">gridscore</span><span class="p">,</span> <span class="n">rotationCorrVals</span><span class="p">,</span> <span class="n">rotationArr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">allProps</span><span class="p">:</span>
        <span class="c1"># attempt to fit an ellipse around the outer edges of the nearest</span>
        <span class="c1"># peaks to the centre of the SAC. First find the outer edges for</span>
        <span class="c1"># the closest peaks using a ndimages labeled_comprehension</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">fn2</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
                <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">A_sz</span><span class="p">)</span>
                <span class="n">xc</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">A_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">yc</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">A_sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">xc</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">yc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">ellipse_coords</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">labeled_comprehension</span><span class="p">(</span>
                <span class="n">A</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">half_peak_labels</span><span class="p">,</span>
                <span class="n">closest_peak_idx</span><span class="p">,</span>
                <span class="n">fn2</span><span class="p">,</span>
                <span class="nb">tuple</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">ellipse_fit_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ellipse_coords</span><span class="p">])</span>
            <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">EllipseModel</span>

            <span class="n">E</span> <span class="o">=</span> <span class="n">EllipseModel</span><span class="p">()</span>
            <span class="n">E</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">ellipse_fit_coords</span><span class="p">)</span>
            <span class="n">im_centre</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ellipse_axes</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">ellipse_angle</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ellipseXY</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">predict_xy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">E</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

            <span class="c1"># get the min containing circle given the eliipse minor axis</span>
            <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">CircleModel</span>

            <span class="n">_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">im_centre</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ellipse_axes</span><span class="p">)]</span>
            <span class="n">circleXY</span> <span class="o">=</span> <span class="n">CircleModel</span><span class="p">()</span><span class="o">.</span><span class="n">predict_xy</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">params</span><span class="o">=</span><span class="n">_params</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>  <span class="c1"># non-iterable x and y</span>
            <span class="n">ellipse_axes</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ellipse_angle</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">ellipseXY</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">circleXY</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># collect all the following keywords into a dict for output</span>
    <span class="n">closest_peak_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peak_coords</span><span class="p">)[</span><span class="n">closest_peak_idx</span><span class="p">]</span>

    <span class="c1"># Assign values to the output dictionary created at the start</span>
    <span class="k">for</span> <span class="n">thiskey</span> <span class="ow">in</span> <span class="n">outDict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">outDict</span><span class="p">[</span><span class="n">thiskey</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">thiskey</span><span class="p">]</span>
        <span class="c1"># neat trick: locals is a dict holding all locally scoped variables</span>
    <span class="k">return</span> <span class="n">outDict</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.grid_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grid_orientation</span><span class="p">(</span><span class="n">peakCoords</span><span class="p">,</span> <span class="n">closestPeakIdx</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates the orientation angle of a grid field.</p>
<p>The orientation angle is the angle of the first peak working
counter-clockwise from 3 o'clock</p>
<p>Args:
    peakCoords (array_like): The peak coordinates as pairs of xy
    closestPeakIdx (array_like): A 1D array of the indices in peakCoords
    of the peaks closest to the centre of the SAC</p>
<p>Returns:
    peak_orientation (float): The first value in an array of the angles of
    the peaks in the SAC working counter-clockwise from a line
    extending from the middle of the SAC to 3 o'clock.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2123</span>
<span class="normal">2124</span>
<span class="normal">2125</span>
<span class="normal">2126</span>
<span class="normal">2127</span>
<span class="normal">2128</span>
<span class="normal">2129</span>
<span class="normal">2130</span>
<span class="normal">2131</span>
<span class="normal">2132</span>
<span class="normal">2133</span>
<span class="normal">2134</span>
<span class="normal">2135</span>
<span class="normal">2136</span>
<span class="normal">2137</span>
<span class="normal">2138</span>
<span class="normal">2139</span>
<span class="normal">2140</span>
<span class="normal">2141</span>
<span class="normal">2142</span>
<span class="normal">2143</span>
<span class="normal">2144</span>
<span class="normal">2145</span>
<span class="normal">2146</span>
<span class="normal">2147</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">grid_orientation</span><span class="p">(</span><span class="n">peakCoords</span><span class="p">,</span> <span class="n">closestPeakIdx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the orientation angle of a grid field.</span>

<span class="sd">    The orientation angle is the angle of the first peak working</span>
<span class="sd">    counter-clockwise from 3 o&#39;clock</span>

<span class="sd">    Args:</span>
<span class="sd">        peakCoords (array_like): The peak coordinates as pairs of xy</span>
<span class="sd">        closestPeakIdx (array_like): A 1D array of the indices in peakCoords</span>
<span class="sd">        of the peaks closest to the centre of the SAC</span>

<span class="sd">    Returns:</span>
<span class="sd">        peak_orientation (float): The first value in an array of the angles of</span>
<span class="sd">        the peaks in the SAC working counter-clockwise from a line</span>
<span class="sd">        extending from the middle of the SAC to 3 o&#39;clock.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakCoords</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">closestPeakIdx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.common.utils</span> <span class="kn">import</span> <span class="n">polar</span>

        <span class="n">peaks</span> <span class="o">=</span> <span class="n">peakCoords</span><span class="p">[</span><span class="n">closestPeakIdx</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">theta</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.gridness" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">gridness</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates the gridness score in a grid cell SAC.</p>
<p>Briefly, the data in <code>image</code> is rotated in <code>step</code> amounts and
each rotated array is correlated with the original.
The maximum of the values at 30, 90 and 150 degrees
is the subtracted from the minimum of the values at 60, 120
and 180 degrees to give the grid score.</p>
<p>Args:
    image (array_like): The spatial autocorrelogram
    step (int, optional): The amount to rotate the SAC in each step of the
    rotational correlation procedure</p>
<p>Returns:
    gridmeasures (3-tuple): The gridscore, the correlation values at each
    <code>step</code> and the rotational array</p>
<p>Notes:
    The correlation performed is a Pearsons R. Some rescaling of the
    values in <code>image</code> is performed following rotation.</p>
<p>See Also:
    skimage.transform.rotate : for how the rotation of <code>image</code> is done
    skimage.exposure.rescale_intensity : for the resscaling following
    rotation</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2150</span>
<span class="normal">2151</span>
<span class="normal">2152</span>
<span class="normal">2153</span>
<span class="normal">2154</span>
<span class="normal">2155</span>
<span class="normal">2156</span>
<span class="normal">2157</span>
<span class="normal">2158</span>
<span class="normal">2159</span>
<span class="normal">2160</span>
<span class="normal">2161</span>
<span class="normal">2162</span>
<span class="normal">2163</span>
<span class="normal">2164</span>
<span class="normal">2165</span>
<span class="normal">2166</span>
<span class="normal">2167</span>
<span class="normal">2168</span>
<span class="normal">2169</span>
<span class="normal">2170</span>
<span class="normal">2171</span>
<span class="normal">2172</span>
<span class="normal">2173</span>
<span class="normal">2174</span>
<span class="normal">2175</span>
<span class="normal">2176</span>
<span class="normal">2177</span>
<span class="normal">2178</span>
<span class="normal">2179</span>
<span class="normal">2180</span>
<span class="normal">2181</span>
<span class="normal">2182</span>
<span class="normal">2183</span>
<span class="normal">2184</span>
<span class="normal">2185</span>
<span class="normal">2186</span>
<span class="normal">2187</span>
<span class="normal">2188</span>
<span class="normal">2189</span>
<span class="normal">2190</span>
<span class="normal">2191</span>
<span class="normal">2192</span>
<span class="normal">2193</span>
<span class="normal">2194</span>
<span class="normal">2195</span>
<span class="normal">2196</span>
<span class="normal">2197</span>
<span class="normal">2198</span>
<span class="normal">2199</span>
<span class="normal">2200</span>
<span class="normal">2201</span>
<span class="normal">2202</span>
<span class="normal">2203</span>
<span class="normal">2204</span>
<span class="normal">2205</span>
<span class="normal">2206</span>
<span class="normal">2207</span>
<span class="normal">2208</span>
<span class="normal">2209</span>
<span class="normal">2210</span>
<span class="normal">2211</span>
<span class="normal">2212</span>
<span class="normal">2213</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">gridness</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the gridness score in a grid cell SAC.</span>

<span class="sd">    Briefly, the data in `image` is rotated in `step` amounts and</span>
<span class="sd">    each rotated array is correlated with the original.</span>
<span class="sd">    The maximum of the values at 30, 90 and 150 degrees</span>
<span class="sd">    is the subtracted from the minimum of the values at 60, 120</span>
<span class="sd">    and 180 degrees to give the grid score.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (array_like): The spatial autocorrelogram</span>
<span class="sd">        step (int, optional): The amount to rotate the SAC in each step of the</span>
<span class="sd">        rotational correlation procedure</span>

<span class="sd">    Returns:</span>
<span class="sd">        gridmeasures (3-tuple): The gridscore, the correlation values at each</span>
<span class="sd">        `step` and the rotational array</span>

<span class="sd">    Notes:</span>
<span class="sd">        The correlation performed is a Pearsons R. Some rescaling of the</span>
<span class="sd">        values in `image` is performed following rotation.</span>

<span class="sd">    See Also:</span>
<span class="sd">        skimage.transform.rotate : for how the rotation of `image` is done</span>
<span class="sd">        skimage.exposure.rescale_intensity : for the resscaling following</span>
<span class="sd">        rotation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: add options in here for whether the full range of correlations</span>
    <span class="c1"># are wanted or whether a reduced set is wanted (i.e. at the 30-tuples)</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

    <span class="n">rotationalCorrVals</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">181</span><span class="p">,</span> <span class="n">step</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">rotationArr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rotationalCorrVals</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># autoCorrMiddle needs to be rescaled or the image rotation falls down</span>
    <span class="c1"># as values are cropped to lie between 0 and 1.0</span>
    <span class="n">in_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>
    <span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">skimage</span>

    <span class="n">autoCorrMiddleRescaled</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span>
        <span class="n">image</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="n">in_range</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="n">out_range</span>
    <span class="p">)</span>
    <span class="n">origNanIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">autoCorrMiddleRescaled</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="n">gridscore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rotationalCorrVals</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">rotatedA</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span>
                <span class="n">autoCorrMiddleRescaled</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span>
            <span class="p">)</span>
            <span class="c1"># ignore nans</span>
            <span class="n">rotatedNanIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rotatedA</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="n">allNans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">origNanIdx</span><span class="p">,</span> <span class="n">rotatedNanIdx</span><span class="p">)</span>
            <span class="c1"># get the correlation between the original and rotated images</span>
            <span class="n">rotationalCorrVals</span><span class="p">[</span><span class="n">angle</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span>
                <span class="n">autoCorrMiddleRescaled</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="o">~</span><span class="n">allNans</span><span class="p">],</span> <span class="n">rotatedA</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="o">~</span><span class="n">allNans</span><span class="p">]</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rotationArr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotationalCorrVals</span><span class="p">[</span><span class="n">angle</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gridscore</span><span class="p">,</span> <span class="n">rotationalCorrVals</span><span class="p">,</span> <span class="n">rotationArr</span>
    <span class="n">gridscore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">60</span><span class="p">],</span> <span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">120</span><span class="p">]))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
        <span class="p">(</span><span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">150</span><span class="p">],</span> <span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">30</span><span class="p">],</span> <span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">90</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">gridscore</span><span class="p">,</span> <span class="n">rotationalCorrVals</span><span class="p">,</span> <span class="n">rotationArr</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.kl_spatial_sparsity" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">kl_spatial_sparsity</span><span class="p">(</span><span class="n">pos_map</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates a measure of spatial sampling of an arena by comparing the
given spatial sampling to a uniform one using kl divergence</p>
<p>Data in pos_map should be unsmoothed (not checked) and the MapType should
be POS (checked)</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1722</span>
<span class="normal">1723</span>
<span class="normal">1724</span>
<span class="normal">1725</span>
<span class="normal">1726</span>
<span class="normal">1727</span>
<span class="normal">1728</span>
<span class="normal">1729</span>
<span class="normal">1730</span>
<span class="normal">1731</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">kl_spatial_sparsity</span><span class="p">(</span><span class="n">pos_map</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates a measure of spatial sampling of an arena by comparing the</span>
<span class="sd">    given spatial sampling to a uniform one using kl divergence</span>

<span class="sd">    Data in pos_map should be unsmoothed (not checked) and the MapType should</span>
<span class="sd">    be POS (checked)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">pos_map</span><span class="o">.</span><span class="n">map_type</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">POS</span>
    <span class="k">return</span> <span class="n">kldiv_dir</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">pos_map</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.kldiv" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">kldiv</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pvect1</span><span class="p">,</span> <span class="n">pvect2</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates the Kullback-Leibler or Jensen-Shannon divergence between
two distributions.</p>
<p>Args:
    X (array_like): Vector of M variable values
    P1 (array_like): Length-M vector of probabilities representing
    distribution 1
    P2 (array_like): Length-M vector of probabilities representing
    distribution 2
    sym (str, optional): If 'sym', returns a symmetric variant of the
        Kullback-Leibler divergence, given by [KL(P1,P2)+KL(P2,P1)]/2
    js (str, optional): If 'js', returns the Jensen-Shannon divergence,
    given by
        [KL(P1,Q)+KL(P2,Q)]/2, where Q = (P1+P2)/2</p>
<p>Returns:
    float: The Kullback-Leibler divergence or Jensen-Shannon divergence</p>
<p>Notes:
    The Kullback-Leibler divergence is given by:</p>
<pre><code>.. math:: KL(P1(x),P2(x)) = sum_[P1(x).log(P1(x)/P2(x))]

If X contains duplicate values, there will be an warning message,
and these values will be treated as distinct values.  (I.e., the
actual values do not enter into the computation, but the probabilities
for the two duplicate values will be considered as probabilities
corresponding to two unique values.).
The elements of probability vectors P1 and P2 must
each sum to 1 +/- .00001.

This function is taken from one on the Mathworks file exchange
</code></pre>
<p>See Also:
    Cover, T.M. and J.A. Thomas. "Elements of Information Theory," Wiley,
    1991.</p>
<pre><code>https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence
</code></pre>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1804</span>
<span class="normal">1805</span>
<span class="normal">1806</span>
<span class="normal">1807</span>
<span class="normal">1808</span>
<span class="normal">1809</span>
<span class="normal">1810</span>
<span class="normal">1811</span>
<span class="normal">1812</span>
<span class="normal">1813</span>
<span class="normal">1814</span>
<span class="normal">1815</span>
<span class="normal">1816</span>
<span class="normal">1817</span>
<span class="normal">1818</span>
<span class="normal">1819</span>
<span class="normal">1820</span>
<span class="normal">1821</span>
<span class="normal">1822</span>
<span class="normal">1823</span>
<span class="normal">1824</span>
<span class="normal">1825</span>
<span class="normal">1826</span>
<span class="normal">1827</span>
<span class="normal">1828</span>
<span class="normal">1829</span>
<span class="normal">1830</span>
<span class="normal">1831</span>
<span class="normal">1832</span>
<span class="normal">1833</span>
<span class="normal">1834</span>
<span class="normal">1835</span>
<span class="normal">1836</span>
<span class="normal">1837</span>
<span class="normal">1838</span>
<span class="normal">1839</span>
<span class="normal">1840</span>
<span class="normal">1841</span>
<span class="normal">1842</span>
<span class="normal">1843</span>
<span class="normal">1844</span>
<span class="normal">1845</span>
<span class="normal">1846</span>
<span class="normal">1847</span>
<span class="normal">1848</span>
<span class="normal">1849</span>
<span class="normal">1850</span>
<span class="normal">1851</span>
<span class="normal">1852</span>
<span class="normal">1853</span>
<span class="normal">1854</span>
<span class="normal">1855</span>
<span class="normal">1856</span>
<span class="normal">1857</span>
<span class="normal">1858</span>
<span class="normal">1859</span>
<span class="normal">1860</span>
<span class="normal">1861</span>
<span class="normal">1862</span>
<span class="normal">1863</span>
<span class="normal">1864</span>
<span class="normal">1865</span>
<span class="normal">1866</span>
<span class="normal">1867</span>
<span class="normal">1868</span>
<span class="normal">1869</span>
<span class="normal">1870</span>
<span class="normal">1871</span>
<span class="normal">1872</span>
<span class="normal">1873</span>
<span class="normal">1874</span>
<span class="normal">1875</span>
<span class="normal">1876</span>
<span class="normal">1877</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">kldiv</span><span class="p">(</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pvect1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pvect2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">variant</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Kullback-Leibler or Jensen-Shannon divergence between</span>
<span class="sd">    two distributions.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (array_like): Vector of M variable values</span>
<span class="sd">        P1 (array_like): Length-M vector of probabilities representing</span>
<span class="sd">        distribution 1</span>
<span class="sd">        P2 (array_like): Length-M vector of probabilities representing</span>
<span class="sd">        distribution 2</span>
<span class="sd">        sym (str, optional): If &#39;sym&#39;, returns a symmetric variant of the</span>
<span class="sd">            Kullback-Leibler divergence, given by [KL(P1,P2)+KL(P2,P1)]/2</span>
<span class="sd">        js (str, optional): If &#39;js&#39;, returns the Jensen-Shannon divergence,</span>
<span class="sd">        given by</span>
<span class="sd">            [KL(P1,Q)+KL(P2,Q)]/2, where Q = (P1+P2)/2</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The Kullback-Leibler divergence or Jensen-Shannon divergence</span>

<span class="sd">    Notes:</span>
<span class="sd">        The Kullback-Leibler divergence is given by:</span>

<span class="sd">        .. math:: KL(P1(x),P2(x)) = sum_[P1(x).log(P1(x)/P2(x))]</span>

<span class="sd">        If X contains duplicate values, there will be an warning message,</span>
<span class="sd">        and these values will be treated as distinct values.  (I.e., the</span>
<span class="sd">        actual values do not enter into the computation, but the probabilities</span>
<span class="sd">        for the two duplicate values will be considered as probabilities</span>
<span class="sd">        corresponding to two unique values.).</span>
<span class="sd">        The elements of probability vectors P1 and P2 must</span>
<span class="sd">        each sum to 1 +/- .00001.</span>

<span class="sd">        This function is taken from one on the Mathworks file exchange</span>

<span class="sd">    See Also:</span>
<span class="sd">        Cover, T.M. and J.A. Thomas. &quot;Elements of Information Theory,&quot; Wiley,</span>
<span class="sd">        1991.</span>

<span class="sd">        https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;X contains duplicate values. Treated as distinct values.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pvect1</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pvect2</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inputs are not the same size&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00001</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00001</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Probabilities sum to </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvect1</span><span class="p">))</span><span class="si">}</span><span class="s2"> for pvect1&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Probabilities sum to </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvect2</span><span class="p">))</span><span class="si">}</span><span class="s2"> for pvect2&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Probabilities don&quot;</span> <span class="s2">&quot;t sum to 1.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">variant</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">variant</span> <span class="o">==</span> <span class="s2">&quot;js&quot;</span><span class="p">:</span>
            <span class="n">logqvect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">((</span><span class="n">pvect2</span> <span class="o">+</span> <span class="n">pvect1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">KL</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pvect1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)</span> <span class="o">-</span> <span class="n">logqvect</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvect2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)</span> <span class="o">-</span> <span class="n">logqvect</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">KL</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">variant</span> <span class="o">==</span> <span class="s2">&quot;sym&quot;</span><span class="p">:</span>
            <span class="n">KL1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pvect1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)))</span>
            <span class="n">KL2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pvect2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)))</span>
            <span class="n">KL</span> <span class="o">=</span> <span class="p">(</span><span class="n">KL1</span> <span class="o">+</span> <span class="n">KL2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">KL</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Last argument not recognised&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
    <span class="n">KL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pvect1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)))</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">KL</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.kldiv_dir" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">kldiv_dir</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns a kl divergence for directional firing: measure of directionality.
Calculates kl diveregence between a smoothed ratemap (probably should be
smoothed otherwise information theoretic measures
don't 'care' about position of bins relative to one another) and a
pure circular distribution.
The larger the divergence the more tendancy the cell has to fire when the
animal faces a specific direction.</p>
<p>Args:
    polarPlot (1D-array): The binned and smoothed directional ratemap</p>
<p>Returns:
    klDivergence (float): The divergence from circular of the 1D-array
    from a uniform circular distribution</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1774</span>
<span class="normal">1775</span>
<span class="normal">1776</span>
<span class="normal">1777</span>
<span class="normal">1778</span>
<span class="normal">1779</span>
<span class="normal">1780</span>
<span class="normal">1781</span>
<span class="normal">1782</span>
<span class="normal">1783</span>
<span class="normal">1784</span>
<span class="normal">1785</span>
<span class="normal">1786</span>
<span class="normal">1787</span>
<span class="normal">1788</span>
<span class="normal">1789</span>
<span class="normal">1790</span>
<span class="normal">1791</span>
<span class="normal">1792</span>
<span class="normal">1793</span>
<span class="normal">1794</span>
<span class="normal">1795</span>
<span class="normal">1796</span>
<span class="normal">1797</span>
<span class="normal">1798</span>
<span class="normal">1799</span>
<span class="normal">1800</span>
<span class="normal">1801</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">kldiv_dir</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a kl divergence for directional firing: measure of directionality.</span>
<span class="sd">    Calculates kl diveregence between a smoothed ratemap (probably should be</span>
<span class="sd">    smoothed otherwise information theoretic measures</span>
<span class="sd">    don&#39;t &#39;care&#39; about position of bins relative to one another) and a</span>
<span class="sd">    pure circular distribution.</span>
<span class="sd">    The larger the divergence the more tendancy the cell has to fire when the</span>
<span class="sd">    animal faces a specific direction.</span>

<span class="sd">    Args:</span>
<span class="sd">        polarPlot (1D-array): The binned and smoothed directional ratemap</span>

<span class="sd">    Returns:</span>
<span class="sd">        klDivergence (float): The divergence from circular of the 1D-array</span>
<span class="sd">        from a uniform circular distribution</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__inc</span> <span class="o">=</span> <span class="mf">0.00001</span>
    <span class="n">polarPlot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">)</span>
    <span class="n">polarPlot</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">)]</span> <span class="o">=</span> <span class="n">__inc</span>
    <span class="n">polarPlot</span><span class="p">[</span><span class="n">polarPlot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__inc</span>
    <span class="n">normdPolar</span> <span class="o">=</span> <span class="n">polarPlot</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">))</span>
    <span class="n">nDirBins</span> <span class="o">=</span> <span class="n">polarPlot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">compCirc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nDirBins</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nDirBins</span><span class="p">)</span>
    <span class="n">kldivergence</span> <span class="o">=</span> <span class="n">kldiv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">normdPolar</span><span class="p">,</span> <span class="n">compCirc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kldivergence</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.limit_to_one" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">limit_to_one</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Processes a multi-peaked ratemap (ie grid cell) and returns a matrix
where the multi-peaked ratemap consist of a single peaked field that is
a) not connected to the border and b) close to the middle of the
ratemap</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">limit_to_one</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes a multi-peaked ratemap (ie grid cell) and returns a matrix</span>
<span class="sd">    where the multi-peaked ratemap consist of a single peaked field that is</span>
<span class="sd">    a) not connected to the border and b) close to the middle of the</span>
<span class="sd">    ratemap</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># smooth Ac more to remove local irregularities</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span> <span class="p">:</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Ac</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
    <span class="c1"># remove really small values</span>
    <span class="n">Ac</span><span class="p">[</span><span class="n">Ac</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Ac_r</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span>
        <span class="n">Ac</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">peak_idx</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span>
        <span class="n">Ac_r</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">peak_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">peak_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">peak_idx</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">peak_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">field_labels</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">Ac</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="n">peak_labels</span><span class="p">)</span>
    <span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">field_labels</span><span class="p">)</span>
    <span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nFields</span><span class="p">,</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">labelled_sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">)</span>
    <span class="n">sub_field_props</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">field_labels</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">Ac</span><span class="p">)</span>
    <span class="n">sub_field_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sub_field_size</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">sub_field</span> <span class="ow">in</span> <span class="n">sub_field_props</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">tmp2</span> <span class="o">=</span> <span class="n">Ac</span> <span class="o">&gt;</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">max_intensity</span> <span class="o">*</span> <span class="p">(</span><span class="n">prc</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">sub_field_mask</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
        <span class="n">labelled_sub_field_mask</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">sub_field</span><span class="o">.</span><span class="n">label</span>
        <span class="p">)</span>
        <span class="n">sub_field_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
        <span class="n">sub_field_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>  <span class="c1"># in bins</span>
    <span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">normd_dists</span> <span class="o">=</span> <span class="n">sub_field_centroids</span> <span class="o">-</span> <span class="n">middle</span>
    <span class="n">field_dists_from_middle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">normd_dists</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">normd_dists</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">central_field_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">field_dists_from_middle</span><span class="p">)</span>
    <span class="n">central_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">labelled_sub_field_mask</span><span class="p">[</span><span class="n">central_field_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
    <span class="c1"># collapse the labelled mask down to an 2d array</span>
    <span class="n">labelled_sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labelled_sub_field_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># clear the border</span>
    <span class="n">cleared_mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">clear_border</span><span class="p">(</span><span class="n">central_field</span><span class="p">)</span>
    <span class="c1"># check we&#39;ve still got stuff in the matrix or fail</span>
    <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cleared_mask</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No fields were detected away from edges so nothing returned&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">central_field_props</span> <span class="o">=</span> <span class="n">sub_field_props</span><span class="p">[</span><span class="n">central_field_idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">central_field_props</span><span class="p">,</span> <span class="n">central_field</span><span class="p">,</span> <span class="n">central_field_idx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.local_threshold" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">local_threshold</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Locally thresholds a ratemap to take only the surrounding prc amount
around any local peak</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">local_threshold</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Locally thresholds a ratemap to take only the surrounding prc amount</span>
<span class="sd">    around any local peak</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">nanidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Ac</span><span class="p">)</span>
    <span class="n">Ac</span><span class="p">[</span><span class="n">nanidx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># smooth Ac more to remove local irregularities</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span> <span class="p">:</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Ac</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
    <span class="c1"># rescale the image going in to peak_local_max and cast to</span>
    <span class="c1"># integer dtype as there is an invert operation internally</span>
    <span class="c1"># that only works in int or bool dtypes</span>
    <span class="n">Ac_r</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span>
        <span class="n">Ac</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">peak_idx</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span>
        <span class="n">Ac_r</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">peak_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">peak_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">peak_idx</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">peak_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">field_labels</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">Ac</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="n">peak_labels</span><span class="p">)</span>
    <span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">field_labels</span><span class="p">)</span>
    <span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nFields</span><span class="p">,</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">sub_field_props</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">field_labels</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">Ac</span><span class="p">)</span>
    <span class="n">sub_field_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sub_field_size</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">sub_field</span> <span class="ow">in</span> <span class="n">sub_field_props</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">tmp2</span> <span class="o">=</span> <span class="n">Ac</span> <span class="o">&gt;</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">max_intensity</span> <span class="o">*</span> <span class="p">(</span><span class="n">prc</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">sub_field_mask</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
        <span class="n">sub_field_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
        <span class="n">sub_field_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>  <span class="c1"># in bins</span>
    <span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">A_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">A_out</span><span class="p">[</span><span class="n">sub_field_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">sub_field_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>
    <span class="n">A_out</span><span class="p">[</span><span class="n">nanidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">A_out</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.partitionFields" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">partitionFields</span><span class="p">(</span><span class="n">binned_data</span><span class="p">,</span> <span class="n">field_threshold_percent</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">field_rate_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">area_threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Partitions fields.</p>
<p>Partitions spikes into fields by finding the watersheds around the
peaks of a super-smoothed ratemap</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>binned_data</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="ephysiopy.common.utils.BinnedData" href="#ephysiopy.common.utils.BinnedData">BinnedData</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>field_threshold_percent</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <pre><code>                        of the maximum firing rate in the field
</code></pre>
              </div>
            </td>
            <td>
                  <code>50</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>field_rate_threshold</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>0.5</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_threshold</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <pre><code>                 environment size. Default of 0.01 says a field has to be at
                 least 1% of the size of the environment i.e.
                 binned_area_width * binned_area_height to be counted as a field
</code></pre>
              </div>
            </td>
            <td>
                  <code>0.01</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[np.ndarray] - including:</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>peaksXY (array_like): The xy coordinates of the peak rates in
each field
peaksRate (array_like): The peak rates in peaksXY
labels (numpy.ndarray): An array of the labels corresponding to
each field (starting  1)
rmap (numpy.ndarray): The ratemap of the tetrode / cluster</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">partitionFields</span><span class="p">(</span>
    <span class="n">binned_data</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span>
    <span class="n">field_threshold_percent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="n">field_rate_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">area_threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Partitions fields.</span>

<span class="sd">    Partitions spikes into fields by finding the watersheds around the</span>
<span class="sd">    peaks of a super-smoothed ratemap</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binned_data (BinnedData) - an instance of ephysiopy.common.utils.BinnedData</span>
<span class="sd">    field_threshold_percent (int) - removes pixels in a field that fall below this percent</span>
<span class="sd">                                    of the maximum firing rate in the field</span>
<span class="sd">    field_rate_threshold (float) - anything below this firing rate in Hz threshold is set to 0</span>
<span class="sd">    area_threshold (float) - defines the minimum field size as a proportion of the</span>
<span class="sd">                             environment size. Default of 0.01 says a field has to be at</span>
<span class="sd">                             least 1% of the size of the environment i.e.</span>
<span class="sd">                             binned_area_width * binned_area_height to be counted as a field</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[np.ndarray] - including:</span>
<span class="sd">        peaksXY (array_like): The xy coordinates of the peak rates in</span>
<span class="sd">        each field</span>
<span class="sd">        peaksRate (array_like): The peak rates in peaksXY</span>
<span class="sd">        labels (numpy.ndarray): An array of the labels corresponding to</span>
<span class="sd">        each field (starting  1)</span>
<span class="sd">        rmap (numpy.ndarray): The ratemap of the tetrode / cluster</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ye</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">bin_edges</span>
    <span class="n">rmap</span> <span class="o">=</span> <span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># start image processing:</span>
    <span class="c1"># Usually the binned_data has a large number of bins which potentially</span>
    <span class="c1"># leaves lots of &quot;holes&quot; in the ratemap (nans) as there will be lots of</span>
    <span class="c1"># positions that aren&#39;t sampled. Get over this by preserving areas outside</span>
    <span class="c1"># the sampled area as nans whilst filling in the nans that live within the</span>
    <span class="c1"># receptive fields</span>
    <span class="n">rmap_filled</span> <span class="o">=</span> <span class="n">infill_ratemap</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span>
    <span class="c1"># get the labels</span>
    <span class="c1"># binarise the ratemap so that anything above field_rate_threshold is set to 1</span>
    <span class="c1"># and anything below to 0</span>
    <span class="n">rmap_to_label</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rmap_filled</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">rmap_to_label</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmap_filled</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rmap_to_label</span><span class="p">[</span><span class="n">rmap_to_label</span> <span class="o">&gt;</span> <span class="n">field_rate_threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rmap_to_label</span><span class="p">[</span><span class="n">rmap_to_label</span> <span class="o">&lt;</span> <span class="n">field_rate_threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">rmap_to_label</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># labels is now a labelled int array from 0 to however many fields have</span>
    <span class="c1"># been detected</span>
    <span class="c1"># Get the coordinates of the peak firing rate within each firing field...</span>
    <span class="n">fieldId</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">fieldId</span> <span class="o">=</span> <span class="n">fieldId</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span>
    <span class="n">peakCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">ndi</span><span class="o">.</span><span class="n">maximum_position</span><span class="p">(</span><span class="n">rmap_filled</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">fieldId</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># ... and convert these to actual x-y coordinates wrt to the position data</span>
    <span class="n">peaksXY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xe</span><span class="p">[</span><span class="n">peakCoords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">ye</span><span class="p">[</span><span class="n">peakCoords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]))</span>

    <span class="c1"># TODO: this labeled_comprehension is not working too well for fields that</span>
    <span class="c1"># have a fairly uniform firing rate distribution across them (using np.nanmax</span>
    <span class="c1"># in the function fn defined for use in the labeled_comprehension)</span>
    <span class="c1"># or those that have nicely gaussian shaped fields (which was using np.nanmedian)</span>
    <span class="c1"># find the peak rate at each of the centre of the detected fields to</span>
    <span class="c1"># subsequently threshold the field at some fraction of the peak value</span>
    <span class="c1"># use a labeled_comprehension to do this</span>

    <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pos</span><span class="p">[</span><span class="n">val</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">field_threshold_percent</span> <span class="o">/</span> <span class="mi">100</span><span class="p">))]</span>

    <span class="c1">#</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">labeled_comprehension</span><span class="p">(</span>
        <span class="n">rmap_filled</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># breakpoint()</span>
    <span class="n">labels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">min_field_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">area_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># breakpoint()</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_field_size</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span>
    <span class="p">)</span>
    <span class="c1"># relable the fields</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">relabel_sequential</span><span class="p">(</span><span class="n">labels</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># re-calculate the peakCoords array as we may have removed some</span>
    <span class="c1"># objects</span>
    <span class="n">fieldId</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">fieldId</span> <span class="o">=</span> <span class="n">fieldId</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span>
    <span class="c1"># breakpoint()</span>
    <span class="n">peakCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">ndi</span><span class="o">.</span><span class="n">maximum_position</span><span class="p">(</span><span class="n">rmap_filled</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">fieldId</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">peaksXY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xe</span><span class="p">[</span><span class="n">peakCoords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">ye</span><span class="p">[</span><span class="n">peakCoords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]))</span>
    <span class="n">peakRates</span> <span class="o">=</span> <span class="n">rmap_filled</span><span class="p">[</span><span class="n">peakCoords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">peakCoords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="n">peakLabels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">peakCoords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">peakCoords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="n">peaksXY</span> <span class="o">=</span> <span class="n">peaksXY</span><span class="p">[:,</span> <span class="n">peakLabels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">peaksRate</span> <span class="o">=</span> <span class="n">peakRates</span><span class="p">[</span><span class="n">peakLabels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">peaksXY</span><span class="p">,</span> <span class="n">peaksRate</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">rmap_filled</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.skaggs_info" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">skaggs_info</span><span class="p">(</span><span class="n">ratemap</span><span class="p">,</span> <span class="n">dwelltimes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates Skaggs information measure</p>
<p>Args:
    ratemap (array_like): The binned up ratemap
    dwelltimes (array_like): Must be same size as ratemap</p>
<p>Returns:
    bits_per_spike (float): Skaggs information score</p>
<p>Notes:
    THIS DATA SHOULD UNDERGO ADAPTIVE BINNING
    See getAdaptiveMap() in binning class</p>
<pre><code>Returns Skaggs et al's estimate of spatial information
in bits per spike:

.. math:: I = sum_{x} p(x).r(x).log(r(x)/r)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1880</span>
<span class="normal">1881</span>
<span class="normal">1882</span>
<span class="normal">1883</span>
<span class="normal">1884</span>
<span class="normal">1885</span>
<span class="normal">1886</span>
<span class="normal">1887</span>
<span class="normal">1888</span>
<span class="normal">1889</span>
<span class="normal">1890</span>
<span class="normal">1891</span>
<span class="normal">1892</span>
<span class="normal">1893</span>
<span class="normal">1894</span>
<span class="normal">1895</span>
<span class="normal">1896</span>
<span class="normal">1897</span>
<span class="normal">1898</span>
<span class="normal">1899</span>
<span class="normal">1900</span>
<span class="normal">1901</span>
<span class="normal">1902</span>
<span class="normal">1903</span>
<span class="normal">1904</span>
<span class="normal">1905</span>
<span class="normal">1906</span>
<span class="normal">1907</span>
<span class="normal">1908</span>
<span class="normal">1909</span>
<span class="normal">1910</span>
<span class="normal">1911</span>
<span class="normal">1912</span>
<span class="normal">1913</span>
<span class="normal">1914</span>
<span class="normal">1915</span>
<span class="normal">1916</span>
<span class="normal">1917</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">skaggs_info</span><span class="p">(</span><span class="n">ratemap</span><span class="p">,</span> <span class="n">dwelltimes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates Skaggs information measure</span>

<span class="sd">    Args:</span>
<span class="sd">        ratemap (array_like): The binned up ratemap</span>
<span class="sd">        dwelltimes (array_like): Must be same size as ratemap</span>

<span class="sd">    Returns:</span>
<span class="sd">        bits_per_spike (float): Skaggs information score</span>

<span class="sd">    Notes:</span>
<span class="sd">        THIS DATA SHOULD UNDERGO ADAPTIVE BINNING</span>
<span class="sd">        See getAdaptiveMap() in binning class</span>

<span class="sd">        Returns Skaggs et al&#39;s estimate of spatial information</span>
<span class="sd">        in bits per spike:</span>

<span class="sd">        .. math:: I = sum_{x} p(x).r(x).log(r(x)/r)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sample_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sample_rate&quot;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>

    <span class="n">dwelltimes</span> <span class="o">=</span> <span class="n">dwelltimes</span> <span class="o">/</span> <span class="n">sample_rate</span>  <span class="c1"># assumed sample rate of 50Hz</span>
    <span class="k">if</span> <span class="n">ratemap</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ratemap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ratemap</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ratemap</span><span class="p">)),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">dwelltimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dwelltimes</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dwelltimes</span><span class="p">)),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dwelltimes</span><span class="p">)</span>
    <span class="n">meanrate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">ratemap</span> <span class="o">*</span> <span class="n">dwelltimes</span><span class="p">)</span> <span class="o">/</span> <span class="n">duration</span>
    <span class="k">if</span> <span class="n">meanrate</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">bits_per_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">bits_per_spike</span>
    <span class="n">p_x</span> <span class="o">=</span> <span class="n">dwelltimes</span> <span class="o">/</span> <span class="n">duration</span>
    <span class="n">p_r</span> <span class="o">=</span> <span class="n">ratemap</span> <span class="o">/</span> <span class="n">meanrate</span>
    <span class="n">dum</span> <span class="o">=</span> <span class="n">p_x</span> <span class="o">*</span> <span class="n">ratemap</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">dum</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">bits_per_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dum</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p_r</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>
    <span class="n">bits_per_spike</span> <span class="o">=</span> <span class="n">bits_per_spike</span> <span class="o">/</span> <span class="n">meanrate</span>
    <span class="k">return</span> <span class="n">bits_per_spike</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.fieldcalcs.spatial_sparsity" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">spatial_sparsity</span><span class="p">(</span><span class="n">rate_map</span><span class="p">,</span> <span class="n">pos_map</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates the spatial sparsity of a rate map as defined by
Markus et al (1994)</p>
<p>For example, a sparsity score of 0.10 indicates that the cell fired on
10% of the maze surface</p>
<p>Args:
    rate_map (np.ndarray): The rate map
    pos_map (np.ndarray): The occupancy map</p>
<p>Returns:
    float: The spatial sparsity of the rate map</p>
<p>References:
    Markus, E.J., Barnes, C.A., McNaughton, B.L., Gladden, V.L. &amp;
    Skaggs, W.E. Spatial information content and reliability of
    hippocampal CA1 neurons: effects of visual input. Hippocampus
    4, 410421 (1994).</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/fieldcalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1734</span>
<span class="normal">1735</span>
<span class="normal">1736</span>
<span class="normal">1737</span>
<span class="normal">1738</span>
<span class="normal">1739</span>
<span class="normal">1740</span>
<span class="normal">1741</span>
<span class="normal">1742</span>
<span class="normal">1743</span>
<span class="normal">1744</span>
<span class="normal">1745</span>
<span class="normal">1746</span>
<span class="normal">1747</span>
<span class="normal">1748</span>
<span class="normal">1749</span>
<span class="normal">1750</span>
<span class="normal">1751</span>
<span class="normal">1752</span>
<span class="normal">1753</span>
<span class="normal">1754</span>
<span class="normal">1755</span>
<span class="normal">1756</span>
<span class="normal">1757</span>
<span class="normal">1758</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">spatial_sparsity</span><span class="p">(</span><span class="n">rate_map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pos_map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the spatial sparsity of a rate map as defined by</span>
<span class="sd">    Markus et al (1994)</span>

<span class="sd">    For example, a sparsity score of 0.10 indicates that the cell fired on</span>
<span class="sd">    10% of the maze surface</span>

<span class="sd">    Args:</span>
<span class="sd">        rate_map (np.ndarray): The rate map</span>
<span class="sd">        pos_map (np.ndarray): The occupancy map</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The spatial sparsity of the rate map</span>

<span class="sd">    References:</span>
<span class="sd">        Markus, E.J., Barnes, C.A., McNaughton, B.L., Gladden, V.L. &amp;</span>
<span class="sd">        Skaggs, W.E. Spatial information content and reliability of</span>
<span class="sd">        hippocampal CA1 neurons: effects of visual input. Hippocampus</span>
<span class="sd">        4, 410421 (1994).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p_i</span> <span class="o">=</span> <span class="n">pos_map</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pos_map</span><span class="p">)</span>
    <span class="n">sparsity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">p_i</span> <span class="o">*</span> <span class="n">rate_map</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">p_i</span> <span class="o">*</span> <span class="n">rate_map</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sparsity</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="phase-coding">Phase coding</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.common.phasecoding"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.phasecoding.phasePrecession2D" class="doc doc-heading">
            <code>phasePrecession2D</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Performs phase precession analysis for single unit data</p>
<p>Mostly a total rip-off of code written by Ali Jeewajee for his paper on
2D phase precession in place and grid cells [1]_</p>
<p>.. [1] Jeewajee A, Barry C, Douchamps V, Manson D, Lever C, Burgess N.
    Theta phase precession of grid and place cell firing in open
    environments.
    Philos Trans R Soc Lond B Biol Sci. 2013 Dec 23;369(1635):20120532.
    doi: 10.1098/rstb.2012.0532.</p>
<p>Args:
    lfp_sig (np.array): The LFP signal against which cells might precess...
    lfp_fs (int): The sampling frequency of the LFP signal
    xy (np.array): The position data as 2 x num_position_samples
    spike_ts (np.array): The times in samples at which the cell fired
    pos_ts (np.array): The times in samples at which position was captured
    pp_config (dict): Contains parameters for running the analysis.
        See phase_precession_config dict in ephysiopy.common.eegcalcs</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 413</span>
<span class="normal"> 414</span>
<span class="normal"> 415</span>
<span class="normal"> 416</span>
<span class="normal"> 417</span>
<span class="normal"> 418</span>
<span class="normal"> 419</span>
<span class="normal"> 420</span>
<span class="normal"> 421</span>
<span class="normal"> 422</span>
<span class="normal"> 423</span>
<span class="normal"> 424</span>
<span class="normal"> 425</span>
<span class="normal"> 426</span>
<span class="normal"> 427</span>
<span class="normal"> 428</span>
<span class="normal"> 429</span>
<span class="normal"> 430</span>
<span class="normal"> 431</span>
<span class="normal"> 432</span>
<span class="normal"> 433</span>
<span class="normal"> 434</span>
<span class="normal"> 435</span>
<span class="normal"> 436</span>
<span class="normal"> 437</span>
<span class="normal"> 438</span>
<span class="normal"> 439</span>
<span class="normal"> 440</span>
<span class="normal"> 441</span>
<span class="normal"> 442</span>
<span class="normal"> 443</span>
<span class="normal"> 444</span>
<span class="normal"> 445</span>
<span class="normal"> 446</span>
<span class="normal"> 447</span>
<span class="normal"> 448</span>
<span class="normal"> 449</span>
<span class="normal"> 450</span>
<span class="normal"> 451</span>
<span class="normal"> 452</span>
<span class="normal"> 453</span>
<span class="normal"> 454</span>
<span class="normal"> 455</span>
<span class="normal"> 456</span>
<span class="normal"> 457</span>
<span class="normal"> 458</span>
<span class="normal"> 459</span>
<span class="normal"> 460</span>
<span class="normal"> 461</span>
<span class="normal"> 462</span>
<span class="normal"> 463</span>
<span class="normal"> 464</span>
<span class="normal"> 465</span>
<span class="normal"> 466</span>
<span class="normal"> 467</span>
<span class="normal"> 468</span>
<span class="normal"> 469</span>
<span class="normal"> 470</span>
<span class="normal"> 471</span>
<span class="normal"> 472</span>
<span class="normal"> 473</span>
<span class="normal"> 474</span>
<span class="normal"> 475</span>
<span class="normal"> 476</span>
<span class="normal"> 477</span>
<span class="normal"> 478</span>
<span class="normal"> 479</span>
<span class="normal"> 480</span>
<span class="normal"> 481</span>
<span class="normal"> 482</span>
<span class="normal"> 483</span>
<span class="normal"> 484</span>
<span class="normal"> 485</span>
<span class="normal"> 486</span>
<span class="normal"> 487</span>
<span class="normal"> 488</span>
<span class="normal"> 489</span>
<span class="normal"> 490</span>
<span class="normal"> 491</span>
<span class="normal"> 492</span>
<span class="normal"> 493</span>
<span class="normal"> 494</span>
<span class="normal"> 495</span>
<span class="normal"> 496</span>
<span class="normal"> 497</span>
<span class="normal"> 498</span>
<span class="normal"> 499</span>
<span class="normal"> 500</span>
<span class="normal"> 501</span>
<span class="normal"> 502</span>
<span class="normal"> 503</span>
<span class="normal"> 504</span>
<span class="normal"> 505</span>
<span class="normal"> 506</span>
<span class="normal"> 507</span>
<span class="normal"> 508</span>
<span class="normal"> 509</span>
<span class="normal"> 510</span>
<span class="normal"> 511</span>
<span class="normal"> 512</span>
<span class="normal"> 513</span>
<span class="normal"> 514</span>
<span class="normal"> 515</span>
<span class="normal"> 516</span>
<span class="normal"> 517</span>
<span class="normal"> 518</span>
<span class="normal"> 519</span>
<span class="normal"> 520</span>
<span class="normal"> 521</span>
<span class="normal"> 522</span>
<span class="normal"> 523</span>
<span class="normal"> 524</span>
<span class="normal"> 525</span>
<span class="normal"> 526</span>
<span class="normal"> 527</span>
<span class="normal"> 528</span>
<span class="normal"> 529</span>
<span class="normal"> 530</span>
<span class="normal"> 531</span>
<span class="normal"> 532</span>
<span class="normal"> 533</span>
<span class="normal"> 534</span>
<span class="normal"> 535</span>
<span class="normal"> 536</span>
<span class="normal"> 537</span>
<span class="normal"> 538</span>
<span class="normal"> 539</span>
<span class="normal"> 540</span>
<span class="normal"> 541</span>
<span class="normal"> 542</span>
<span class="normal"> 543</span>
<span class="normal"> 544</span>
<span class="normal"> 545</span>
<span class="normal"> 546</span>
<span class="normal"> 547</span>
<span class="normal"> 548</span>
<span class="normal"> 549</span>
<span class="normal"> 550</span>
<span class="normal"> 551</span>
<span class="normal"> 552</span>
<span class="normal"> 553</span>
<span class="normal"> 554</span>
<span class="normal"> 555</span>
<span class="normal"> 556</span>
<span class="normal"> 557</span>
<span class="normal"> 558</span>
<span class="normal"> 559</span>
<span class="normal"> 560</span>
<span class="normal"> 561</span>
<span class="normal"> 562</span>
<span class="normal"> 563</span>
<span class="normal"> 564</span>
<span class="normal"> 565</span>
<span class="normal"> 566</span>
<span class="normal"> 567</span>
<span class="normal"> 568</span>
<span class="normal"> 569</span>
<span class="normal"> 570</span>
<span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">phasePrecession2D</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs phase precession analysis for single unit data</span>

<span class="sd">    Mostly a total rip-off of code written by Ali Jeewajee for his paper on</span>
<span class="sd">    2D phase precession in place and grid cells [1]_</span>

<span class="sd">    .. [1] Jeewajee A, Barry C, Douchamps V, Manson D, Lever C, Burgess N.</span>
<span class="sd">        Theta phase precession of grid and place cell firing in open</span>
<span class="sd">        environments.</span>
<span class="sd">        Philos Trans R Soc Lond B Biol Sci. 2013 Dec 23;369(1635):20120532.</span>
<span class="sd">        doi: 10.1098/rstb.2012.0532.</span>

<span class="sd">    Args:</span>
<span class="sd">        lfp_sig (np.array): The LFP signal against which cells might precess...</span>
<span class="sd">        lfp_fs (int): The sampling frequency of the LFP signal</span>
<span class="sd">        xy (np.array): The position data as 2 x num_position_samples</span>
<span class="sd">        spike_ts (np.array): The times in samples at which the cell fired</span>
<span class="sd">        pos_ts (np.array): The times in samples at which position was captured</span>
<span class="sd">        pp_config (dict): Contains parameters for running the analysis.</span>
<span class="sd">            See phase_precession_config dict in ephysiopy.common.eegcalcs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lfp_sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lfp_fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">xy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">spike_ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pos_ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pp_config</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">phase_precession_config</span><span class="p">,</span>
        <span class="n">regressors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Set up the parameters</span>
        <span class="c1"># this sets a bunch of member attributes from the pp_config dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_xy</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_config</span><span class="p">(</span><span class="n">pp_config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_ts</span> <span class="o">=</span> <span class="n">pos_ts</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_regressors</span><span class="p">(</span><span class="n">regressors</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">regressor</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conf</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Process the EEG data a bit...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eeg</span> <span class="o">=</span> <span class="n">lfp_sig</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">LFPOscillations</span><span class="p">(</span><span class="n">lfp_sig</span><span class="p">,</span> <span class="n">lfp_fs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_theta</span> <span class="o">=</span> <span class="n">pp_config</span><span class="p">[</span><span class="s2">&quot;min_theta&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_theta</span> <span class="o">=</span> <span class="n">pp_config</span><span class="p">[</span><span class="s2">&quot;max_theta&quot;</span><span class="p">]</span>
        <span class="n">filt_sig</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span>
            <span class="n">lfp_sig</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_theta</span><span class="p">],</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filteredEEG</span> <span class="o">=</span> <span class="n">filt_sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phaseAdj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_position</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppm</span><span class="p">,</span> <span class="n">cm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xy_2_cm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_rate_map</span><span class="p">()</span>

        <span class="n">spk_times_in_pos_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSpikePosIndices</span><span class="p">(</span><span class="n">spike_ts</span><span class="p">)</span>
        <span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spk_times_in_pos_samples</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_ts</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times_in_pos_samples</span> <span class="o">=</span> <span class="n">spk_times_in_pos_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_weights</span> <span class="o">=</span> <span class="n">spk_weights</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spike_ts</span> <span class="o">=</span> <span class="n">spike_ts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_ts</span>

    <span class="nd">@pos_ts</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pos_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_ts</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spike_eeg_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_ts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spike_pos_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_ts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_regressors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a dict to hold the stats values for</span>
<span class="sd">        each regressor</span>
<span class="sd">        Default regressors are:</span>
<span class="sd">            &quot;spk_numWithinRun&quot;,</span>
<span class="sd">            &quot;pos_exptdRate_cum&quot;,</span>
<span class="sd">            &quot;pos_instFR&quot;,</span>
<span class="sd">            &quot;pos_timeInRun&quot;,</span>
<span class="sd">            &quot;pos_d_cum&quot;,</span>
<span class="sd">            &quot;pos_d_meanDir&quot;,</span>
<span class="sd">            &quot;pos_d_currentdir&quot;,</span>
<span class="sd">            &quot;spk_thetaBatchLabelInRun&quot;</span>

<span class="sd">        NB: The regressors have differing sizes of &#39;values&#39; depending on the</span>
<span class="sd">        type of the regressor:</span>
<span class="sd">        spk_* - integer values of the spike number within a run or the theta batch</span>
<span class="sd">                in a run, so has a length equal to the number of spikes collected</span>
<span class="sd">        pos_* - a bincount of some type so equal to the number of position samples</span>
<span class="sd">                collected</span>
<span class="sd">        eeg_* - only one at present, the instantaneous firing rate binned into the</span>
<span class="sd">                number of eeg samples so equal to that in length</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reg_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reg_keys</span> <span class="o">=</span> <span class="n">all_regressors</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">regressor</span> <span class="ow">in</span> <span class="n">all_regressors</span> <span class="k">for</span> <span class="n">regressor</span> <span class="ow">in</span> <span class="n">reg_keys</span><span class="p">])</span>

        <span class="c1"># Create a dict to hold the stats values for</span>
        <span class="c1"># each regressor</span>
        <span class="n">stats_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span>
            <span class="s2">&quot;pha&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span>
            <span class="s2">&quot;slope&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="s2">&quot;intercept&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="s2">&quot;cor&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="s2">&quot;cor_boot&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="s2">&quot;p_shuffled&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="s2">&quot;ci&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="s2">&quot;reg&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">stats_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">)</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">]</span> <span class="k">for</span> <span class="n">regressor</span> <span class="ow">in</span> <span class="n">reg_keys</span><span class="p">]</span>
        <span class="c1"># each of the regressors in regressor_keys is a key with a value</span>
        <span class="c1"># of stats_dict</span>

    <span class="k">def</span> <span class="nf">update_regressor_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># Check whether values is a masked array and if not make it one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">update_regressor_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="c1"># Mask entries in the &#39;values&#39; and &#39;pha&#39; arrays of the relevant regressor</span>
        <span class="nb">breakpoint</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_regressors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_regressor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pp_config</span><span class="p">):</span>
        <span class="p">[</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">pp_config</span><span class="p">[</span><span class="n">attribute</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">pp_config</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">update_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cm</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">PosCalcsGeneric</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orig_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orig_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
            <span class="n">ppm</span><span class="o">=</span><span class="n">ppm</span><span class="p">,</span>
            <span class="n">convert2cm</span><span class="o">=</span><span class="n">cm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">P</span><span class="o">.</span><span class="n">postprocesspos</span><span class="p">(</span><span class="n">tracker_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;AxonaBadValue&quot;</span><span class="p">:</span> <span class="mi">1023</span><span class="p">})</span>
        <span class="c1"># ... do the ratemap creation here once</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PosData</span> <span class="o">=</span> <span class="n">P</span>

    <span class="k">def</span> <span class="nf">update_rate_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="p">,</span> <span class="n">xyInCms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xy_2_cm</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">binsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins_per_cm</span>
        <span class="n">R</span><span class="o">.</span><span class="n">smooth_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_smoothing_kernel_len</span>
        <span class="n">R</span><span class="o">.</span><span class="n">ppm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span> <span class="o">=</span> <span class="n">R</span>  <span class="c1"># this will be used a fair bit below</span>

    <span class="k">def</span> <span class="nf">getSpikePosIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">pos_times</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;pos_ts&quot;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pos_times</span><span class="p">,</span> <span class="n">spk_times</span><span class="p">)</span>
        <span class="n">idx</span><span class="p">[</span><span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_times</span><span class="p">)]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_times</span><span class="p">)]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">performRegression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper function for doing the actual regression which has multiple</span>
<span class="sd">        stages.</span>

<span class="sd">        Specifically here we partition fields into sub-fields, get a bunch of</span>
<span class="sd">        information about the position, spiking and theta data and then</span>
<span class="sd">        do the actual regression.</span>

<span class="sd">        Args:</span>
<span class="sd">            tetrode (int): The tetrode to examine</span>
<span class="sd">            cluster (int): The cluster to examine</span>
<span class="sd">            laserEvents (array_like, optional): The on times for laser events</span>
<span class="sd">            if present. Default is None</span>
<span class="sd">        Valid keyword args:</span>
<span class="sd">            plot (bool): whether to plot the results of field partitions, the regression(s)</span>
<span class="sd">                etc</span>
<span class="sd">        See Also:</span>
<span class="sd">            ephysiopy.common.eegcalcs.phasePrecession.partitionFields()</span>
<span class="sd">            ephysiopy.common.eegcalcs.phasePrecession.getPosProps()</span>
<span class="sd">            ephysiopy.common.eegcalcs.phasePrecession.getThetaProps()</span>
<span class="sd">            ephysiopy.common.eegcalcs.phasePrecession.getSpikeProps()</span>
<span class="sd">            ephysiopy.common.eegcalcs.phasePrecession._ppRegress()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">do_plot</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Partition fields - comes from ephysiopy.common.fieldca</span>
        <span class="n">binned_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_weights</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partitionFields</span><span class="p">(</span>
            <span class="n">binned_data</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">field_threshold_percent</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">field_threshold</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># split into runs</span>
        <span class="n">field_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPosProps</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="c1"># self.posdict = posD</span>
        <span class="c1"># self.rundict = runD</span>

        <span class="c1"># get theta cycles, amplitudes, phase etc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getThetaProps</span><span class="p">(</span><span class="n">field_properties</span><span class="p">)</span>
        <span class="c1"># TODO: next: getSpikeProps(field_properties)</span>
        <span class="c1"># the fields that are set within getSpikeProps() I think can be added</span>
        <span class="c1"># to the individual runs within the FieldProps instance</span>
        <span class="c1"># spkCount is just spikes binned wrt eeg timebase</span>
        <span class="c1">#</span>

        <span class="c1"># get the indices of spikes for various metrics such as</span>
        <span class="c1"># theta cycle, run etc</span>
        <span class="n">spkD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSpikeProps</span><span class="p">(</span><span class="n">field_properties</span><span class="p">)</span>
        <span class="c1"># self.spkdict = spkD</span>
        <span class="c1"># at this point the &#39;values&#39; and &#39;pha&#39; arrays in the regressors dict are all</span>
        <span class="c1"># npos elements long and are masked arrays. keep as masked arrays and just modify the</span>
        <span class="c1"># masks instead of truncating the data</span>
        <span class="c1"># Do the regressions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppRegress</span><span class="p">(</span><span class="n">spkD</span><span class="p">)</span>

        <span class="c1"># Plot the results if asked</span>
        <span class="k">if</span> <span class="n">do_plot</span><span class="p">:</span>
            <span class="n">n_regressors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_regressors</span><span class="p">())</span>
            <span class="n">n_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_regressors</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_regressors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s2">&quot;Regression results&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">flatten_list</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_regressors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ra</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_regressors</span><span class="p">(),</span> <span class="n">ax</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plotRegressor</span><span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">getPosProps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the output of partitionFields and returns vectors the same</span>
<span class="sd">        length as pos.</span>

<span class="sd">        Args:</span>
<span class="sd">            tetrode, cluster (int): The tetrode / cluster to examine</span>
<span class="sd">            peaksXY (array_like): The x-y coords of the peaks in the ratemap</span>
<span class="sd">            laserEvents (array_like): The position indices of on events</span>
<span class="sd">            (laser on)</span>

<span class="sd">        Returns:</span>
<span class="sd">            pos_dict, run_dict (dict): Contains a whole bunch of information</span>
<span class="sd">            for the whole trial and also on a run-by-run basis (run_dict).</span>
<span class="sd">            See the end of this function for all the key / value pairs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spikeTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_ts</span>  <span class="c1"># in seconds</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">xydir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">dir</span>
        <span class="c1"># spd = self.RateMap.speed</span>
        <span class="n">spkPosInd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_pos_idx</span>
        <span class="n">nPos</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">spkPosInd</span><span class="p">[</span><span class="n">spkPosInd</span> <span class="o">&gt;</span> <span class="n">nPos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nPos</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">xydir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">xydir</span><span class="p">)</span>

        <span class="n">binned_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_weights</span><span class="p">)</span>
        <span class="n">ye</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">bin_edges</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># The large number of bins combined with the super-smoothed ratemap</span>
        <span class="c1"># will lead to fields labelled with lots of small holes in. Fill those</span>
        <span class="c1"># gaps in here and calculate the perimeter of the fields based on that</span>
        <span class="c1"># labelled image</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>

        <span class="n">rmap_zeros</span> <span class="o">=</span> <span class="n">rmap</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">rmap_zeros</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmap</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">xBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xe</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">yBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ye</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">observed_spikes_in_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
            <span class="p">(</span><span class="n">spikeTS</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nPos</span>
        <span class="p">)</span>

        <span class="n">field_props</span> <span class="o">=</span> <span class="n">fieldprops</span><span class="p">(</span>
            <span class="n">labels</span><span class="p">,</span>
            <span class="n">binned_data</span><span class="p">,</span>
            <span class="n">xy</span><span class="p">,</span>
            <span class="n">observed_spikes_in_time</span><span class="p">,</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Filtering runs for min duration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_allowed_run_duration</span><span class="si">}</span><span class="s2">, speed </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_allowed_run_speed</span><span class="si">}</span><span class="s2"> and min spikes </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_spikes</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">field_props</span> <span class="o">=</span> <span class="n">filter_runs</span><span class="p">(</span>
            <span class="n">field_props</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minimum_allowed_run_duration</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minimum_allowed_run_speed</span><span class="p">,</span>
            <span class="n">min_spikes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Smooth the runs before calculating other metrics</span>
        <span class="p">[</span>
            <span class="n">f</span><span class="o">.</span><span class="n">smooth_runs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ifr_smoothing_constant</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spatial_lowpass_cutoff</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;pos_d_currentdir&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">d_currentdir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                    <span class="n">d_currentdir</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">current_direction</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_d_currentdir&quot;</span><span class="p">,</span> <span class="n">d_currentdir</span><span class="p">)</span>

        <span class="c1"># calculate the cumulative distance travelled on each run</span>
        <span class="c1"># only goes from 0-1</span>
        <span class="k">if</span> <span class="s2">&quot;pos_d_cum&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">d_cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                    <span class="n">d_cumulative</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">cumulative_distance</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_d_cum&quot;</span><span class="p">,</span> <span class="n">d_cumulative</span><span class="p">)</span>

        <span class="c1"># calculate cumulative sum of the expected normalised firing rate</span>
        <span class="c1"># only goes from 0-1</span>
        <span class="c1"># NB I&#39;m not sure why this is called expected rate as there is nothing</span>
        <span class="c1"># about firing rate in this just the accumulation of rho</span>
        <span class="k">if</span> <span class="s2">&quot;pos_exptdRate_cum&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">exptd_rate_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">rmap_infilled</span> <span class="o">=</span> <span class="n">infill_ratemap</span><span class="p">(</span><span class="n">rmap</span><span class="p">)</span>
            <span class="n">exptd_rate</span> <span class="o">=</span> <span class="n">rmap_infilled</span><span class="p">[</span><span class="n">yBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># setting the sample rate to 1 here will result in firing rate being returned</span>
            <span class="c1"># not expected spike count</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                    <span class="n">exptd_rate_all</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">expected_spikes</span><span class="p">(</span><span class="n">exptd_rate</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_exptdRate_cum&quot;</span><span class="p">,</span> <span class="n">exptd_rate_all</span><span class="p">)</span>

        <span class="c1"># direction projected onto the run mean direction is just the x coord</span>
        <span class="c1"># good - remembering that xy_new is rho,phi</span>
        <span class="c1"># this might be wrong - need to check i&#39;m grabbing the right value</span>
        <span class="c1"># from FieldProps... could be rho</span>
        <span class="k">if</span> <span class="s2">&quot;pos_d_meanDir&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">d_meandir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                    <span class="n">d_meandir</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">pos_r</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_d_meanDir&quot;</span><span class="p">,</span> <span class="n">d_meandir</span><span class="p">)</span>

        <span class="c1"># smooth binned spikes to get an instantaneous firing rate</span>
        <span class="c1"># set up the smoothing kernel</span>
        <span class="c1"># all up at 1.0</span>
        <span class="k">if</span> <span class="s2">&quot;pos_instFR&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kernLenInBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ifr_kernel_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins_per_second</span><span class="p">)</span>
            <span class="n">kernSig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifr_kernel_sigma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins_per_second</span>
            <span class="n">regressor</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">kernLenInBins</span><span class="p">,</span> <span class="n">kernSig</span><span class="p">)</span>
            <span class="c1"># apply the smoothing kernel over the binned observed spikes</span>
            <span class="n">ifr</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">observed_spikes_in_time</span><span class="p">,</span> <span class="n">regressor</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
            <span class="n">inst_firing_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ifr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i_slice</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">run_slices</span><span class="p">:</span>
                    <span class="n">inst_firing_rate</span><span class="p">[</span><span class="n">i_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifr</span><span class="p">[</span><span class="n">i_slice</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_instFR&quot;</span><span class="p">,</span> <span class="n">inst_firing_rate</span><span class="p">)</span>

        <span class="c1"># find time spent within run</span>
        <span class="c1"># only goes from 0-1</span>
        <span class="k">if</span> <span class="s2">&quot;pos_timeInRun&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">time_in_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                    <span class="n">time_in_run</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">cumulative_time</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_timeInRun&quot;</span><span class="p">,</span> <span class="n">time_in_run</span><span class="p">)</span>

        <span class="c1"># mnSpd = np.concatenate([f.runs_speed for f in field_props])</span>
        <span class="c1"># centralPeripheral = np.concatenate([f.pos_xy[1] for f in field_props])</span>

        <span class="k">return</span> <span class="n">field_props</span>

    <span class="k">def</span> <span class="nf">getThetaProps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_props</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">FieldProps</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes the LFP data and inserts into each run within each field</span>
<span class="sd">        a segment of LFP data that has had its phase and amplitude extracted</span>
<span class="sd">        as well as some other metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spikeTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_ts</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">filteredEEG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filteredEEG</span>
        <span class="n">oldAmplt</span> <span class="o">=</span> <span class="n">filteredEEG</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># get indices of spikes into eeg</span>
        <span class="n">spkEEGIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_eeg_idx</span>
        <span class="n">spkCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spkEEGIdx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">))</span>
        <span class="n">spkPhase</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># unmask the valid entries</span>
        <span class="n">spkPhase</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">spkEEGIdx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">minSpikingPhase</span> <span class="o">=</span> <span class="n">getPhaseOfMinSpiking</span><span class="p">(</span><span class="n">spkPhase</span><span class="p">)</span>
        <span class="c1"># force phase to lie between 0 and 2PI</span>
        <span class="n">phaseAdj</span> <span class="o">=</span> <span class="n">fixAngle</span><span class="p">(</span>
            <span class="n">phase</span> <span class="o">-</span> <span class="n">minSpikingPhase</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_min_spike_phase</span>
        <span class="p">)</span>
        <span class="n">isNegFreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phaseAdj</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">isNegFreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isNegFreq</span><span class="p">,</span> <span class="n">isNegFreq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># get start of theta cycles as points where diff &gt; pi</span>
        <span class="n">phaseDf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phaseAdj</span><span class="p">)</span>
        <span class="n">cycleStarts</span> <span class="o">=</span> <span class="n">phaseDf</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">cycleStarts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycleStarts</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">cycleStarts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cycleStarts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">cycleStarts</span><span class="p">[</span><span class="n">isNegFreq</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">cycleLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">cycleStarts</span><span class="p">)</span>

        <span class="c1"># caculate power and find low power cycles</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">filteredEEG</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cycleTotValidPow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
            <span class="n">cycleLabel</span><span class="p">[</span><span class="o">~</span><span class="n">isNegFreq</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">power</span><span class="p">[</span><span class="o">~</span><span class="n">isNegFreq</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">cycleValidBinCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">cycleLabel</span><span class="p">[</span><span class="o">~</span><span class="n">isNegFreq</span><span class="p">])</span>
        <span class="n">cycleValidMnPow</span> <span class="o">=</span> <span class="n">cycleTotValidPow</span> <span class="o">/</span> <span class="n">cycleValidBinCount</span>
        <span class="n">powRejectThresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
            <span class="n">cycleValidMnPow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_power_percent_threshold</span>
        <span class="p">)</span>
        <span class="n">cycleHasBadPow</span> <span class="o">=</span> <span class="n">cycleValidMnPow</span> <span class="o">&lt;</span> <span class="n">powRejectThresh</span>

        <span class="c1"># find cycles too long or too short</span>
        <span class="n">allowed_theta_len</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_theta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_theta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">cycleTotBinCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">cycleLabel</span><span class="p">)</span>
        <span class="n">cycleHasBadLen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">cycleTotBinCount</span> <span class="o">&lt;</span> <span class="n">allowed_theta_len</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">cycleTotBinCount</span> <span class="o">&gt;</span> <span class="n">allowed_theta_len</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># remove data calculated as &#39;bad&#39;</span>
        <span class="n">isBadCycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">cycleHasBadLen</span><span class="p">,</span> <span class="n">cycleHasBadPow</span><span class="p">)</span>
        <span class="n">isInBadCycle</span> <span class="o">=</span> <span class="n">isBadCycle</span><span class="p">[</span><span class="n">cycleLabel</span><span class="p">]</span>
        <span class="n">isBad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">isInBadCycle</span><span class="p">,</span> <span class="n">isNegFreq</span><span class="p">)</span>
        <span class="nb">breakpoint</span><span class="p">()</span>
        <span class="c1"># TODO: above phaseAdj is being created as a Masked array with all mask values as True...</span>
        <span class="n">phaseAdj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">phaseAdj</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">isBad</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phaseAdj</span> <span class="o">=</span> <span class="n">phaseAdj</span>
        <span class="n">ampAdj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">filteredEEG</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">isBad</span><span class="p">))</span>
        <span class="n">cycleLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">cycleLabel</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">isBad</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cycleLabel</span> <span class="o">=</span> <span class="n">cycleLabel</span>
        <span class="n">spkCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spkCount</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">isBad</span><span class="p">))</span>
        <span class="c1"># Extract all the relevant values from the arrays above and</span>
        <span class="c1"># add to each run</span>
        <span class="n">lfp_to_pos_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                <span class="n">lfp_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">run</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">start</span> <span class="o">*</span> <span class="n">lfp_to_pos_ratio</span><span class="p">),</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">run</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">*</span> <span class="n">lfp_to_pos_ratio</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">spike_times</span> <span class="o">=</span> <span class="n">spikeTS</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="n">spikeTS</span> <span class="o">&gt;</span> <span class="n">lfp_slice</span><span class="o">.</span><span class="n">start</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">,</span>
                        <span class="n">spikeTS</span> <span class="o">&lt;</span> <span class="n">lfp_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">]</span>
                <span class="n">lfp_segment</span> <span class="o">=</span> <span class="n">LFPSegment</span><span class="p">(</span>
                    <span class="n">field</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                    <span class="n">run</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                    <span class="n">lfp_slice</span><span class="p">,</span>
                    <span class="n">spike_times</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eeg</span><span class="p">[</span><span class="n">lfp_slice</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filteredEEG</span><span class="p">[</span><span class="n">lfp_slice</span><span class="p">],</span>
                    <span class="n">phaseAdj</span><span class="p">[</span><span class="n">lfp_slice</span><span class="p">],</span>
                    <span class="n">ampAdj</span><span class="p">[</span><span class="n">lfp_slice</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">,</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_theta</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">run</span><span class="o">.</span><span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_segment</span>

    <span class="k">def</span> <span class="nf">getSpikeProps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_props</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># TODO: the regressor values here need updating so they are the same length</span>
        <span class="c1"># as the number of positions and masked in the correct places to maintain</span>
        <span class="c1"># consistency with the regressors added in the getPosProps method</span>
        <span class="n">spikeTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_ts</span>
        <span class="n">spkPosIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_pos_idx</span>
        <span class="n">spkEEGIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_eeg_idx</span>

        <span class="n">durations</span> <span class="o">=</span> <span class="n">flatten_list</span><span class="p">([[</span><span class="n">r</span><span class="o">.</span><span class="n">duration</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">])</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
        <span class="n">spk_counts</span> <span class="o">=</span> <span class="n">flatten_list</span><span class="p">([[</span><span class="n">r</span><span class="o">.</span><span class="n">n_spikes</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">])</span>
        <span class="n">spk_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spk_counts</span><span class="p">)</span>
        <span class="n">run_firing_rates</span> <span class="o">=</span> <span class="n">spk_counts</span> <span class="o">/</span> <span class="n">durations</span>

        <span class="n">runLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                <span class="n">runLabel</span><span class="p">[</span><span class="n">run</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">run</span><span class="o">.</span><span class="n">label</span>

        <span class="n">spkRunLabel</span> <span class="o">=</span> <span class="n">runLabel</span><span class="p">[</span><span class="n">spkPosIdx</span><span class="p">]</span>
        <span class="c1"># NB: Unlike the old way of doing this the run labels won&#39;t be</span>
        <span class="c1"># in ascending order as the runs are extracted from the fields themselves</span>
        <span class="c1"># which are basically labelled using skimage.measure.label (see partitionFields)</span>

        <span class="n">cycleLabel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycleLabel</span>
        <span class="n">thetaCycleLabel</span> <span class="o">=</span> <span class="n">cycleLabel</span><span class="p">[</span><span class="n">spkEEGIdx</span><span class="p">]</span>

        <span class="n">firstInTheta</span> <span class="o">=</span> <span class="n">thetaCycleLabel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">thetaCycleLabel</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span>
        <span class="n">firstInTheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">firstInTheta</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># lastInTheta = firstInTheta[1::]</span>
        <span class="n">numWithinRun</span> <span class="o">=</span> <span class="n">labelledCumSum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">spkRunLabel</span><span class="p">),</span> <span class="n">spkRunLabel</span><span class="p">)</span>
        <span class="n">thetaBatchLabelInRun</span> <span class="o">=</span> <span class="n">labelledCumSum</span><span class="p">(</span><span class="n">firstInTheta</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">spkRunLabel</span><span class="p">)</span>

        <span class="c1"># NB this is NOT the firing rate in pos bins but rather spikes/second</span>
        <span class="n">rateInPosBins</span> <span class="o">=</span> <span class="n">run_firing_rates</span>
        <span class="c1"># update the regressor dict from __init__ with relevant values</span>
        <span class="c1"># all up at 1.0</span>
        <span class="k">if</span> <span class="s2">&quot;spk_numWithinRun&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;spk_numWithinRun&quot;</span><span class="p">,</span> <span class="n">numWithinRun</span><span class="p">)</span>
        <span class="c1"># all up at 1.0</span>
        <span class="k">if</span> <span class="s2">&quot;spk_thetaBatchLabelInRun&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span>
                <span class="s2">&quot;spk_thetaBatchLabelInRun&quot;</span><span class="p">,</span> <span class="n">thetaBatchLabelInRun</span>
            <span class="p">)</span>
        <span class="n">spkKeys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;spikeTS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spkPosIdx&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spkEEGIdx&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spkRunLabel&quot;</span><span class="p">,</span>
            <span class="s2">&quot;thetaCycleLabel&quot;</span><span class="p">,</span>
            <span class="s2">&quot;firstInTheta&quot;</span><span class="p">,</span>
            <span class="c1"># &quot;lastInTheta&quot;,</span>
            <span class="s2">&quot;numWithinRun&quot;</span><span class="p">,</span>
            <span class="s2">&quot;thetaBatchLabelInRun&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spk_counts&quot;</span><span class="p">,</span>
            <span class="s2">&quot;run_firing_rates&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">spkDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">spkKeys</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">thiskey</span> <span class="ow">in</span> <span class="n">spkDict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">spkDict</span><span class="p">[</span><span class="n">thiskey</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">thiskey</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total spikes available for this cluster: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spikeTS</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total spikes used for analysis: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spk_counts</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spkDict</span>

    <span class="k">def</span> <span class="nf">_ppRegress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spkDict</span><span class="p">,</span> <span class="n">whichSpk</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">):</span>

        <span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phaseAdj</span>
        <span class="n">newSpkRunLabel</span> <span class="o">=</span> <span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;spkRunLabel&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># TODO: need code to deal with splitting the data based on a group of</span>
        <span class="c1"># variables</span>
        <span class="n">spkUsed</span> <span class="o">=</span> <span class="n">newSpkRunLabel</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># Calling compressed() method on spkUsed gives a boolean mask with length equal to</span>
        <span class="c1"># the number of spikes emitted by the cluster where True is a valid spike (ie it was</span>
        <span class="c1"># emitted when in a receptive field detected by the getPosProps() method above)</span>
        <span class="c1"># firstInTheta (and presumably lastInTheta) need to be the same length as</span>
        <span class="c1"># the number of pos samples - currently it&#39;s just the length of some smaller</span>
        <span class="c1"># subset of the length of the number of spikes</span>
        <span class="k">if</span> <span class="s2">&quot;first&quot;</span> <span class="ow">in</span> <span class="n">whichSpk</span><span class="p">:</span>
            <span class="n">spkUsed</span><span class="p">[</span><span class="o">~</span><span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;firstInTheta&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="s2">&quot;last&quot;</span> <span class="ow">in</span> <span class="n">whichSpk</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;lastInTheta&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;spkRunLabel&quot;</span><span class="p">]):</span>
                <span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;lastInTheta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;lastInTheta&quot;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">spkUsed</span><span class="p">[</span><span class="o">~</span><span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;lastInTheta&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">spkPosIdxUsed</span> <span class="o">=</span> <span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;spkPosIdx&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># copy self.regressors and update with spk/ pos of interest</span>
        <span class="n">regressors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># the length of the &#39;values&#39; of the regressors is dependent on the variable</span>
        <span class="c1"># so &#39;pos_&#39; regressors are vectors as long as the number of position samples</span>
        <span class="c1"># and &#39;spk_&#39; regressors are as long as the number of spikes for the current</span>
        <span class="c1"># cluster. These different length vectors need to be dealt with differently..</span>
        <span class="k">for</span> <span class="n">regressor</span> <span class="ow">in</span> <span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># breakpoint()</span>
            <span class="c1"># self.update_regressor_mask(regressor, spkPosIdxUsed)</span>
            <span class="k">if</span> <span class="n">regressor</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;spk_&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span>
                    <span class="n">regressor</span><span class="p">,</span> <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">][</span><span class="n">spkUsed</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">regressor</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;pos_&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span>
                    <span class="n">regressor</span><span class="p">,</span> <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">][</span><span class="n">spkPosIdxUsed</span><span class="p">[</span><span class="n">spkUsed</span><span class="p">]]</span>
                <span class="p">)</span>
        <span class="c1"># breakpoint()</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">[</span><span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;spkEEGIdx&quot;</span><span class="p">][</span><span class="n">spkUsed</span><span class="p">]]</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;mean&quot;</span> <span class="ow">in</span> <span class="n">whichSpk</span><span class="p">:</span>
            <span class="n">goodPhase</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
            <span class="n">cycleLabels</span> <span class="o">=</span> <span class="n">spkDict</span><span class="p">[</span><span class="s2">&quot;thetaCycleLabel&quot;</span><span class="p">][</span><span class="n">spkUsed</span><span class="p">]</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cycleLabels</span><span class="p">)</span>
            <span class="n">cycleComplexPhase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span>
                <span class="n">cycleComplexPhase</span><span class="p">,</span>
                <span class="n">cycleLabels</span><span class="p">[</span><span class="n">goodPhase</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase</span><span class="p">[</span><span class="n">goodPhase</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cycleComplexPhase</span><span class="p">)</span>
            <span class="n">spkCountPerCycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">cycleLabels</span><span class="p">[</span><span class="n">goodPhase</span><span class="p">],</span> <span class="n">minlength</span><span class="o">=</span><span class="n">sz</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">regressor</span> <span class="ow">in</span> <span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
                        <span class="n">cycleLabels</span><span class="p">[</span><span class="n">goodPhase</span><span class="p">],</span>
                        <span class="n">weights</span><span class="o">=</span><span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">][</span><span class="n">goodPhase</span><span class="p">],</span>
                        <span class="n">minlength</span><span class="o">=</span><span class="n">sz</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="o">/</span> <span class="n">spkCountPerCycle</span>
                <span class="p">)</span>

        <span class="n">goodPhase</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">regressor</span> <span class="ow">in</span> <span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Doing regression: </span><span class="si">{</span><span class="n">regressor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">goodRegressor</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">goodRegressor</span><span class="p">):</span>
                <span class="c1"># breakpoint()</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">][</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">goodRegressor</span><span class="p">,</span> <span class="n">goodPhase</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">pha</span> <span class="o">=</span> <span class="n">phase</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">goodRegressor</span><span class="p">,</span> <span class="n">goodPhase</span><span class="p">)]</span>
                <span class="c1"># TODO: all the pha values are masked. make sure only the relevant ones are!</span>
                <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;slope&quot;</span><span class="p">],</span> <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">circRegress</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">pha</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;pha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pha</span>
                <span class="n">mnx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">-</span> <span class="n">mnx</span>
                <span class="n">mxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">/</span> <span class="n">mxx</span>
                <span class="c1"># problem regressors = instFR, pos_d_cum</span>
                <span class="c1"># breakpoint()</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;slope&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">reg</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">rho</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho_boot</span><span class="p">,</span> <span class="n">p_shuff</span><span class="p">,</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">circCircCorrTLinear</span><span class="p">(</span>
                    <span class="n">theta</span><span class="p">,</span> <span class="n">pha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span>
                <span class="p">)</span>
                <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;reg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span>
                <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;cor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
                <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;cor_boot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho_boot</span>
                <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;p_shuffled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_shuff</span>
                <span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;ci&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reg_phase</span> <span class="o">=</span> <span class="n">phase</span>
        <span class="k">return</span> <span class="n">regressors</span>

    <span class="k">def</span> <span class="nf">plotRegressor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regressor</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">regressor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;values&quot;</span><span class="p">]</span>
        <span class="n">pha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_phase</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;slope&quot;</span><span class="p">]</span>
        <span class="n">intercept</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mm</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">slope</span> <span class="o">+</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">slope</span> <span class="o">+</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">m</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">pha</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;regressor.&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">xtick_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">xtick_locs</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">xtick_locs</span><span class="p">)))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;-4&quot;</span><span class="p">,</span> <span class="s2">&quot;-2&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">title_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">regressor</span><span class="si">}</span><span class="s2"> vs phase: slope = </span><span class="si">{</span><span class="n">slope</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, </span><span class="se">\n</span><span class="s2">intercept = </span><span class="si">{</span><span class="n">intercept</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, p_shuffled = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">][</span><span class="s1">&#39;p_shuffled&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title_str</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">subaxis_title_fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Phase&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">subaxis_title_fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Normalised position&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">subaxis_title_fontsize</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">plotPPRegression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regressorDict</span><span class="p">,</span> <span class="n">regressor2plot</span><span class="o">=</span><span class="s2">&quot;pos_d_cum&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLFPPhaseValsForSpikeTS</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times_in_pos_samples</span><span class="p">]</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.common</span> <span class="kn">import</span> <span class="n">fieldcalcs</span>

        <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_weights</span><span class="p">)</span>
        <span class="n">xe</span><span class="p">,</span> <span class="n">ye</span> <span class="o">=</span> <span class="n">rmap</span><span class="o">.</span><span class="n">bin_edges</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">fieldcalcs</span><span class="o">.</span><span class="n">field_lims</span><span class="p">(</span><span class="n">rmap</span><span class="p">)</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">rmap</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xInField</span> <span class="o">=</span> <span class="n">xe</span><span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xInField</span><span class="p">),</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xInField</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="c1"># keep x between -1 and +1</span>
        <span class="n">mnx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xn</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mnx</span>
        <span class="n">mxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xn</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xn</span> <span class="o">/</span> <span class="n">mxx</span>
        <span class="c1"># keep tn between 0 and 2pi</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span> <span class="o">=</span> <span class="n">circRegress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">rho</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho_boot</span><span class="p">,</span> <span class="n">p_shuff</span><span class="p">,</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">circCircCorrTLinear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;regressor&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;regressor&quot;</span><span class="p">)</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mm</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">slope</span> <span class="o">+</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">slope</span> <span class="o">+</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">m</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;slope&quot;</span><span class="p">:</span> <span class="n">slope</span><span class="p">,</span>
            <span class="s2">&quot;intercept&quot;</span><span class="p">:</span> <span class="n">intercept</span><span class="p">,</span>
            <span class="s2">&quot;rho&quot;</span><span class="p">:</span> <span class="n">rho</span><span class="p">,</span>
            <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">,</span>
            <span class="s2">&quot;rho_boot&quot;</span><span class="p">:</span> <span class="n">rho_boot</span><span class="p">,</span>
            <span class="s2">&quot;p_shuff&quot;</span><span class="p">:</span> <span class="n">p_shuff</span><span class="p">,</span>
            <span class="s2">&quot;ci&quot;</span><span class="p">:</span> <span class="n">ci</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">getLFPPhaseValsForSpikeTS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times_in_pos_samples</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
        <span class="p">)</span>
        <span class="n">ts_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase</span><span class="p">[</span><span class="n">ts_idx</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.phasecoding.phasePrecession2D.getPosProps" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getPosProps</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Uses the output of partitionFields and returns vectors the same
length as pos.</p>
<p>Args:
    tetrode, cluster (int): The tetrode / cluster to examine
    peaksXY (array_like): The x-y coords of the peaks in the ratemap
    laserEvents (array_like): The position indices of on events
    (laser on)</p>
<p>Returns:
    pos_dict, run_dict (dict): Contains a whole bunch of information
    for the whole trial and also on a run-by-run basis (run_dict).
    See the end of this function for all the key / value pairs.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getPosProps</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uses the output of partitionFields and returns vectors the same</span>
<span class="sd">    length as pos.</span>

<span class="sd">    Args:</span>
<span class="sd">        tetrode, cluster (int): The tetrode / cluster to examine</span>
<span class="sd">        peaksXY (array_like): The x-y coords of the peaks in the ratemap</span>
<span class="sd">        laserEvents (array_like): The position indices of on events</span>
<span class="sd">        (laser on)</span>

<span class="sd">    Returns:</span>
<span class="sd">        pos_dict, run_dict (dict): Contains a whole bunch of information</span>
<span class="sd">        for the whole trial and also on a run-by-run basis (run_dict).</span>
<span class="sd">        See the end of this function for all the key / value pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spikeTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_ts</span>  <span class="c1"># in seconds</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">xy</span>
    <span class="n">xydir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">dir</span>
    <span class="c1"># spd = self.RateMap.speed</span>
    <span class="n">spkPosInd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_pos_idx</span>
    <span class="n">nPos</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">spkPosInd</span><span class="p">[</span><span class="n">spkPosInd</span> <span class="o">&gt;</span> <span class="n">nPos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nPos</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">xydir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">xydir</span><span class="p">)</span>

    <span class="n">binned_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_weights</span><span class="p">)</span>
    <span class="n">ye</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">bin_edges</span>
    <span class="n">rmap</span> <span class="o">=</span> <span class="n">binned_data</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># The large number of bins combined with the super-smoothed ratemap</span>
    <span class="c1"># will lead to fields labelled with lots of small holes in. Fill those</span>
    <span class="c1"># gaps in here and calculate the perimeter of the fields based on that</span>
    <span class="c1"># labelled image</span>
    <span class="n">labels</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>

    <span class="n">rmap_zeros</span> <span class="o">=</span> <span class="n">rmap</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">rmap_zeros</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmap</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">xBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xe</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">yBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ye</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">observed_spikes_in_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
        <span class="p">(</span><span class="n">spikeTS</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nPos</span>
    <span class="p">)</span>

    <span class="n">field_props</span> <span class="o">=</span> <span class="n">fieldprops</span><span class="p">(</span>
        <span class="n">labels</span><span class="p">,</span>
        <span class="n">binned_data</span><span class="p">,</span>
        <span class="n">xy</span><span class="p">,</span>
        <span class="n">observed_spikes_in_time</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Filtering runs for min duration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_allowed_run_duration</span><span class="si">}</span><span class="s2">, speed </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_allowed_run_speed</span><span class="si">}</span><span class="s2"> and min spikes </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_spikes</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="n">field_props</span> <span class="o">=</span> <span class="n">filter_runs</span><span class="p">(</span>
        <span class="n">field_props</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_allowed_run_duration</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_allowed_run_speed</span><span class="p">,</span>
        <span class="n">min_spikes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Smooth the runs before calculating other metrics</span>
    <span class="p">[</span>
        <span class="n">f</span><span class="o">.</span><span class="n">smooth_runs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ifr_smoothing_constant</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatial_lowpass_cutoff</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;pos_d_currentdir&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">d_currentdir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                <span class="n">d_currentdir</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">current_direction</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_d_currentdir&quot;</span><span class="p">,</span> <span class="n">d_currentdir</span><span class="p">)</span>

    <span class="c1"># calculate the cumulative distance travelled on each run</span>
    <span class="c1"># only goes from 0-1</span>
    <span class="k">if</span> <span class="s2">&quot;pos_d_cum&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">d_cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                <span class="n">d_cumulative</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">cumulative_distance</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_d_cum&quot;</span><span class="p">,</span> <span class="n">d_cumulative</span><span class="p">)</span>

    <span class="c1"># calculate cumulative sum of the expected normalised firing rate</span>
    <span class="c1"># only goes from 0-1</span>
    <span class="c1"># NB I&#39;m not sure why this is called expected rate as there is nothing</span>
    <span class="c1"># about firing rate in this just the accumulation of rho</span>
    <span class="k">if</span> <span class="s2">&quot;pos_exptdRate_cum&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">exptd_rate_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">rmap_infilled</span> <span class="o">=</span> <span class="n">infill_ratemap</span><span class="p">(</span><span class="n">rmap</span><span class="p">)</span>
        <span class="n">exptd_rate</span> <span class="o">=</span> <span class="n">rmap_infilled</span><span class="p">[</span><span class="n">yBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># setting the sample rate to 1 here will result in firing rate being returned</span>
        <span class="c1"># not expected spike count</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                <span class="n">exptd_rate_all</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">expected_spikes</span><span class="p">(</span><span class="n">exptd_rate</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_exptdRate_cum&quot;</span><span class="p">,</span> <span class="n">exptd_rate_all</span><span class="p">)</span>

    <span class="c1"># direction projected onto the run mean direction is just the x coord</span>
    <span class="c1"># good - remembering that xy_new is rho,phi</span>
    <span class="c1"># this might be wrong - need to check i&#39;m grabbing the right value</span>
    <span class="c1"># from FieldProps... could be rho</span>
    <span class="k">if</span> <span class="s2">&quot;pos_d_meanDir&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">d_meandir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                <span class="n">d_meandir</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">pos_r</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_d_meanDir&quot;</span><span class="p">,</span> <span class="n">d_meandir</span><span class="p">)</span>

    <span class="c1"># smooth binned spikes to get an instantaneous firing rate</span>
    <span class="c1"># set up the smoothing kernel</span>
    <span class="c1"># all up at 1.0</span>
    <span class="k">if</span> <span class="s2">&quot;pos_instFR&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">kernLenInBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ifr_kernel_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins_per_second</span><span class="p">)</span>
        <span class="n">kernSig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifr_kernel_sigma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins_per_second</span>
        <span class="n">regressor</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">kernLenInBins</span><span class="p">,</span> <span class="n">kernSig</span><span class="p">)</span>
        <span class="c1"># apply the smoothing kernel over the binned observed spikes</span>
        <span class="n">ifr</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">observed_spikes_in_time</span><span class="p">,</span> <span class="n">regressor</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="n">inst_firing_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ifr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i_slice</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">run_slices</span><span class="p">:</span>
                <span class="n">inst_firing_rate</span><span class="p">[</span><span class="n">i_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifr</span><span class="p">[</span><span class="n">i_slice</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_instFR&quot;</span><span class="p">,</span> <span class="n">inst_firing_rate</span><span class="p">)</span>

    <span class="c1"># find time spent within run</span>
    <span class="c1"># only goes from 0-1</span>
    <span class="k">if</span> <span class="s2">&quot;pos_timeInRun&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">time_in_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">PosData</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
                <span class="n">time_in_run</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">cumulative_time</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_regressor_values</span><span class="p">(</span><span class="s2">&quot;pos_timeInRun&quot;</span><span class="p">,</span> <span class="n">time_in_run</span><span class="p">)</span>

    <span class="c1"># mnSpd = np.concatenate([f.runs_speed for f in field_props])</span>
    <span class="c1"># centralPeripheral = np.concatenate([f.pos_xy[1] for f in field_props])</span>

    <span class="k">return</span> <span class="n">field_props</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.phasecoding.phasePrecession2D.getThetaProps" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getThetaProps</span><span class="p">(</span><span class="n">field_props</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Processes the LFP data and inserts into each run within each field
a segment of LFP data that has had its phase and amplitude extracted
as well as some other metadata</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getThetaProps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_props</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">FieldProps</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes the LFP data and inserts into each run within each field</span>
<span class="sd">    a segment of LFP data that has had its phase and amplitude extracted</span>
<span class="sd">    as well as some other metadata</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spikeTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_ts</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">filteredEEG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filteredEEG</span>
    <span class="n">oldAmplt</span> <span class="o">=</span> <span class="n">filteredEEG</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># get indices of spikes into eeg</span>
    <span class="n">spkEEGIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_eeg_idx</span>
    <span class="n">spkCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spkEEGIdx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">))</span>
    <span class="n">spkPhase</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># unmask the valid entries</span>
    <span class="n">spkPhase</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">spkEEGIdx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">minSpikingPhase</span> <span class="o">=</span> <span class="n">getPhaseOfMinSpiking</span><span class="p">(</span><span class="n">spkPhase</span><span class="p">)</span>
    <span class="c1"># force phase to lie between 0 and 2PI</span>
    <span class="n">phaseAdj</span> <span class="o">=</span> <span class="n">fixAngle</span><span class="p">(</span>
        <span class="n">phase</span> <span class="o">-</span> <span class="n">minSpikingPhase</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_min_spike_phase</span>
    <span class="p">)</span>
    <span class="n">isNegFreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phaseAdj</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="n">isNegFreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isNegFreq</span><span class="p">,</span> <span class="n">isNegFreq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># get start of theta cycles as points where diff &gt; pi</span>
    <span class="n">phaseDf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phaseAdj</span><span class="p">)</span>
    <span class="n">cycleStarts</span> <span class="o">=</span> <span class="n">phaseDf</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">cycleStarts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycleStarts</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">cycleStarts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cycleStarts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">cycleStarts</span><span class="p">[</span><span class="n">isNegFreq</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">cycleLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">cycleStarts</span><span class="p">)</span>

    <span class="c1"># caculate power and find low power cycles</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">filteredEEG</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cycleTotValidPow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
        <span class="n">cycleLabel</span><span class="p">[</span><span class="o">~</span><span class="n">isNegFreq</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">power</span><span class="p">[</span><span class="o">~</span><span class="n">isNegFreq</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">cycleValidBinCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">cycleLabel</span><span class="p">[</span><span class="o">~</span><span class="n">isNegFreq</span><span class="p">])</span>
    <span class="n">cycleValidMnPow</span> <span class="o">=</span> <span class="n">cycleTotValidPow</span> <span class="o">/</span> <span class="n">cycleValidBinCount</span>
    <span class="n">powRejectThresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
        <span class="n">cycleValidMnPow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_power_percent_threshold</span>
    <span class="p">)</span>
    <span class="n">cycleHasBadPow</span> <span class="o">=</span> <span class="n">cycleValidMnPow</span> <span class="o">&lt;</span> <span class="n">powRejectThresh</span>

    <span class="c1"># find cycles too long or too short</span>
    <span class="n">allowed_theta_len</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_theta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_theta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">cycleTotBinCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">cycleLabel</span><span class="p">)</span>
    <span class="n">cycleHasBadLen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
        <span class="n">cycleTotBinCount</span> <span class="o">&lt;</span> <span class="n">allowed_theta_len</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">cycleTotBinCount</span> <span class="o">&gt;</span> <span class="n">allowed_theta_len</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># remove data calculated as &#39;bad&#39;</span>
    <span class="n">isBadCycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">cycleHasBadLen</span><span class="p">,</span> <span class="n">cycleHasBadPow</span><span class="p">)</span>
    <span class="n">isInBadCycle</span> <span class="o">=</span> <span class="n">isBadCycle</span><span class="p">[</span><span class="n">cycleLabel</span><span class="p">]</span>
    <span class="n">isBad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">isInBadCycle</span><span class="p">,</span> <span class="n">isNegFreq</span><span class="p">)</span>
    <span class="nb">breakpoint</span><span class="p">()</span>
    <span class="c1"># TODO: above phaseAdj is being created as a Masked array with all mask values as True...</span>
    <span class="n">phaseAdj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">phaseAdj</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">isBad</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">phaseAdj</span> <span class="o">=</span> <span class="n">phaseAdj</span>
    <span class="n">ampAdj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">filteredEEG</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">isBad</span><span class="p">))</span>
    <span class="n">cycleLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">cycleLabel</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">isBad</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cycleLabel</span> <span class="o">=</span> <span class="n">cycleLabel</span>
    <span class="n">spkCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spkCount</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">isBad</span><span class="p">))</span>
    <span class="c1"># Extract all the relevant values from the arrays above and</span>
    <span class="c1"># add to each run</span>
    <span class="n">lfp_to_pos_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">field_props</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">runs</span><span class="p">:</span>
            <span class="n">lfp_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">run</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">start</span> <span class="o">*</span> <span class="n">lfp_to_pos_ratio</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">run</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">*</span> <span class="n">lfp_to_pos_ratio</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">spike_times</span> <span class="o">=</span> <span class="n">spikeTS</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">spikeTS</span> <span class="o">&gt;</span> <span class="n">lfp_slice</span><span class="o">.</span><span class="n">start</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">,</span>
                    <span class="n">spikeTS</span> <span class="o">&lt;</span> <span class="n">lfp_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="n">lfp_segment</span> <span class="o">=</span> <span class="n">LFPSegment</span><span class="p">(</span>
                <span class="n">field</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                <span class="n">run</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                <span class="n">lfp_slice</span><span class="p">,</span>
                <span class="n">spike_times</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eeg</span><span class="p">[</span><span class="n">lfp_slice</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filteredEEG</span><span class="p">[</span><span class="n">lfp_slice</span><span class="p">],</span>
                <span class="n">phaseAdj</span><span class="p">[</span><span class="n">lfp_slice</span><span class="p">],</span>
                <span class="n">ampAdj</span><span class="p">[</span><span class="n">lfp_slice</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lfp_sample_rate</span><span class="p">,</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_theta</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">run</span><span class="o">.</span><span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_segment</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.phasecoding.phasePrecession2D.performRegression" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">performRegression</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Wrapper function for doing the actual regression which has multiple
stages.</p>
<p>Specifically here we partition fields into sub-fields, get a bunch of
information about the position, spiking and theta data and then
do the actual regression.</p>
<p>Args:
    tetrode (int): The tetrode to examine
    cluster (int): The cluster to examine
    laserEvents (array_like, optional): The on times for laser events
    if present. Default is None
Valid keyword args:
    plot (bool): whether to plot the results of field partitions, the regression(s)
        etc
See Also:
    ephysiopy.common.eegcalcs.phasePrecession.partitionFields()
    ephysiopy.common.eegcalcs.phasePrecession.getPosProps()
    ephysiopy.common.eegcalcs.phasePrecession.getThetaProps()
    ephysiopy.common.eegcalcs.phasePrecession.getSpikeProps()
    ephysiopy.common.eegcalcs.phasePrecession._ppRegress()</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">performRegression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for doing the actual regression which has multiple</span>
<span class="sd">    stages.</span>

<span class="sd">    Specifically here we partition fields into sub-fields, get a bunch of</span>
<span class="sd">    information about the position, spiking and theta data and then</span>
<span class="sd">    do the actual regression.</span>

<span class="sd">    Args:</span>
<span class="sd">        tetrode (int): The tetrode to examine</span>
<span class="sd">        cluster (int): The cluster to examine</span>
<span class="sd">        laserEvents (array_like, optional): The on times for laser events</span>
<span class="sd">        if present. Default is None</span>
<span class="sd">    Valid keyword args:</span>
<span class="sd">        plot (bool): whether to plot the results of field partitions, the regression(s)</span>
<span class="sd">            etc</span>
<span class="sd">    See Also:</span>
<span class="sd">        ephysiopy.common.eegcalcs.phasePrecession.partitionFields()</span>
<span class="sd">        ephysiopy.common.eegcalcs.phasePrecession.getPosProps()</span>
<span class="sd">        ephysiopy.common.eegcalcs.phasePrecession.getThetaProps()</span>
<span class="sd">        ephysiopy.common.eegcalcs.phasePrecession.getSpikeProps()</span>
<span class="sd">        ephysiopy.common.eegcalcs.phasePrecession._ppRegress()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">do_plot</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Partition fields - comes from ephysiopy.common.fieldca</span>
    <span class="n">binned_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_weights</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">partitionFields</span><span class="p">(</span>
        <span class="n">binned_data</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_threshold_percent</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_threshold</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># split into runs</span>
    <span class="n">field_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPosProps</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="c1"># self.posdict = posD</span>
    <span class="c1"># self.rundict = runD</span>

    <span class="c1"># get theta cycles, amplitudes, phase etc</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">getThetaProps</span><span class="p">(</span><span class="n">field_properties</span><span class="p">)</span>
    <span class="c1"># TODO: next: getSpikeProps(field_properties)</span>
    <span class="c1"># the fields that are set within getSpikeProps() I think can be added</span>
    <span class="c1"># to the individual runs within the FieldProps instance</span>
    <span class="c1"># spkCount is just spikes binned wrt eeg timebase</span>
    <span class="c1">#</span>

    <span class="c1"># get the indices of spikes for various metrics such as</span>
    <span class="c1"># theta cycle, run etc</span>
    <span class="n">spkD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSpikeProps</span><span class="p">(</span><span class="n">field_properties</span><span class="p">)</span>
    <span class="c1"># self.spkdict = spkD</span>
    <span class="c1"># at this point the &#39;values&#39; and &#39;pha&#39; arrays in the regressors dict are all</span>
    <span class="c1"># npos elements long and are masked arrays. keep as masked arrays and just modify the</span>
    <span class="c1"># masks instead of truncating the data</span>
    <span class="c1"># Do the regressions</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_ppRegress</span><span class="p">(</span><span class="n">spkD</span><span class="p">)</span>

    <span class="c1"># Plot the results if asked</span>
    <span class="k">if</span> <span class="n">do_plot</span><span class="p">:</span>
        <span class="n">n_regressors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_regressors</span><span class="p">())</span>
        <span class="n">n_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_regressors</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_regressors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s2">&quot;Regression results&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">flatten_list</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_regressors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ra</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_regressors</span><span class="p">(),</span> <span class="n">ax</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotRegressor</span><span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.phasecoding.phasePrecession2D.update_regressors" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">update_regressors</span><span class="p">(</span><span class="n">reg_keys</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Create a dict to hold the stats values for
each regressor
Default regressors are:
    "spk_numWithinRun",
    "pos_exptdRate_cum",
    "pos_instFR",
    "pos_timeInRun",
    "pos_d_cum",
    "pos_d_meanDir",
    "pos_d_currentdir",
    "spk_thetaBatchLabelInRun"</p>
<p>NB: The regressors have differing sizes of 'values' depending on the
type of the regressor:
spk_<em> - integer values of the spike number within a run or the theta batch
        in a run, so has a length equal to the number of spikes collected
pos_</em> - a bincount of some type so equal to the number of position samples
        collected
eeg_* - only one at present, the instantaneous firing rate binned into the
        number of eeg samples so equal to that in length</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">update_regressors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a dict to hold the stats values for</span>
<span class="sd">    each regressor</span>
<span class="sd">    Default regressors are:</span>
<span class="sd">        &quot;spk_numWithinRun&quot;,</span>
<span class="sd">        &quot;pos_exptdRate_cum&quot;,</span>
<span class="sd">        &quot;pos_instFR&quot;,</span>
<span class="sd">        &quot;pos_timeInRun&quot;,</span>
<span class="sd">        &quot;pos_d_cum&quot;,</span>
<span class="sd">        &quot;pos_d_meanDir&quot;,</span>
<span class="sd">        &quot;pos_d_currentdir&quot;,</span>
<span class="sd">        &quot;spk_thetaBatchLabelInRun&quot;</span>

<span class="sd">    NB: The regressors have differing sizes of &#39;values&#39; depending on the</span>
<span class="sd">    type of the regressor:</span>
<span class="sd">    spk_* - integer values of the spike number within a run or the theta batch</span>
<span class="sd">            in a run, so has a length equal to the number of spikes collected</span>
<span class="sd">    pos_* - a bincount of some type so equal to the number of position samples</span>
<span class="sd">            collected</span>
<span class="sd">    eeg_* - only one at present, the instantaneous firing rate binned into the</span>
<span class="sd">            number of eeg samples so equal to that in length</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reg_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">reg_keys</span> <span class="o">=</span> <span class="n">all_regressors</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">regressor</span> <span class="ow">in</span> <span class="n">all_regressors</span> <span class="k">for</span> <span class="n">regressor</span> <span class="ow">in</span> <span class="n">reg_keys</span><span class="p">])</span>

    <span class="c1"># Create a dict to hold the stats values for</span>
    <span class="c1"># each regressor</span>
    <span class="n">stats_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span>
        <span class="s2">&quot;pha&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span>
        <span class="s2">&quot;slope&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;intercept&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;cor&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;cor_boot&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;p_shuffled&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;ci&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;reg&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">stats_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">)</span>
    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">regressors</span><span class="p">[</span><span class="n">regressor</span><span class="p">]</span> <span class="k">for</span> <span class="n">regressor</span> <span class="ow">in</span> <span class="n">reg_keys</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.phasecoding.ccc" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">ccc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates correlation between two random circular variables</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">ccc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates correlation between two random circular variables</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <span class="o">-</span> <span class="n">C</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">E</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">G</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">H</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rho</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.phasecoding.ccc_jack" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">ccc_jack</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Function used to calculate jackknife estimates of correlation</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">ccc_jack</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function used to calculate jackknife estimates of correlation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="n">B</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">-</span> <span class="n">C</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="o">-</span> <span class="n">D</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">-</span> <span class="n">E</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">-</span> <span class="n">G</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="n">H</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <span class="o">-</span> <span class="n">C</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">E</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">G</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">H</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rho</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.phasecoding.circCircCorrTLinear" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">circCircCorrTLinear</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">regressor</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">hyp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">conf</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>An almost direct copy from AJs Matlab fcn to perform correlation
between 2 circular random variables.</p>
<p>Returns the correlation value (rho), p-value, bootstrapped correlation
values, shuffled p values and correlation values.</p>
<p>Args:
    theta, phi (array_like): mx1 array containing circular data (radians)
        whose correlation is to be measured
    regressor (int, optional): number of permutations to use to calculate p-value
        from randomisation and bootstrap estimation of confidence
        intervals.
        Leave empty to calculate p-value analytically (NB confidence
        intervals will not be calculated). Default is 1000.
    alpha (float, optional): hypothesis test level e.g. 0.05, 0.01 etc.
        Default is 0.05.
    hyp (int, optional): hypothesis to test; -1/ 0 / 1 (-ve correlated /
        correlated in either direction / positively correlated).
        Default is 0.
    conf (bool, optional): True or False to calculate confidence intervals
        via jackknife or bootstrap. Default is True.</p>
<p>References:
    Fisher (1993), Statistical Analysis of Circular Data,
        Cambridge University Press, ISBN: 0 521 56890 0</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">circCircCorrTLinear</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">regressor</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">hyp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">conf</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An almost direct copy from AJs Matlab fcn to perform correlation</span>
<span class="sd">    between 2 circular random variables.</span>

<span class="sd">    Returns the correlation value (rho), p-value, bootstrapped correlation</span>
<span class="sd">    values, shuffled p values and correlation values.</span>

<span class="sd">    Args:</span>
<span class="sd">        theta, phi (array_like): mx1 array containing circular data (radians)</span>
<span class="sd">            whose correlation is to be measured</span>
<span class="sd">        regressor (int, optional): number of permutations to use to calculate p-value</span>
<span class="sd">            from randomisation and bootstrap estimation of confidence</span>
<span class="sd">            intervals.</span>
<span class="sd">            Leave empty to calculate p-value analytically (NB confidence</span>
<span class="sd">            intervals will not be calculated). Default is 1000.</span>
<span class="sd">        alpha (float, optional): hypothesis test level e.g. 0.05, 0.01 etc.</span>
<span class="sd">            Default is 0.05.</span>
<span class="sd">        hyp (int, optional): hypothesis to test; -1/ 0 / 1 (-ve correlated /</span>
<span class="sd">            correlated in either direction / positively correlated).</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        conf (bool, optional): True or False to calculate confidence intervals</span>
<span class="sd">            via jackknife or bootstrap. Default is True.</span>

<span class="sd">    References:</span>
<span class="sd">        Fisher (1993), Statistical Analysis of Circular Data,</span>
<span class="sd">            Cambridge University Press, ISBN: 0 521 56890 0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;theta and phi not same length - try again!&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

    <span class="c1"># estimate correlation</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">ccc</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="c1"># derive p-values</span>
    <span class="k">if</span> <span class="n">regressor</span><span class="p">:</span>
        <span class="n">p_shuff</span> <span class="o">=</span> <span class="n">shuffledPVal</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">regressor</span><span class="p">,</span> <span class="n">hyp</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># estimtate ci&#39;s for correlation</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">25</span> <span class="ow">and</span> <span class="n">conf</span><span class="p">:</span>
        <span class="c1"># obtain jackknife estimates of rho and its ci&#39;s</span>
        <span class="n">rho_jack</span> <span class="o">=</span> <span class="n">ccc_jack</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
        <span class="n">rho_jack</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho_jack</span>
        <span class="n">rho_boot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rho_jack</span><span class="p">)</span>
        <span class="n">rho_jack_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">rho_jack</span><span class="p">)</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">rho_boot</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">rho_jack_std</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">rho_boot</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">rho_jack_std</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">conf</span> <span class="ow">and</span> <span class="n">regressor</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">25</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">resample</span>

        <span class="c1"># set up the bootstrapping parameters</span>
        <span class="n">boot_samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">regressor</span><span class="p">):</span>
            <span class="n">theta_sample</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">phi_sample</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">boot_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">ccc</span><span class="p">(</span>
                    <span class="n">theta_sample</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">theta_sample</span><span class="p">)],</span>
                    <span class="n">phi_sample</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">phi_sample</span><span class="p">)],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">rho_boot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">boot_samples</span><span class="p">)</span>
        <span class="c1"># confidence intervals</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">boot_samples</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">boot_samples</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

        <span class="n">ci</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rho_boot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">rho</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho_boot</span><span class="p">,</span> <span class="n">p_shuff</span><span class="p">,</span> <span class="n">ci</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.phasecoding.circRegress" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">circRegress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Finds approximation to circular-linear regression for phase precession.</p>
<p>Args:
    x (list): n-by-1 list of in-field positions (linear variable)
    t (list): n-by-1 list of phases, in degrees (converted to radians)</p>
<p>Note:
    Neither x nor t can contain NaNs, must be paired (of equal length).</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">circRegress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds approximation to circular-linear regression for phase precession.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (list): n-by-1 list of in-field positions (linear variable)</span>
<span class="sd">        t (list): n-by-1 list of phases, in degrees (converted to radians)</span>

<span class="sd">    Note:</span>
<span class="sd">        Neither x nor t can contain NaNs, must be paired (of equal length).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># transform the linear co-variate to the range -1 to 1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span>
    <span class="n">mnx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">xn</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mnx</span>
    <span class="n">mxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">xn</span><span class="p">))</span>
    <span class="n">xn</span> <span class="o">=</span> <span class="n">xn</span> <span class="o">/</span> <span class="n">mxx</span>
    <span class="c1"># keep tn between 0 and 2pi</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="c1"># constrain max slope to give at most 720 degrees of phase precession</span>
    <span class="c1"># over the field</span>
    <span class="n">max_slope</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xn</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xn</span><span class="p">))</span>

    <span class="c1"># perform slope optimisation and find intercept</span>
    <span class="k">def</span> <span class="nf">_cost</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span><span class="p">))))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

    <span class="n">slope</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="n">_cost</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">max_slope</span><span class="p">,</span> <span class="n">max_slope</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">tn</span><span class="p">))</span>
    <span class="n">intercept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tn</span> <span class="o">-</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">xn</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">tn</span> <span class="o">-</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">xn</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">intercept</span> <span class="o">=</span> <span class="n">intercept</span> <span class="o">+</span> <span class="p">((</span><span class="mi">0</span> <span class="o">-</span> <span class="n">slope</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">mnx</span> <span class="o">/</span> <span class="n">mxx</span><span class="p">))</span>
    <span class="n">slope</span> <span class="o">=</span> <span class="n">slope</span> <span class="o">/</span> <span class="n">mxx</span>
    <span class="k">return</span> <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.phasecoding.plot_spikes_in_runs_per_field" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_spikes_in_runs_per_field</span><span class="p">(</span><span class="n">field_label</span><span class="p">,</span> <span class="n">run_starts</span><span class="p">,</span> <span class="n">run_ends</span><span class="p">,</span> <span class="n">spikes_in_time</span><span class="p">,</span> <span class="n">ttls_in_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Debug plotting to show spikes per run per field found in the ratemap
as a raster plot</p>
<p>Args:
field_label (np.ndarray): The field labels for each position bin
    a vector
run_start_stop_idx (np.ndarray): The start and stop indices of each run
    has shape (n_runs, 2)
spikes_in_time (np.ndarray): The number of spikes in each position bin
    a vector</p>
<p>kwargs:
separate_plots (bool): If True then each field will be plotted in a
separate figure</p>
<p>single_axes (bool): If True will plot all the runs/ spikes in a single
axis with fields delimited by horizontal lines</p>
<p>Returns:
fig, axes (tuple): The figure and axes objects</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">plot_spikes_in_runs_per_field</span><span class="p">(</span>
    <span class="n">field_label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">run_starts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">run_ends</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">spikes_in_time</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ttls_in_time</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Debug plotting to show spikes per run per field found in the ratemap</span>
<span class="sd">    as a raster plot</span>

<span class="sd">    Args:</span>
<span class="sd">    field_label (np.ndarray): The field labels for each position bin</span>
<span class="sd">        a vector</span>
<span class="sd">    run_start_stop_idx (np.ndarray): The start and stop indices of each run</span>
<span class="sd">        has shape (n_runs, 2)</span>
<span class="sd">    spikes_in_time (np.ndarray): The number of spikes in each position bin</span>
<span class="sd">        a vector</span>

<span class="sd">    kwargs:</span>
<span class="sd">    separate_plots (bool): If True then each field will be plotted in a</span>
<span class="sd">    separate figure</span>

<span class="sd">    single_axes (bool): If True will plot all the runs/ spikes in a single</span>
<span class="sd">    axis with fields delimited by horizontal lines</span>

<span class="sd">    Returns:</span>
<span class="sd">    fig, axes (tuple): The figure and axes objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spikes_in_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">spikes_in_time</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ttls_in_time</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikes_in_time</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ttls_in_time</span><span class="p">)</span>
    <span class="n">run_start_stop_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">run_starts</span><span class="p">,</span> <span class="n">run_ends</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">run_field_id</span> <span class="o">=</span> <span class="n">field_label</span><span class="p">[</span><span class="n">run_start_stop_idx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="n">runs_per_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">run_field_id</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">run_field_id</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_run_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">run_start_stop_idx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">run_start_stop_idx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">all_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">run_start_stop_idx</span><span class="p">])</span>
    <span class="c1"># create the figure window first then do the iteration through fields etc</span>
    <span class="n">master_raster_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># a grey colour for the background i.e. how long the run was</span>
    <span class="n">grey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="c1"># iterate through each field then pull out the</span>
    <span class="n">max_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">spikes_in_time</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">orig_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;spring&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="n">max_spikes</span><span class="p">)</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">orig_cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_spikes</span><span class="p">))</span>
    <span class="n">cmap</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grey</span>
    <span class="n">newcmap</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
    <span class="c1"># some lists to hold the outputs</span>
    <span class="c1"># spike count for each run through the field</span>
    <span class="n">master_raster_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># list for count of total number of spikes per field</span>
    <span class="n">spikes_per_run</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># counts of ttl puleses emitted during each run</span>
    <span class="k">if</span> <span class="n">ttls_in_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ttls_per_field</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># collect all the per field spiking, ttls etc first then plot</span>
    <span class="c1"># in a separate iteration</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">field_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">run_field_id</span><span class="p">)):</span>
        <span class="c1"># create a temporary array to hold the raster for this fields runs</span>
        <span class="n">raster_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">runs_per_field</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max_run_len</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">ttl_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">runs_per_field</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max_run_len</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># get the indices into the time binned spikes of the runs</span>
        <span class="n">i_field_slices</span> <span class="o">=</span> <span class="n">all_slices</span><span class="p">[</span><span class="n">run_field_id</span> <span class="o">==</span> <span class="n">field_id</span><span class="p">]</span>
        <span class="c1"># breakpoint()</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_field_slices</span><span class="p">):</span>
            <span class="n">i_run_len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span>
            <span class="n">raster_arr</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">i_run_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">spikes_in_time</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ttls_in_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ttl_arr</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">i_run_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">ttls_in_time</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="n">spikes_per_run</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">raster_arr</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">ttls_in_time</span><span class="p">:</span>
            <span class="n">ttls_per_field</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ttl_arr</span><span class="p">)</span>
        <span class="n">master_raster_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raster_arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;separate_plots&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">field_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">run_field_id</span><span class="p">)):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">master_raster_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">newcmap</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Field </span><span class="si">{</span><span class="n">field_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;single_axes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># deal with master_raster_arr here</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ttls_in_time</span><span class="p">:</span>
            <span class="n">ttls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flatten_list</span><span class="p">(</span><span class="n">ttls_per_field</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">ttls</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;bone&quot;</span><span class="p">])</span>
        <span class="n">spiking_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flatten_list</span><span class="p">(</span><span class="n">master_raster_arr</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">spiking_arr</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">newcmap</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">runs_per_field</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_run_len</span><span class="p">,</span> <span class="s2">&quot;regressor&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_run_len</span><span class="p">)</span>
        <span class="n">ytick_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">runs_per_field</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ytick_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ytick_locs</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ytick_locs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ytick_locs</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">run_field_id</span><span class="p">))))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Field ID&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_run_len</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">max_run_len</span><span class="p">)</span><span class="o">/</span><span class="mi">50</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
        <span class="n">axes2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
        <span class="n">axes2</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ytick_locs</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">spikes_per_run</span><span class="p">)))</span>
        <span class="n">axes2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">())</span>
        <span class="n">axes2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Spikes per field&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.phasecoding.shuffledPVal" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">shuffledPVal</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">regressor</span><span class="p">,</span> <span class="n">hyp</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates shuffled p-values for correlation</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/phasecoding.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">shuffledPVal</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">regressor</span><span class="p">,</span> <span class="n">hyp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates shuffled p-values for correlation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">regressor</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">regressor</span><span class="p">):</span>
        <span class="n">idx</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="n">thetaPerms</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetaPerms</span><span class="p">))</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetaPerms</span><span class="p">))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetaPerms</span><span class="p">))</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetaPerms</span><span class="p">))</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span><span class="p">))</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span><span class="p">))</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phi</span><span class="p">))</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phi</span><span class="p">))</span>

    <span class="n">rho_sim</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <span class="o">-</span> <span class="n">C</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">E</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">G</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">H</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">hyp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">p_shuff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rho_sim</span> <span class="o">&gt;=</span> <span class="n">rho</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">regressor</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">hyp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">p_shuff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rho_sim</span> <span class="o">&lt;=</span> <span class="n">rho</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">regressor</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">hyp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p_shuff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">rho_sim</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">regressor</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_shuff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">p_shuff</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="rhymicity">Rhymicity</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.common.rhythmicity"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.rhythmicity.CosineDirectionalTuning" class="doc doc-heading">
            <code>CosineDirectionalTuning</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Produces output to do with Welday et al (2011) like analysis
of rhythmic firing a la oscialltory interference model</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">CosineDirectionalTuning</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produces output to do with Welday et al (2011) like analysis</span>
<span class="sd">    of rhythmic firing a la oscialltory interference model</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spike_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">pos_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">spk_clusters</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">tracker_params</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            spike_times (1d np.array): Spike times</span>
<span class="sd">            pos_times (1d np.array): Position times</span>
<span class="sd">            spk_clusters (1d np.array): Spike clusters</span>
<span class="sd">            x and y (1d np.array): Position coordinates</span>
<span class="sd">            tracker_params (dict): From the PosTracker as created in</span>
<span class="sd">                                    OESettings.Settings.parse</span>

<span class="sd">        Note:</span>
<span class="sd">            All timestamps should be given in sub-millisecond accurate seconds</span>
<span class="sd">            and pos_xy in cms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">=</span> <span class="n">spike_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_times</span> <span class="o">=</span> <span class="n">pos_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">=</span> <span class="n">spk_clusters</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        There can be more spikes than pos samples in terms of sampling as the</span>
<span class="sd">        open-ephys buffer probably needs to finish writing and the camera has</span>
<span class="sd">        already stopped, so cut of any cluster indices and spike times</span>
<span class="sd">        that exceed the length of the pos indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx_to_keep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">idx_to_keep</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="p">[</span><span class="n">idx_to_keep</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_sample_rate</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spk_sample_rate</span> <span class="o">=</span> <span class="mf">3e4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_samples_for_spike</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_runlength</span> <span class="o">=</span> <span class="mf">0.4</span>  <span class="c1"># in seconds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span> <span class="o">=</span> <span class="n">PosCalcsGeneric</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">230</span><span class="p">,</span> <span class="n">cm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jumpmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tracker_params</span><span class="o">=</span><span class="n">tracker_params</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spikeCalcs</span> <span class="o">=</span> <span class="n">SpikeCalcsGeneric</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">spk_clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spikeCalcs</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">=</span> <span class="n">spk_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">postprocesspos</span><span class="p">(</span><span class="n">tracker_params</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">hdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">calcSpeed</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hdir</span> <span class="o">=</span> <span class="n">hdir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">speed</span>
        <span class="c1"># TEMPORARY FOR POWER SPECTRUM STUFF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smthKernelWidth</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smthKernelSigma</span> <span class="o">=</span> <span class="mf">0.1875</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sn2Width</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="mi">11</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spk_sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spk_sample_rate</span>

    <span class="nd">@spk_sample_rate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">spk_sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spk_sample_rate</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_sample_rate</span>

    <span class="nd">@pos_sample_rate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pos_sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_sample_rate</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_runlength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_runlength</span>

    <span class="nd">@min_runlength</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">min_runlength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_runlength</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span>

    <span class="nd">@xy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hdir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hdir</span>

    <span class="nd">@hdir</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">hdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hdir</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">speed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_speed</span>

    <span class="nd">@speed</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">speed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_speed</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_samples_for_spike</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_samples_for_spike</span>

    <span class="nd">@pos_samples_for_spike</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pos_samples_for_spike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_samples_for_spike</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_rolling_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Totally nabbed from SO:</span>
<span class="sd">        https://stackoverflow.com/questions/6811183/rolling-window-for-1d-arrays-in-numpy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getPosIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples_for_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getClusterPosIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clust</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples_for_spike</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getPosIndices</span><span class="p">()</span>
        <span class="n">clust_pos_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples_for_spike</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">==</span> <span class="n">clust</span><span class="p">]</span>
        <span class="n">clust_pos_idx</span><span class="p">[</span><span class="n">clust_pos_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_times</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">clust_pos_idx</span>

    <span class="k">def</span> <span class="nf">getClusterSpikeTimes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples_for_spike</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getPosIndices</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span> <span class="nf">getDirectionalBinPerPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binwidth</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Direction is in degrees as that what is created by me in some of the</span>
<span class="sd">        other bits of this package.</span>

<span class="sd">        Args:</span>
<span class="sd">            binwidth (int): The bin width in degrees</span>

<span class="sd">        Returns:</span>
<span class="sd">            A digitization of which directional bin each pos sample belongs to</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">binwidth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdir</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getDirectionalBinForCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDirectionalBinPerPosition</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
        <span class="n">cluster_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClusterPosIndices</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="c1"># idx_to_keep = cluster_pos &lt; len(self.pos_times)</span>
        <span class="c1"># cluster_pos = cluster_pos[idx_to_keep]</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">cluster_pos</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getRunsOfMinLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identifies runs of at least self.min_runlength seconds long,</span>
<span class="sd">        which at 30Hz pos sampling rate equals 12 samples, and</span>
<span class="sd">        returns the start and end indices at which</span>
<span class="sd">        the run was occurred and the directional bin that run belongs to</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.array: The start and end indices into pos samples of the run</span>
<span class="sd">                      and the directional bin to which it belongs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDirectionalBinPerPosition</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
        <span class="c1"># nabbed from SO</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>

        <span class="n">grouped_runs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span>
        <span class="n">grouped_runs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grouped_runs</span><span class="p">)</span>
        <span class="n">run_start_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">grouped_runs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">grouped_runs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">min_len_in_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_runlength</span><span class="p">)</span>
        <span class="n">min_len_runs_mask</span> <span class="o">=</span> <span class="n">grouped_runs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_len_in_samples</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">run_start_indices</span><span class="p">[</span><span class="n">min_len_runs_mask</span><span class="p">],</span> <span class="n">grouped_runs</span><span class="p">[</span><span class="n">min_len_runs_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># ret contains run length as last column</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">grouped_runs</span><span class="p">[</span><span class="n">min_len_runs_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">speedFilterRuns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">runs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">minspeed</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the runs identified in getRunsOfMinLength, filter for speed</span>
<span class="sd">        and return runs that meet the min speed criteria.</span>

<span class="sd">        The function goes over the runs with a moving window of length equal</span>
<span class="sd">        to self.min_runlength in samples and sees if any of those segments</span>
<span class="sd">        meet the speed criteria and splits them out into separate runs if true.</span>

<span class="sd">        NB For now this means the same spikes might get included in the</span>
<span class="sd">        autocorrelation procedure later as the</span>
<span class="sd">        moving window will use overlapping periods - can be modified later.</span>

<span class="sd">        Args:</span>
<span class="sd">            runs (3 x nRuns np.array): Generated from getRunsOfMinLength</span>
<span class="sd">            minspeed (float): Min running speed in cm/s for an epoch (minimum</span>
<span class="sd">                              epoch length defined previously</span>
<span class="sd">                              in getRunsOfMinLength as minlength, usually 0.4s)</span>

<span class="sd">        Returns:</span>
<span class="sd">            3 x nRuns np.array: A modified version of the &quot;runs&quot; input variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">minlength_in_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_runlength</span><span class="p">)</span>
        <span class="n">run_list</span> <span class="o">=</span> <span class="n">runs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">all_speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">,</span> <span class="n">dir_bin</span> <span class="ow">in</span> <span class="n">run_list</span><span class="p">:</span>
            <span class="n">this_runs_speed</span> <span class="o">=</span> <span class="n">all_speed</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
            <span class="n">this_runs_runs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rolling_window</span><span class="p">(</span><span class="n">this_runs_speed</span><span class="p">,</span> <span class="n">minlength_in_samples</span><span class="p">)</span>
            <span class="n">run_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this_runs_runs</span> <span class="o">&gt;</span> <span class="n">minspeed</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">run_mask</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got one&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def testing(self, cluster: int):</span>
<span class="sd">        ts = self.getClusterSpikeTimes(cluster)</span>
<span class="sd">        pos_idx = self.getClusterPosIndices(cluster)</span>

<span class="sd">        dir_bins = self.getDirectionalBinPerPosition(45)</span>
<span class="sd">        cluster_dir_bins = dir_bins[pos_idx.astype(int)]</span>

<span class="sd">        from scipy.signal import periodogram, boxcar, filtfilt</span>

<span class="sd">        acorrs = []</span>
<span class="sd">        max_freqs = []</span>
<span class="sd">        max_idx = []</span>
<span class="sd">        isis = []</span>

<span class="sd">        acorr_range = np.array([-500, 500])</span>
<span class="sd">        for i in range(1, 9):</span>
<span class="sd">            this_bin_indices = cluster_dir_bins == i</span>
<span class="sd">            this_ts = ts[this_bin_indices]  # in seconds still so * 1000 for ms</span>
<span class="sd">            y = self.spikeCalcs.xcorr(this_ts*1000, Trange=acorr_range)</span>
<span class="sd">            isis.append(y)</span>
<span class="sd">            corr, acorr_bins = np.histogram(</span>
<span class="sd">                y[y != 0], bins=501, range=acorr_range)</span>
<span class="sd">            freqs, power = periodogram(corr, fs=200, return_onesided=True)</span>
<span class="sd">            # Smooth the power over +/- 1Hz</span>
<span class="sd">            b = boxcar(3)</span>
<span class="sd">            h = filtfilt(b, 3, power)</span>
<span class="sd">            # Square the amplitude first</span>
<span class="sd">            sqd_amp = h ** 2</span>
<span class="sd">            # Then find the mean power in the +/-1Hz band either side of that</span>
<span class="sd">            theta_band_max_idx = np.nonzero(</span>
<span class="sd">                sqd_amp == np.max(</span>
<span class="sd">                    sqd_amp[np.logical_and(freqs &gt; 6, freqs &lt; 11)]))[0][0]</span>
<span class="sd">            max_freq = freqs[theta_band_max_idx]</span>
<span class="sd">            acorrs.append(corr)</span>
<span class="sd">            max_freqs.append(max_freq)</span>
<span class="sd">            max_idx.append(theta_band_max_idx)</span>
<span class="sd">        return isis, acorrs, max_freqs, max_idx, acorr_bins</span>

<span class="sd">    def plotXCorrsByDirection(self, cluster: int):</span>
<span class="sd">        acorr_range = np.array([-500, 500])</span>
<span class="sd">        # plot_range = np.array([-400,400])</span>
<span class="sd">        nbins = 501</span>
<span class="sd">        isis, acorrs, max_freqs, max_idx, acorr_bins = self.testing(cluster)</span>
<span class="sd">        bin_labels = np.arange(0, 360, 45)</span>
<span class="sd">        fig, axs = plt.subplots(8)</span>
<span class="sd">        pts = []</span>
<span class="sd">        for i, a in enumerate(isis):</span>
<span class="sd">            axs[i].hist(</span>
<span class="sd">                a[a != 0], bins=nbins, range=acorr_range,</span>
<span class="sd">                color=&#39;k&#39;, histtype=&#39;stepfilled&#39;)</span>
<span class="sd">            # find the max of the first positive peak</span>
<span class="sd">            corr, _ = np.histogram(a[a != 0], bins=nbins, range=acorr_range)</span>
<span class="sd">            axs[i].set_xlim(acorr_range)</span>
<span class="sd">            axs[i].set_ylabel(str(bin_labels[i]))</span>
<span class="sd">            axs[i].set_yticklabels(&#39;&#39;)</span>
<span class="sd">            if i &lt; 7:</span>
<span class="sd">                axs[i].set_xticklabels(&#39;&#39;)</span>
<span class="sd">            axs[i].spines[&#39;right&#39;].set_visible(False)</span>
<span class="sd">            axs[i].spines[&#39;top&#39;].set_visible(False)</span>
<span class="sd">            axs[i].spines[&#39;left&#39;].set_visible(False)</span>
<span class="sd">        plt.show()</span>
<span class="sd">        return pts</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">intrinsic_freq_autoCorr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spkTimes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">posMask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxFreq</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">acBinSize</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span>
        <span class="n">acWindow</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is taken and adapted from ephysiopy.common.eegcalcs.EEGCalcs</span>

<span class="sd">        Args:</span>
<span class="sd">            spkTimes (np.array): Times in seconds of the cells firing</span>
<span class="sd">            posMask (np.array): Boolean array corresponding to the length of</span>
<span class="sd">                                spkTimes where True is stuff to keep</span>
<span class="sd">            maxFreq (float): The maximum frequency to do the power spectrum</span>
<span class="sd">                                out to</span>
<span class="sd">            acBinSize (float): The bin size of the autocorrelogram in seconds</span>
<span class="sd">            acWindow (float): The range of the autocorr in seconds</span>

<span class="sd">        Note:</span>
<span class="sd">            Make sure all times are in seconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acBinsPerPos</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">/</span> <span class="n">acBinSize</span>
        <span class="n">acWindowSizeBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">acWindow</span> <span class="o">/</span> <span class="n">acBinSize</span><span class="p">)</span>
        <span class="n">binCentres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">posMask</span><span class="p">)</span> <span class="o">*</span> <span class="n">acBinsPerPos</span><span class="p">)</span> <span class="o">*</span> <span class="n">acBinSize</span>
        <span class="n">spkTrHist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">spkTimes</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binCentres</span><span class="p">)</span>

        <span class="c1"># split the single histogram into individual chunks</span>
        <span class="n">splitIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">posMask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">splitMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">posMask</span><span class="p">,</span> <span class="n">splitIdx</span><span class="p">)</span>
        <span class="n">splitSpkHist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">spkTrHist</span><span class="p">,</span> <span class="p">(</span><span class="n">splitIdx</span> <span class="o">*</span> <span class="n">acBinsPerPos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">histChunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">splitSpkHist</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">splitMask</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">splitSpkHist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">splitSpkHist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">acWindowSizeBins</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">histChunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">splitSpkHist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">autoCorrGrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">acWindowSizeBins</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">histChunks</span><span class="p">)))</span>
        <span class="n">chunkLens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;num chunks = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">histChunks</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">histChunks</span><span class="p">)):</span>
            <span class="n">lenThisChunk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">histChunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">chunkLens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lenThisChunk</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lenThisChunk</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">lenThisChunk</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">lenThisChunk</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">lenThisChunk</span><span class="p">]</span> <span class="o">=</span> <span class="n">histChunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">tmp2</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span>
                <span class="n">tmp</span><span class="p">,</span> <span class="n">histChunks</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span>
            <span class="p">)</span>  <span class="c1"># the autocorrelation</span>
            <span class="n">autoCorrGrid</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">tmp2</span><span class="p">[</span><span class="n">lenThisChunk</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">lenThisChunk</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">acWindowSizeBins</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="o">/</span> <span class="n">acBinsPerPos</span>
            <span class="p">)</span>

        <span class="n">totalLen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">chunkLens</span><span class="p">)</span>
        <span class="n">autoCorrSum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">autoCorrGrid</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">totalLen</span>
        <span class="n">meanNormdAc</span> <span class="o">=</span> <span class="n">autoCorrSum</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">autoCorrSum</span><span class="p">[</span><span class="mi">1</span><span class="p">::])</span>
        <span class="c1"># return meanNormdAc</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_spectrum</span><span class="p">(</span>
            <span class="n">eeg</span><span class="o">=</span><span class="n">meanNormdAc</span><span class="p">,</span>
            <span class="n">binWidthSecs</span><span class="o">=</span><span class="n">acBinSize</span><span class="p">,</span>
            <span class="n">maxFreq</span><span class="o">=</span><span class="n">maxFreq</span><span class="p">,</span>
            <span class="n">pad2pow</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;meanNormdAc&quot;</span><span class="p">:</span> <span class="n">meanNormdAc</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">xlim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
                <span class="n">autoCorrGrid</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="p">[</span>
                    <span class="n">maxFreq</span> <span class="o">*</span> <span class="mf">0.6</span><span class="p">,</span>
                    <span class="n">maxFreq</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s2">&quot;Power&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.6</span><span class="p">,</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">],</span>
            <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">power_spectrum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">eeg</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">binWidthSecs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxFreq</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">pad2pow</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ymax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method used by eeg_power_spectra and intrinsic_freq_autoCorr</span>
<span class="sd">        Signal in must be mean normalised already</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get raw power spectrum</span>
        <span class="n">nqLim</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">binWidthSecs</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">origLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eeg</span><span class="p">)</span>
        <span class="c1"># if pad2pow is None:</span>
        <span class="c1"># 	fftLen = int(np.power(2, self._nextpow2(origLen)))</span>
        <span class="c1"># else:</span>
        <span class="n">fftLen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad2pow</span><span class="p">))</span>
        <span class="n">fftHalfLen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fftLen</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">fftRes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">eeg</span><span class="p">,</span> <span class="n">fftLen</span><span class="p">)</span>
        <span class="c1"># get power density from fft and discard second half of spectrum</span>
        <span class="n">_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftRes</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">origLen</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">_power</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">fftHalfLen</span><span class="p">::])</span>
        <span class="n">power</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># calculate freqs and crop spectrum to requested range</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">nqLim</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fftHalfLen</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">freqs</span> <span class="o">&lt;=</span> <span class="n">maxFreq</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)]</span>

        <span class="c1"># smooth spectrum using gaussian kernel</span>
        <span class="n">binsPerHz</span> <span class="o">=</span> <span class="p">(</span><span class="n">fftHalfLen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nqLim</span>
        <span class="n">kernelLen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smthKernelWidth</span> <span class="o">*</span> <span class="n">binsPerHz</span><span class="p">)</span>
        <span class="n">kernelSig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smthKernelSigma</span> <span class="o">*</span> <span class="n">binsPerHz</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">kernelLen</span><span class="p">,</span> <span class="n">kernelSig</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">kernelLen</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">power_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>

        <span class="c1"># calculate some metrics</span>
        <span class="c1"># find max in theta band</span>
        <span class="n">spectrumMaskBand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">freqs</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">bandMaxPower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">power_sm</span><span class="p">[</span><span class="n">spectrumMaskBand</span><span class="p">])</span>
        <span class="n">maxBinInBand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">power_sm</span><span class="p">[</span><span class="n">spectrumMaskBand</span><span class="p">])</span>
        <span class="n">bandFreqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">spectrumMaskBand</span><span class="p">]</span>
        <span class="n">freqAtBandMaxPower</span> <span class="o">=</span> <span class="n">bandFreqs</span><span class="p">[</span><span class="n">maxBinInBand</span><span class="p">]</span>
        <span class="c1"># self.maxBinInBand = maxBinInBand</span>
        <span class="c1"># self.freqAtBandMaxPower = freqAtBandMaxPower</span>
        <span class="c1"># self.bandMaxPower = bandMaxPower</span>

        <span class="c1"># find power in small window around peak and divide by power in rest</span>
        <span class="c1"># of spectrum to get snr</span>
        <span class="n">spectrumMaskPeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">freqs</span> <span class="o">&gt;</span> <span class="n">freqAtBandMaxPower</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sn2Width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">freqs</span> <span class="o">&lt;</span> <span class="n">freqAtBandMaxPower</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sn2Width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">s2n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">power_sm</span><span class="p">[</span><span class="n">spectrumMaskPeak</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
            <span class="n">power_sm</span><span class="p">[</span><span class="o">~</span><span class="n">spectrumMaskPeak</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">power_sm</span> <span class="o">=</span> <span class="n">power_sm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrumMaskPeak</span> <span class="o">=</span> <span class="n">spectrumMaskPeak</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ymax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">power</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">power_sm</span><span class="p">)])</span>
                <span class="k">if</span> <span class="n">ymax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ymax</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">])</span>
            <span class="c1"># ax.hold(True)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power_sm</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">stemlines</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">stem</span><span class="p">([</span><span class="n">freqAtBandMaxPower</span><span class="p">],</span> <span class="p">[</span><span class="n">bandMaxPower</span><span class="p">],</span> <span class="n">linefmt</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="c1"># plt.setp(stemlines, &#39;linewidth&#39;, 2)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span>
                <span class="n">freqs</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">power_sm</span><span class="p">,</span>
                <span class="n">where</span><span class="o">=</span><span class="n">spectrumMaskPeak</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
                <span class="n">zorder</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># ax.set_ylim(0, ymax)</span>
            <span class="c1"># ax.set_xlim(0, self.xmax)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power density (W/Hz)&quot;</span><span class="p">)</span>
        <span class="n">out_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;maxFreq&quot;</span><span class="p">:</span> <span class="n">freqAtBandMaxPower</span><span class="p">,</span>
            <span class="s2">&quot;Power&quot;</span><span class="p">:</span> <span class="n">power_sm</span><span class="p">,</span>
            <span class="s2">&quot;Freqs&quot;</span><span class="p">:</span> <span class="n">freqs</span><span class="p">,</span>
            <span class="s2">&quot;s2n&quot;</span><span class="p">:</span> <span class="n">s2n</span><span class="p">,</span>
            <span class="s2">&quot;Power_raw&quot;</span><span class="p">:</span> <span class="n">power</span><span class="p">,</span>
            <span class="s2">&quot;k&quot;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
            <span class="s2">&quot;kernelLen&quot;</span><span class="p">:</span> <span class="n">kernelLen</span><span class="p">,</span>
            <span class="s2">&quot;kernelSig&quot;</span><span class="p">:</span> <span class="n">kernelSig</span><span class="p">,</span>
            <span class="s2">&quot;binsPerHz&quot;</span><span class="p">:</span> <span class="n">binsPerHz</span><span class="p">,</span>
            <span class="s2">&quot;kernelLen&quot;</span><span class="p">:</span> <span class="n">kernelLen</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">out_dict</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.common.rhythmicity.CosineDirectionalTuning.spk_clusters" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">spk_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="p">[</span><span class="n">idx_to_keep</span><span class="p">]</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>There can be more spikes than pos samples in terms of sampling as the
open-ephys buffer probably needs to finish writing and the camera has
already stopped, so cut of any cluster indices and spike times
that exceed the length of the pos indices</p>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.CosineDirectionalTuning.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">pos_times</span><span class="p">,</span> <span class="n">spk_clusters</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">tracker_params</span><span class="o">=</span><span class="p">{})</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Args:
    spike_times (1d np.array): Spike times
    pos_times (1d np.array): Position times
    spk_clusters (1d np.array): Spike clusters
    x and y (1d np.array): Position coordinates
    tracker_params (dict): From the PosTracker as created in
                            OESettings.Settings.parse</p>
<p>Note:
    All timestamps should be given in sub-millisecond accurate seconds
    and pos_xy in cms</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">spike_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">pos_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">spk_clusters</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tracker_params</span><span class="o">=</span><span class="p">{},</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        spike_times (1d np.array): Spike times</span>
<span class="sd">        pos_times (1d np.array): Position times</span>
<span class="sd">        spk_clusters (1d np.array): Spike clusters</span>
<span class="sd">        x and y (1d np.array): Position coordinates</span>
<span class="sd">        tracker_params (dict): From the PosTracker as created in</span>
<span class="sd">                                OESettings.Settings.parse</span>

<span class="sd">    Note:</span>
<span class="sd">        All timestamps should be given in sub-millisecond accurate seconds</span>
<span class="sd">        and pos_xy in cms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">=</span> <span class="n">spike_times</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pos_times</span> <span class="o">=</span> <span class="n">pos_times</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">=</span> <span class="n">spk_clusters</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    There can be more spikes than pos samples in terms of sampling as the</span>
<span class="sd">    open-ephys buffer probably needs to finish writing and the camera has</span>
<span class="sd">    already stopped, so cut of any cluster indices and spike times</span>
<span class="sd">    that exceed the length of the pos indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idx_to_keep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">idx_to_keep</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="p">[</span><span class="n">idx_to_keep</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pos_sample_rate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_spk_sample_rate</span> <span class="o">=</span> <span class="mf">3e4</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pos_samples_for_spike</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_min_runlength</span> <span class="o">=</span> <span class="mf">0.4</span>  <span class="c1"># in seconds</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span> <span class="o">=</span> <span class="n">PosCalcsGeneric</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">230</span><span class="p">,</span> <span class="n">cm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jumpmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tracker_params</span><span class="o">=</span><span class="n">tracker_params</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">spikeCalcs</span> <span class="o">=</span> <span class="n">SpikeCalcsGeneric</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">spk_clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">spikeCalcs</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">=</span> <span class="n">spk_clusters</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">postprocesspos</span><span class="p">(</span><span class="n">tracker_params</span><span class="p">)</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">xy</span>
    <span class="n">hdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">dir</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">calcSpeed</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span> <span class="o">=</span> <span class="n">xy</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_hdir</span> <span class="o">=</span> <span class="n">hdir</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">posCalcs</span><span class="o">.</span><span class="n">speed</span>
    <span class="c1"># TEMPORARY FOR POWER SPECTRUM STUFF</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">smthKernelWidth</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">smthKernelSigma</span> <span class="o">=</span> <span class="mf">0.1875</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sn2Width</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="mi">11</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.CosineDirectionalTuning._rolling_window" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_rolling_window</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Totally nabbed from SO:
https://stackoverflow.com/questions/6811183/rolling-window-for-1d-arrays-in-numpy</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_rolling_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Totally nabbed from SO:</span>
<span class="sd">    https://stackoverflow.com/questions/6811183/rolling-window-for-1d-arrays-in-numpy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.CosineDirectionalTuning.getDirectionalBinPerPosition" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getDirectionalBinPerPosition</span><span class="p">(</span><span class="n">binwidth</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Direction is in degrees as that what is created by me in some of the
other bits of this package.</p>
<p>Args:
    binwidth (int): The bin width in degrees</p>
<p>Returns:
    A digitization of which directional bin each pos sample belongs to</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getDirectionalBinPerPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binwidth</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Direction is in degrees as that what is created by me in some of the</span>
<span class="sd">    other bits of this package.</span>

<span class="sd">    Args:</span>
<span class="sd">        binwidth (int): The bin width in degrees</span>

<span class="sd">    Returns:</span>
<span class="sd">        A digitization of which directional bin each pos sample belongs to</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">binwidth</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdir</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.CosineDirectionalTuning.getRunsOfMinLength" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getRunsOfMinLength</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Identifies runs of at least self.min_runlength seconds long,
which at 30Hz pos sampling rate equals 12 samples, and
returns the start and end indices at which
the run was occurred and the directional bin that run belongs to</p>
<p>Returns:
    np.array: The start and end indices into pos samples of the run
              and the directional bin to which it belongs</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getRunsOfMinLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies runs of at least self.min_runlength seconds long,</span>
<span class="sd">    which at 30Hz pos sampling rate equals 12 samples, and</span>
<span class="sd">    returns the start and end indices at which</span>
<span class="sd">    the run was occurred and the directional bin that run belongs to</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: The start and end indices into pos samples of the run</span>
<span class="sd">                  and the directional bin to which it belongs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDirectionalBinPerPosition</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
    <span class="c1"># nabbed from SO</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>

    <span class="n">grouped_runs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span>
    <span class="n">grouped_runs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grouped_runs</span><span class="p">)</span>
    <span class="n">run_start_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">grouped_runs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">grouped_runs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">min_len_in_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_runlength</span><span class="p">)</span>
    <span class="n">min_len_runs_mask</span> <span class="o">=</span> <span class="n">grouped_runs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_len_in_samples</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">run_start_indices</span><span class="p">[</span><span class="n">min_len_runs_mask</span><span class="p">],</span> <span class="n">grouped_runs</span><span class="p">[</span><span class="n">min_len_runs_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># ret contains run length as last column</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">grouped_runs</span><span class="p">[</span><span class="n">min_len_runs_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.CosineDirectionalTuning.intrinsic_freq_autoCorr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">intrinsic_freq_autoCorr</span><span class="p">(</span><span class="n">spkTimes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">posMask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxFreq</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">acBinSize</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span> <span class="n">acWindow</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>This is taken and adapted from ephysiopy.common.eegcalcs.EEGCalcs</p>
<p>Args:
    spkTimes (np.array): Times in seconds of the cells firing
    posMask (np.array): Boolean array corresponding to the length of
                        spkTimes where True is stuff to keep
    maxFreq (float): The maximum frequency to do the power spectrum
                        out to
    acBinSize (float): The bin size of the autocorrelogram in seconds
    acWindow (float): The range of the autocorr in seconds</p>
<p>Note:
    Make sure all times are in seconds</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">intrinsic_freq_autoCorr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">spkTimes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">posMask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxFreq</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="n">acBinSize</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span>
    <span class="n">acWindow</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is taken and adapted from ephysiopy.common.eegcalcs.EEGCalcs</span>

<span class="sd">    Args:</span>
<span class="sd">        spkTimes (np.array): Times in seconds of the cells firing</span>
<span class="sd">        posMask (np.array): Boolean array corresponding to the length of</span>
<span class="sd">                            spkTimes where True is stuff to keep</span>
<span class="sd">        maxFreq (float): The maximum frequency to do the power spectrum</span>
<span class="sd">                            out to</span>
<span class="sd">        acBinSize (float): The bin size of the autocorrelogram in seconds</span>
<span class="sd">        acWindow (float): The range of the autocorr in seconds</span>

<span class="sd">    Note:</span>
<span class="sd">        Make sure all times are in seconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">acBinsPerPos</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">/</span> <span class="n">acBinSize</span>
    <span class="n">acWindowSizeBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">acWindow</span> <span class="o">/</span> <span class="n">acBinSize</span><span class="p">)</span>
    <span class="n">binCentres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">posMask</span><span class="p">)</span> <span class="o">*</span> <span class="n">acBinsPerPos</span><span class="p">)</span> <span class="o">*</span> <span class="n">acBinSize</span>
    <span class="n">spkTrHist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">spkTimes</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binCentres</span><span class="p">)</span>

    <span class="c1"># split the single histogram into individual chunks</span>
    <span class="n">splitIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">posMask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">splitMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">posMask</span><span class="p">,</span> <span class="n">splitIdx</span><span class="p">)</span>
    <span class="n">splitSpkHist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">spkTrHist</span><span class="p">,</span> <span class="p">(</span><span class="n">splitIdx</span> <span class="o">*</span> <span class="n">acBinsPerPos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">histChunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">splitSpkHist</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">splitMask</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">splitSpkHist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">splitSpkHist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">acWindowSizeBins</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">histChunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">splitSpkHist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">autoCorrGrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">acWindowSizeBins</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">histChunks</span><span class="p">)))</span>
    <span class="n">chunkLens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;num chunks = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">histChunks</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">histChunks</span><span class="p">)):</span>
        <span class="n">lenThisChunk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">histChunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">chunkLens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lenThisChunk</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lenThisChunk</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">lenThisChunk</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">lenThisChunk</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">lenThisChunk</span><span class="p">]</span> <span class="o">=</span> <span class="n">histChunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">tmp2</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span>
            <span class="n">tmp</span><span class="p">,</span> <span class="n">histChunks</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span>
        <span class="p">)</span>  <span class="c1"># the autocorrelation</span>
        <span class="n">autoCorrGrid</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">tmp2</span><span class="p">[</span><span class="n">lenThisChunk</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">lenThisChunk</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">acWindowSizeBins</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="o">/</span> <span class="n">acBinsPerPos</span>
        <span class="p">)</span>

    <span class="n">totalLen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">chunkLens</span><span class="p">)</span>
    <span class="n">autoCorrSum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">autoCorrGrid</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">totalLen</span>
    <span class="n">meanNormdAc</span> <span class="o">=</span> <span class="n">autoCorrSum</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">autoCorrSum</span><span class="p">[</span><span class="mi">1</span><span class="p">::])</span>
    <span class="c1"># return meanNormdAc</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_spectrum</span><span class="p">(</span>
        <span class="n">eeg</span><span class="o">=</span><span class="n">meanNormdAc</span><span class="p">,</span>
        <span class="n">binWidthSecs</span><span class="o">=</span><span class="n">acBinSize</span><span class="p">,</span>
        <span class="n">maxFreq</span><span class="o">=</span><span class="n">maxFreq</span><span class="p">,</span>
        <span class="n">pad2pow</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;meanNormdAc&quot;</span><span class="p">:</span> <span class="n">meanNormdAc</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
            <span class="n">autoCorrGrid</span><span class="p">,</span>
            <span class="n">extent</span><span class="o">=</span><span class="p">[</span>
                <span class="n">maxFreq</span> <span class="o">*</span> <span class="mf">0.6</span><span class="p">,</span>
                <span class="n">maxFreq</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s2">&quot;Power&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.6</span><span class="p">,</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.CosineDirectionalTuning.power_spectrum" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">power_spectrum</span><span class="p">(</span><span class="n">eeg</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">binWidthSecs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxFreq</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">pad2pow</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Method used by eeg_power_spectra and intrinsic_freq_autoCorr
Signal in must be mean normalised already</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">power_spectrum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">eeg</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">binWidthSecs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxFreq</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="n">pad2pow</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ymax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method used by eeg_power_spectra and intrinsic_freq_autoCorr</span>
<span class="sd">    Signal in must be mean normalised already</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get raw power spectrum</span>
    <span class="n">nqLim</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">binWidthSecs</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">origLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eeg</span><span class="p">)</span>
    <span class="c1"># if pad2pow is None:</span>
    <span class="c1"># 	fftLen = int(np.power(2, self._nextpow2(origLen)))</span>
    <span class="c1"># else:</span>
    <span class="n">fftLen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad2pow</span><span class="p">))</span>
    <span class="n">fftHalfLen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fftLen</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">fftRes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">eeg</span><span class="p">,</span> <span class="n">fftLen</span><span class="p">)</span>
    <span class="c1"># get power density from fft and discard second half of spectrum</span>
    <span class="n">_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftRes</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">origLen</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">_power</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">fftHalfLen</span><span class="p">::])</span>
    <span class="n">power</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="c1"># calculate freqs and crop spectrum to requested range</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">nqLim</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fftHalfLen</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">freqs</span> <span class="o">&lt;=</span> <span class="n">maxFreq</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)]</span>

    <span class="c1"># smooth spectrum using gaussian kernel</span>
    <span class="n">binsPerHz</span> <span class="o">=</span> <span class="p">(</span><span class="n">fftHalfLen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nqLim</span>
    <span class="n">kernelLen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smthKernelWidth</span> <span class="o">*</span> <span class="n">binsPerHz</span><span class="p">)</span>
    <span class="n">kernelSig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smthKernelSigma</span> <span class="o">*</span> <span class="n">binsPerHz</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">kernelLen</span><span class="p">,</span> <span class="n">kernelSig</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">kernelLen</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">power_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>

    <span class="c1"># calculate some metrics</span>
    <span class="c1"># find max in theta band</span>
    <span class="n">spectrumMaskBand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
        <span class="n">freqs</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">bandMaxPower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">power_sm</span><span class="p">[</span><span class="n">spectrumMaskBand</span><span class="p">])</span>
    <span class="n">maxBinInBand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">power_sm</span><span class="p">[</span><span class="n">spectrumMaskBand</span><span class="p">])</span>
    <span class="n">bandFreqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">spectrumMaskBand</span><span class="p">]</span>
    <span class="n">freqAtBandMaxPower</span> <span class="o">=</span> <span class="n">bandFreqs</span><span class="p">[</span><span class="n">maxBinInBand</span><span class="p">]</span>
    <span class="c1"># self.maxBinInBand = maxBinInBand</span>
    <span class="c1"># self.freqAtBandMaxPower = freqAtBandMaxPower</span>
    <span class="c1"># self.bandMaxPower = bandMaxPower</span>

    <span class="c1"># find power in small window around peak and divide by power in rest</span>
    <span class="c1"># of spectrum to get snr</span>
    <span class="n">spectrumMaskPeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
        <span class="n">freqs</span> <span class="o">&gt;</span> <span class="n">freqAtBandMaxPower</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sn2Width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">freqs</span> <span class="o">&lt;</span> <span class="n">freqAtBandMaxPower</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sn2Width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">s2n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">power_sm</span><span class="p">[</span><span class="n">spectrumMaskPeak</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
        <span class="n">power_sm</span><span class="p">[</span><span class="o">~</span><span class="n">spectrumMaskPeak</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">power_sm</span> <span class="o">=</span> <span class="n">power_sm</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">spectrumMaskPeak</span> <span class="o">=</span> <span class="n">spectrumMaskPeak</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ymax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">power</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">power_sm</span><span class="p">)])</span>
            <span class="k">if</span> <span class="n">ymax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">])</span>
        <span class="c1"># ax.hold(True)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power_sm</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">stemlines</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">stem</span><span class="p">([</span><span class="n">freqAtBandMaxPower</span><span class="p">],</span> <span class="p">[</span><span class="n">bandMaxPower</span><span class="p">],</span> <span class="n">linefmt</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="c1"># plt.setp(stemlines, &#39;linewidth&#39;, 2)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">power_sm</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">spectrumMaskPeak</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
            <span class="n">zorder</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># ax.set_ylim(0, ymax)</span>
        <span class="c1"># ax.set_xlim(0, self.xmax)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power density (W/Hz)&quot;</span><span class="p">)</span>
    <span class="n">out_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;maxFreq&quot;</span><span class="p">:</span> <span class="n">freqAtBandMaxPower</span><span class="p">,</span>
        <span class="s2">&quot;Power&quot;</span><span class="p">:</span> <span class="n">power_sm</span><span class="p">,</span>
        <span class="s2">&quot;Freqs&quot;</span><span class="p">:</span> <span class="n">freqs</span><span class="p">,</span>
        <span class="s2">&quot;s2n&quot;</span><span class="p">:</span> <span class="n">s2n</span><span class="p">,</span>
        <span class="s2">&quot;Power_raw&quot;</span><span class="p">:</span> <span class="n">power</span><span class="p">,</span>
        <span class="s2">&quot;k&quot;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
        <span class="s2">&quot;kernelLen&quot;</span><span class="p">:</span> <span class="n">kernelLen</span><span class="p">,</span>
        <span class="s2">&quot;kernelSig&quot;</span><span class="p">:</span> <span class="n">kernelSig</span><span class="p">,</span>
        <span class="s2">&quot;binsPerHz&quot;</span><span class="p">:</span> <span class="n">binsPerHz</span><span class="p">,</span>
        <span class="s2">&quot;kernelLen&quot;</span><span class="p">:</span> <span class="n">kernelLen</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">out_dict</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.CosineDirectionalTuning.speedFilterRuns" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">speedFilterRuns</span><span class="p">(</span><span class="n">runs</span><span class="p">,</span> <span class="n">minspeed</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Given the runs identified in getRunsOfMinLength, filter for speed
and return runs that meet the min speed criteria.</p>
<p>The function goes over the runs with a moving window of length equal
to self.min_runlength in samples and sees if any of those segments
meet the speed criteria and splits them out into separate runs if true.</p>
<p>NB For now this means the same spikes might get included in the
autocorrelation procedure later as the
moving window will use overlapping periods - can be modified later.</p>
<p>Args:
    runs (3 x nRuns np.array): Generated from getRunsOfMinLength
    minspeed (float): Min running speed in cm/s for an epoch (minimum
                      epoch length defined previously
                      in getRunsOfMinLength as minlength, usually 0.4s)</p>
<p>Returns:
    3 x nRuns np.array: A modified version of the "runs" input variable</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">speedFilterRuns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">runs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">minspeed</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the runs identified in getRunsOfMinLength, filter for speed</span>
<span class="sd">    and return runs that meet the min speed criteria.</span>

<span class="sd">    The function goes over the runs with a moving window of length equal</span>
<span class="sd">    to self.min_runlength in samples and sees if any of those segments</span>
<span class="sd">    meet the speed criteria and splits them out into separate runs if true.</span>

<span class="sd">    NB For now this means the same spikes might get included in the</span>
<span class="sd">    autocorrelation procedure later as the</span>
<span class="sd">    moving window will use overlapping periods - can be modified later.</span>

<span class="sd">    Args:</span>
<span class="sd">        runs (3 x nRuns np.array): Generated from getRunsOfMinLength</span>
<span class="sd">        minspeed (float): Min running speed in cm/s for an epoch (minimum</span>
<span class="sd">                          epoch length defined previously</span>
<span class="sd">                          in getRunsOfMinLength as minlength, usually 0.4s)</span>

<span class="sd">    Returns:</span>
<span class="sd">        3 x nRuns np.array: A modified version of the &quot;runs&quot; input variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">minlength_in_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_runlength</span><span class="p">)</span>
    <span class="n">run_list</span> <span class="o">=</span> <span class="n">runs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">all_speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">,</span> <span class="n">dir_bin</span> <span class="ow">in</span> <span class="n">run_list</span><span class="p">:</span>
        <span class="n">this_runs_speed</span> <span class="o">=</span> <span class="n">all_speed</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
        <span class="n">this_runs_runs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rolling_window</span><span class="p">(</span><span class="n">this_runs_speed</span><span class="p">,</span> <span class="n">minlength_in_samples</span><span class="p">)</span>
        <span class="n">run_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this_runs_runs</span> <span class="o">&gt;</span> <span class="n">minspeed</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">run_mask</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got one&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.rhythmicity.LFPOscillations" class="doc doc-heading">
            <code>LFPOscillations</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Does stuff with the LFP such as looking at nested oscillations
(theta/ gamma coupling), the modulation index of such phenomena,
filtering out certain frequencies in the LFP, getting the instantaneous
phase and amplitude and so on</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">LFPOscillations</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Does stuff with the LFP such as looking at nested oscillations</span>
<span class="sd">    (theta/ gamma coupling), the modulation index of such phenomena,</span>
<span class="sd">    filtering out certain frequencies in the LFP, getting the instantaneous</span>
<span class="sd">    phase and amplitude and so on</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span>

    <span class="k">def</span> <span class="nf">getFreqPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">band2filter</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ford</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the Hilbert transform to calculate the instantaneous phase and</span>
<span class="sd">        amplitude of the time series in sig.</span>

<span class="sd">        Args:</span>
<span class="sd">            sig (np.array): The signal to be analysed</span>
<span class="sd">            ford (int): The order for the Butterworth filter</span>
<span class="sd">            band2filter (list): The two frequencies to be filtered for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
        <span class="n">band2filter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">band2filter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">ford</span><span class="p">,</span> <span class="n">band2filter</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;bandpass&quot;</span><span class="p">)</span>

        <span class="n">filt_sig</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s2">&quot;odd&quot;</span><span class="p">)</span>
        <span class="n">hilbert_sig</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">filt_sig</span><span class="p">)</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">hilbert_sig</span><span class="p">)</span>
        <span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hilbert_sig</span><span class="p">)</span>
        <span class="n">inst_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phase</span><span class="p">))</span>
        <span class="n">inst_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">inst_freq</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inst_freq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">amplitude_filtered</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s2">&quot;odd&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filt_sig</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">amplitude_filtered</span><span class="p">,</span> <span class="n">inst_freq</span>

    <span class="k">def</span> <span class="nf">modulationindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nbins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">forder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">thetaband</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
        <span class="n">gammaband</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the modulation index of theta and gamma oscillations.</span>
<span class="sd">        Specifically this is the circular correlation between the phase of</span>
<span class="sd">        theta and the power of theta.</span>

<span class="sd">        Args:</span>
<span class="sd">            sig (np.array): The LFP signal</span>
<span class="sd">            nbins (int): The number of bins in the circular range 0 to 2*pi</span>
<span class="sd">            forder (int): The order of the butterworth filter</span>
<span class="sd">            thetaband (list): The lower/upper bands of the theta freq range</span>
<span class="sd">            gammaband (list): The lower/upper bands of the gamma freq range</span>
<span class="sd">            plot (bool): Show some pics or not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">lowphase</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">thetaband</span><span class="p">,</span> <span class="n">forder</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">highamp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">gammaband</span><span class="p">,</span> <span class="n">forder</span><span class="p">)</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">nbins</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">inc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">inc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">pbins</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbins</span><span class="p">))</span>
        <span class="n">phaselen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lowphase</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbins</span><span class="p">):</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span>
                <span class="p">(</span><span class="n">lowphase</span> <span class="o">&gt;=</span> <span class="n">pbins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">lowphase</span> <span class="o">&lt;</span> <span class="n">pbins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">phaselen</span>
            <span class="p">)</span>
            <span class="n">amp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">highamp</span><span class="p">[</span><span class="n">pts</span><span class="p">])</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">amp</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.common.statscalcs</span> <span class="kn">import</span> <span class="n">circ_r</span>

        <span class="n">mi</span> <span class="o">=</span> <span class="n">circ_r</span><span class="p">(</span><span class="n">pbins</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">amp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">nbins</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">pbins</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">amp</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Modulation index=</span><span class="si">{0:.5f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mi</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">mi</span>

    <span class="k">def</span> <span class="nf">plv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">forder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">thetaband</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
        <span class="n">gammaband</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the phase-amplitude coupling (PAC) of nested oscillations.</span>
<span class="sd">        More specifically this is the phase-locking value (PLV) between two</span>
<span class="sd">        nested oscillations in EEG data, in this case theta (default 4-8Hz)</span>
<span class="sd">        and gamma (defaults to 30-80Hz). A PLV of unity indicates perfect phase</span>
<span class="sd">        locking (here PAC) and a value of zero indicates no locking (no PAC)</span>

<span class="sd">        Args:</span>
<span class="sd">            eeg (numpy array): The eeg data itself. This is a 1-d array which</span>
<span class="sd">            can be masked or not</span>
<span class="sd">            forder (int): The order of the filter(s) applied to the eeg data</span>
<span class="sd">            thetaband, gammaband (list/array): The range of values to bandpass</span>
<span class="sd">            filter for for the theta and gamma ranges</span>
<span class="sd">            plot (bool, optional): Whether to plot the resulting binned up</span>
<span class="sd">            polar plot which shows the amplitude of the gamma oscillation</span>
<span class="sd">            found at different phases of the theta oscillation.</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            plv (float): The value of the phase-amplitude coupling</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">lowphase</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">thetaband</span><span class="p">,</span> <span class="n">forder</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">highamp_f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">gammaband</span><span class="p">,</span> <span class="n">forder</span><span class="p">)</span>

        <span class="n">highampphase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">highamp_f</span><span class="p">))</span>
        <span class="n">phasedf</span> <span class="o">=</span> <span class="n">highampphase</span> <span class="o">-</span> <span class="n">lowphase</span>
        <span class="n">phasedf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phasedf</span><span class="p">)</span>
        <span class="n">phasedf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">phasedf</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.common.statscalcs</span> <span class="kn">import</span> <span class="n">circ_r</span>

        <span class="n">plv</span> <span class="o">=</span> <span class="n">circ_r</span><span class="p">(</span><span class="n">phasedf</span><span class="p">)</span>
        <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">phasedf</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phasedf</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">10</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">plv</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">h</span>

    <span class="k">def</span> <span class="nf">filterForLaser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">dip</span><span class="o">=</span><span class="mf">15.0</span><span class="p">,</span> <span class="n">stimFreq</span><span class="o">=</span><span class="mf">6.66</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to filter out frequencies from optogenetic experiments where</span>
<span class="sd">        the frequency of laser stimulation was at 6.66Hz.</span>

<span class="sd">        Note:</span>
<span class="sd">            This method needs tweaking for each trial as the power in the signal</span>
<span class="sd">            is variable across trials / animals etc. A potential improvement could be using mean</span>
<span class="sd">            power or a similar metric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">filtfilt</span><span class="p">,</span> <span class="n">firwin</span><span class="p">,</span> <span class="n">kaiserord</span>

        <span class="n">nyq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">nyq</span>
        <span class="n">dip</span> <span class="o">=</span> <span class="n">dip</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">kaiserord</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;N: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">beta: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nyq</span> <span class="o">/</span> <span class="n">stimFreq</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">stimFreq</span><span class="p">,</span> <span class="n">upper</span> <span class="o">*</span> <span class="n">stimFreq</span><span class="p">,</span> <span class="n">stimFreq</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">])</span>
        <span class="n">cutoff_hz</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">cutoff_hz</span> <span class="o">=</span> <span class="n">cutoff_hz</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">cutoff_hz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cutoff_hz</span><span class="p">,</span> <span class="n">nyq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cutoff_hz</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">cutoff_hz_nyq</span> <span class="o">=</span> <span class="n">cutoff_hz</span> <span class="o">/</span> <span class="n">nyq</span>
        <span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">cutoff_hz_nyq</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;kaiser&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
        <span class="n">fx</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">taps</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fx</span>

    <span class="k">def</span> <span class="nf">theta_running</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">:</span> <span class="n">PosCalcsGeneric</span><span class="p">,</span> <span class="n">lfp_data</span><span class="p">:</span> <span class="n">EEGCalcsGeneric</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns metrics to do with the theta frequency/ power and running speed/ acceleration</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">low_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;low_theta&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">high_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;high_theta&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
        <span class="n">low_speed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;low_speed&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">high_speed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;high_speed&quot;</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;nbins&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">inst_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span>
            <span class="n">lfp_data</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="n">band2filter</span><span class="o">=</span><span class="p">[</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># interpolate speed to match the frequency of the LFP data</span>
        <span class="n">eeg_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">lfp_data</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">lfp_data</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lfp_data</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">pos_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span>
        <span class="n">interpolated_speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">eeg_time</span><span class="p">,</span> <span class="n">pos_time</span><span class="p">,</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span>
            <span class="p">[</span><span class="n">inst_freq</span><span class="p">,</span> <span class="n">interpolated_speed</span><span class="p">],</span>
            <span class="n">bins</span><span class="o">=</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">,</span> <span class="n">nbins</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low_speed</span><span class="p">,</span> <span class="n">high_speed</span><span class="p">,</span> <span class="n">nbins</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="c1"># overlay the mean points for each speed bin</span>
        <span class="n">spd_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low_speed</span><span class="p">,</span> <span class="n">high_speed</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__freq_calc__</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">fn</span><span class="p">(</span>
                    <span class="n">inst_freq</span><span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">interpolated_speed</span> <span class="o">&gt;</span> <span class="n">s1</span><span class="p">,</span> <span class="n">interpolated_speed</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="p">]</span>

        <span class="n">mean_freqs</span> <span class="o">=</span> <span class="n">__freq_calc__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">pos_data</span><span class="o">.</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="n">s1</span><span class="p">,</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">]</span>
        <span class="n">std_freqs</span> <span class="o">=</span> <span class="n">__freq_calc__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
            <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">h</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;bone_r&quot;</span><span class="p">],</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">mean_freqs</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">std_freqs</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;r.&quot;</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Running speed (cm/s)&quot;</span><span class="p">)</span>
        <span class="c1"># mask the speed and lfp vectors so we can return these based</span>
        <span class="c1"># on the low/high bounds of speed &amp; theta for doing correlations/</span>
        <span class="c1"># stats later</span>
        <span class="n">speed_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">interpolated_speed</span><span class="p">,</span> <span class="n">low_speed</span><span class="p">,</span> <span class="n">high_speed</span><span class="p">)</span>
        <span class="n">theta_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">inst_freq</span><span class="p">,</span> <span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">)</span>
        <span class="c1"># extract both masks, combine and re-apply</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">speed_masked</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">theta_masked</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">speed_masked</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="n">theta_masked</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="c1"># do the linear regression to add to the plot</span>
        <span class="c1"># alternative argument here says we expect the correlation to be positive</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span>
            <span class="n">speed_masked</span><span class="o">.</span><span class="n">compressed</span><span class="p">(),</span> <span class="n">theta_masked</span><span class="o">.</span><span class="n">compressed</span><span class="p">(),</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;greater&quot;</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">intercept</span> <span class="o">+</span> <span class="n">res</span><span class="o">.</span><span class="n">slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;r--&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;r = </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">rvalue</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, p = </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">pvalue</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, intercept = </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">intercept</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">speed_masked</span><span class="p">,</span> <span class="n">theta_masked</span>

    <span class="k">def</span> <span class="nf">get_theta_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the phase of theta at which a cluster emitted spikes</span>
<span class="sd">        and returns a fit to a vonmises distribution</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_times (np.ndarray) - the times the cluster emitted spikes in</span>
<span class="sd">                                     seconds</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        kwargs can include:</span>
<span class="sd">            low_theta (int) - low end for bandpass filter</span>
<span class="sd">            high_theta (int) - high end for bandpass filter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">low_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;low_theta&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">high_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;high_theta&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="p">[</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">])</span>
        <span class="c1"># get indices into the phase vector</span>
        <span class="n">phase_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_times</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># It&#39;s possible that there are indices higher than the length of</span>
        <span class="c1"># the phase vector so lets set them to the last index</span>
        <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">phase_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phase_idx</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># get some stats for fitting to a vonmises</span>
        <span class="n">kappa</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">vonmises</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">phase</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">])</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">501</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">loc</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">i0</span><span class="p">(</span><span class="n">kappa</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">phase</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">spike_xy_phase_plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">pos_data</span><span class="p">:</span> <span class="n">PosCalcsGeneric</span><span class="p">,</span>
        <span class="n">phy_data</span><span class="p">:</span> <span class="n">TemplateModel</span><span class="p">,</span>
        <span class="n">lfp_data</span><span class="p">:</span> <span class="n">EEGCalcsGeneric</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces a plot of the phase of theta at which each spike was</span>
<span class="sd">        emitted. Each spike is plotted according to the x-y location the</span>
<span class="sd">        animal was in when it was fired and the colour of the marker</span>
<span class="sd">        corresponds to the phase of theta at which it fired.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">lfp_data</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
        <span class="n">cluster_times</span> <span class="o">=</span> <span class="n">phy_data</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span>
            <span class="n">phy_data</span><span class="o">.</span><span class="n">spike_clusters</span> <span class="o">==</span> <span class="n">cluster</span>
        <span class="p">]</span>  <span class="c1"># in seconds</span>
        <span class="c1"># get indices into the phase vector</span>
        <span class="n">phase_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_times</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># It&#39;s possible that there are indices higher than the length of</span>
        <span class="c1"># the phase vector so lets set them to the last index</span>
        <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">phase_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phase_idx</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># get indices into the position data</span>
        <span class="n">pos_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_times</span> <span class="o">*</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">pos_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_data</span><span class="o">.</span><span class="n">xyTS</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pos_idx</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_data</span><span class="o">.</span><span class="n">xyTS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># add PI to phases to remove negativity</span>
        <span class="c1"># cluster_phases = phase[phase_idx]</span>
        <span class="c1"># TODO: create the colour map for phase and plot</span>
        <span class="n">spike_xy</span> <span class="o">=</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">pos_idx</span><span class="p">]</span>
        <span class="n">spike_phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;hsv&quot;</span><span class="p">]</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos_data</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightgrey&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">spike_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spike_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">spike_phase</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.LFPOscillations.filterForLaser" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">filterForLaser</span><span class="p">(</span><span class="n">sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">dip</span><span class="o">=</span><span class="mf">15.0</span><span class="p">,</span> <span class="n">stimFreq</span><span class="o">=</span><span class="mf">6.66</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Attempts to filter out frequencies from optogenetic experiments where
the frequency of laser stimulation was at 6.66Hz.</p>
<p>Note:
    This method needs tweaking for each trial as the power in the signal
    is variable across trials / animals etc. A potential improvement could be using mean
    power or a similar metric.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">filterForLaser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">dip</span><span class="o">=</span><span class="mf">15.0</span><span class="p">,</span> <span class="n">stimFreq</span><span class="o">=</span><span class="mf">6.66</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempts to filter out frequencies from optogenetic experiments where</span>
<span class="sd">    the frequency of laser stimulation was at 6.66Hz.</span>

<span class="sd">    Note:</span>
<span class="sd">        This method needs tweaking for each trial as the power in the signal</span>
<span class="sd">        is variable across trials / animals etc. A potential improvement could be using mean</span>
<span class="sd">        power or a similar metric.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">filtfilt</span><span class="p">,</span> <span class="n">firwin</span><span class="p">,</span> <span class="n">kaiserord</span>

    <span class="n">nyq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">nyq</span>
    <span class="n">dip</span> <span class="o">=</span> <span class="n">dip</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">kaiserord</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;N: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">beta: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nyq</span> <span class="o">/</span> <span class="n">stimFreq</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">stimFreq</span><span class="p">,</span> <span class="n">upper</span> <span class="o">*</span> <span class="n">stimFreq</span><span class="p">,</span> <span class="n">stimFreq</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">])</span>
    <span class="n">cutoff_hz</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">cutoff_hz</span> <span class="o">=</span> <span class="n">cutoff_hz</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">cutoff_hz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cutoff_hz</span><span class="p">,</span> <span class="n">nyq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cutoff_hz</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">cutoff_hz_nyq</span> <span class="o">=</span> <span class="n">cutoff_hz</span> <span class="o">/</span> <span class="n">nyq</span>
    <span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">cutoff_hz_nyq</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;kaiser&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">taps</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">sig</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.LFPOscillations.getFreqPhase" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">band2filter</span><span class="p">,</span> <span class="n">ford</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Uses the Hilbert transform to calculate the instantaneous phase and
amplitude of the time series in sig.</p>
<p>Args:
    sig (np.array): The signal to be analysed
    ford (int): The order for the Butterworth filter
    band2filter (list): The two frequencies to be filtered for</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getFreqPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">band2filter</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ford</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uses the Hilbert transform to calculate the instantaneous phase and</span>
<span class="sd">    amplitude of the time series in sig.</span>

<span class="sd">    Args:</span>
<span class="sd">        sig (np.array): The signal to be analysed</span>
<span class="sd">        ford (int): The order for the Butterworth filter</span>
<span class="sd">        band2filter (list): The two frequencies to be filtered for</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
    <span class="n">band2filter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">band2filter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">ford</span><span class="p">,</span> <span class="n">band2filter</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;bandpass&quot;</span><span class="p">)</span>

    <span class="n">filt_sig</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s2">&quot;odd&quot;</span><span class="p">)</span>
    <span class="n">hilbert_sig</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">filt_sig</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">hilbert_sig</span><span class="p">)</span>
    <span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hilbert_sig</span><span class="p">)</span>
    <span class="n">inst_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phase</span><span class="p">))</span>
    <span class="n">inst_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">inst_freq</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inst_freq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">amplitude_filtered</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s2">&quot;odd&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filt_sig</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">amplitude_filtered</span><span class="p">,</span> <span class="n">inst_freq</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.LFPOscillations.get_theta_phase" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_theta_phase</span><span class="p">(</span><span class="n">cluster_times</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculates the phase of theta at which a cluster emitted spikes
and returns a fit to a vonmises distribution</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster_times</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <pre><code>                     seconds
</code></pre>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Notes</summary>
  <p>kwargs can include:
    low_theta (int) - low end for bandpass filter
    high_theta (int) - high end for bandpass filter</p>
</details>
            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_theta_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the phase of theta at which a cluster emitted spikes</span>
<span class="sd">    and returns a fit to a vonmises distribution</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster_times (np.ndarray) - the times the cluster emitted spikes in</span>
<span class="sd">                                 seconds</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    kwargs can include:</span>
<span class="sd">        low_theta (int) - low end for bandpass filter</span>
<span class="sd">        high_theta (int) - high end for bandpass filter</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">low_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;low_theta&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">high_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;high_theta&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="p">[</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">])</span>
    <span class="c1"># get indices into the phase vector</span>
    <span class="n">phase_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_times</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># It&#39;s possible that there are indices higher than the length of</span>
    <span class="c1"># the phase vector so lets set them to the last index</span>
    <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">phase_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">phase_idx</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># get some stats for fitting to a vonmises</span>
    <span class="n">kappa</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">vonmises</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">phase</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">])</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">501</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">loc</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">i0</span><span class="p">(</span><span class="n">kappa</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">phase</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.LFPOscillations.modulationindex" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">modulationindex</span><span class="p">(</span><span class="n">sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">forder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">thetaband</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">gammaband</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculates the modulation index of theta and gamma oscillations.
Specifically this is the circular correlation between the phase of
theta and the power of theta.</p>
<p>Args:
    sig (np.array): The LFP signal
    nbins (int): The number of bins in the circular range 0 to 2*pi
    forder (int): The order of the butterworth filter
    thetaband (list): The lower/upper bands of the theta freq range
    gammaband (list): The lower/upper bands of the gamma freq range
    plot (bool): Show some pics or not</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">modulationindex</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">nbins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">forder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">thetaband</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
    <span class="n">gammaband</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the modulation index of theta and gamma oscillations.</span>
<span class="sd">    Specifically this is the circular correlation between the phase of</span>
<span class="sd">    theta and the power of theta.</span>

<span class="sd">    Args:</span>
<span class="sd">        sig (np.array): The LFP signal</span>
<span class="sd">        nbins (int): The number of bins in the circular range 0 to 2*pi</span>
<span class="sd">        forder (int): The order of the butterworth filter</span>
<span class="sd">        thetaband (list): The lower/upper bands of the theta freq range</span>
<span class="sd">        gammaband (list): The lower/upper bands of the gamma freq range</span>
<span class="sd">        plot (bool): Show some pics or not</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">lowphase</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">thetaband</span><span class="p">,</span> <span class="n">forder</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">highamp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">gammaband</span><span class="p">,</span> <span class="n">forder</span><span class="p">)</span>
    <span class="n">inc</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">nbins</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">inc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">inc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">pbins</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbins</span><span class="p">))</span>
    <span class="n">phaselen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lowphase</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbins</span><span class="p">):</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span>
            <span class="p">(</span><span class="n">lowphase</span> <span class="o">&gt;=</span> <span class="n">pbins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">lowphase</span> <span class="o">&lt;</span> <span class="n">pbins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">phaselen</span>
        <span class="p">)</span>
        <span class="n">amp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">highamp</span><span class="p">[</span><span class="n">pts</span><span class="p">])</span>
    <span class="n">amp</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">amp</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">ephysiopy.common.statscalcs</span> <span class="kn">import</span> <span class="n">circ_r</span>

    <span class="n">mi</span> <span class="o">=</span> <span class="n">circ_r</span><span class="p">(</span><span class="n">pbins</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">amp</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">nbins</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">pbins</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">amp</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Modulation index=</span><span class="si">{0:.5f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mi</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mi</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.LFPOscillations.plv" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plv</span><span class="p">(</span><span class="n">sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">forder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">thetaband</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">gammaband</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Computes the phase-amplitude coupling (PAC) of nested oscillations.
More specifically this is the phase-locking value (PLV) between two
nested oscillations in EEG data, in this case theta (default 4-8Hz)
and gamma (defaults to 30-80Hz). A PLV of unity indicates perfect phase
locking (here PAC) and a value of zero indicates no locking (no PAC)</p>
<p>Args:
    eeg (numpy array): The eeg data itself. This is a 1-d array which
    can be masked or not
    forder (int): The order of the filter(s) applied to the eeg data
    thetaband, gammaband (list/array): The range of values to bandpass
    filter for for the theta and gamma ranges
    plot (bool, optional): Whether to plot the resulting binned up
    polar plot which shows the amplitude of the gamma oscillation
    found at different phases of the theta oscillation.
    Default is True.</p>
<p>Returns:
    plv (float): The value of the phase-amplitude coupling</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">plv</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">forder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">thetaband</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
    <span class="n">gammaband</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the phase-amplitude coupling (PAC) of nested oscillations.</span>
<span class="sd">    More specifically this is the phase-locking value (PLV) between two</span>
<span class="sd">    nested oscillations in EEG data, in this case theta (default 4-8Hz)</span>
<span class="sd">    and gamma (defaults to 30-80Hz). A PLV of unity indicates perfect phase</span>
<span class="sd">    locking (here PAC) and a value of zero indicates no locking (no PAC)</span>

<span class="sd">    Args:</span>
<span class="sd">        eeg (numpy array): The eeg data itself. This is a 1-d array which</span>
<span class="sd">        can be masked or not</span>
<span class="sd">        forder (int): The order of the filter(s) applied to the eeg data</span>
<span class="sd">        thetaband, gammaband (list/array): The range of values to bandpass</span>
<span class="sd">        filter for for the theta and gamma ranges</span>
<span class="sd">        plot (bool, optional): Whether to plot the resulting binned up</span>
<span class="sd">        polar plot which shows the amplitude of the gamma oscillation</span>
<span class="sd">        found at different phases of the theta oscillation.</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        plv (float): The value of the phase-amplitude coupling</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">lowphase</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">thetaband</span><span class="p">,</span> <span class="n">forder</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">highamp_f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">gammaband</span><span class="p">,</span> <span class="n">forder</span><span class="p">)</span>

    <span class="n">highampphase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">highamp_f</span><span class="p">))</span>
    <span class="n">phasedf</span> <span class="o">=</span> <span class="n">highampphase</span> <span class="o">-</span> <span class="n">lowphase</span>
    <span class="n">phasedf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phasedf</span><span class="p">)</span>
    <span class="n">phasedf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">phasedf</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">ephysiopy.common.statscalcs</span> <span class="kn">import</span> <span class="n">circ_r</span>

    <span class="n">plv</span> <span class="o">=</span> <span class="n">circ_r</span><span class="p">(</span><span class="n">phasedf</span><span class="p">)</span>
    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">phasedf</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phasedf</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">10</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">plv</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">h</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.LFPOscillations.spike_xy_phase_plot" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">spike_xy_phase_plot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">lfp_data</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Produces a plot of the phase of theta at which each spike was
emitted. Each spike is plotted according to the x-y location the
animal was in when it was fired and the colour of the marker
corresponds to the phase of theta at which it fired.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">spike_xy_phase_plot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pos_data</span><span class="p">:</span> <span class="n">PosCalcsGeneric</span><span class="p">,</span>
    <span class="n">phy_data</span><span class="p">:</span> <span class="n">TemplateModel</span><span class="p">,</span>
    <span class="n">lfp_data</span><span class="p">:</span> <span class="n">EEGCalcsGeneric</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produces a plot of the phase of theta at which each spike was</span>
<span class="sd">    emitted. Each spike is plotted according to the x-y location the</span>
<span class="sd">    animal was in when it was fired and the colour of the marker</span>
<span class="sd">    corresponds to the phase of theta at which it fired.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span><span class="n">lfp_data</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
    <span class="n">cluster_times</span> <span class="o">=</span> <span class="n">phy_data</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span>
        <span class="n">phy_data</span><span class="o">.</span><span class="n">spike_clusters</span> <span class="o">==</span> <span class="n">cluster</span>
    <span class="p">]</span>  <span class="c1"># in seconds</span>
    <span class="c1"># get indices into the phase vector</span>
    <span class="n">phase_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_times</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># It&#39;s possible that there are indices higher than the length of</span>
    <span class="c1"># the phase vector so lets set them to the last index</span>
    <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">phase_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">phase_idx</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># get indices into the position data</span>
    <span class="n">pos_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_times</span> <span class="o">*</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">pos_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_data</span><span class="o">.</span><span class="n">xyTS</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pos_idx</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_data</span><span class="o">.</span><span class="n">xyTS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># add PI to phases to remove negativity</span>
    <span class="c1"># cluster_phases = phase[phase_idx]</span>
    <span class="c1"># TODO: create the colour map for phase and plot</span>
    <span class="n">spike_xy</span> <span class="o">=</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">pos_idx</span><span class="p">]</span>
    <span class="n">spike_phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;hsv&quot;</span><span class="p">]</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos_data</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightgrey&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">spike_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spike_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">spike_phase</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.LFPOscillations.theta_running" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">theta_running</span><span class="p">(</span><span class="n">pos_data</span><span class="p">,</span> <span class="n">lfp_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns metrics to do with the theta frequency/ power and running speed/ acceleration</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">theta_running</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">:</span> <span class="n">PosCalcsGeneric</span><span class="p">,</span> <span class="n">lfp_data</span><span class="p">:</span> <span class="n">EEGCalcsGeneric</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns metrics to do with the theta frequency/ power and running speed/ acceleration</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">low_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;low_theta&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">high_theta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;high_theta&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">low_speed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;low_speed&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">high_speed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;high_speed&quot;</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
    <span class="n">nbins</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;nbins&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">inst_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFreqPhase</span><span class="p">(</span>
        <span class="n">lfp_data</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="n">band2filter</span><span class="o">=</span><span class="p">[</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="c1"># interpolate speed to match the frequency of the LFP data</span>
    <span class="n">eeg_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">lfp_data</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">lfp_data</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lfp_data</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">pos_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span>
    <span class="n">interpolated_speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">eeg_time</span><span class="p">,</span> <span class="n">pos_time</span><span class="p">,</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span>
        <span class="p">[</span><span class="n">inst_freq</span><span class="p">,</span> <span class="n">interpolated_speed</span><span class="p">],</span>
        <span class="n">bins</span><span class="o">=</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">,</span> <span class="n">nbins</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low_speed</span><span class="p">,</span> <span class="n">high_speed</span><span class="p">,</span> <span class="n">nbins</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="c1"># overlay the mean points for each speed bin</span>
    <span class="n">spd_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low_speed</span><span class="p">,</span> <span class="n">high_speed</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__freq_calc__</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">fn</span><span class="p">(</span>
                <span class="n">inst_freq</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">interpolated_speed</span> <span class="o">&gt;</span> <span class="n">s1</span><span class="p">,</span> <span class="n">interpolated_speed</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">]</span>

    <span class="n">mean_freqs</span> <span class="o">=</span> <span class="n">__freq_calc__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">pos_data</span><span class="o">.</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="n">s1</span><span class="p">,</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="p">]</span>
    <span class="n">std_freqs</span> <span class="o">=</span> <span class="n">__freq_calc__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
        <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">h</span><span class="p">,</span>
        <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;bone_r&quot;</span><span class="p">],</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">mean_freqs</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">std_freqs</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;r.&quot;</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Running speed (cm/s)&quot;</span><span class="p">)</span>
    <span class="c1"># mask the speed and lfp vectors so we can return these based</span>
    <span class="c1"># on the low/high bounds of speed &amp; theta for doing correlations/</span>
    <span class="c1"># stats later</span>
    <span class="n">speed_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">interpolated_speed</span><span class="p">,</span> <span class="n">low_speed</span><span class="p">,</span> <span class="n">high_speed</span><span class="p">)</span>
    <span class="n">theta_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">inst_freq</span><span class="p">,</span> <span class="n">low_theta</span><span class="p">,</span> <span class="n">high_theta</span><span class="p">)</span>
    <span class="c1"># extract both masks, combine and re-apply</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">speed_masked</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">theta_masked</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">speed_masked</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="n">theta_masked</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="c1"># do the linear regression to add to the plot</span>
    <span class="c1"># alternative argument here says we expect the correlation to be positive</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span>
        <span class="n">speed_masked</span><span class="o">.</span><span class="n">compressed</span><span class="p">(),</span> <span class="n">theta_masked</span><span class="o">.</span><span class="n">compressed</span><span class="p">(),</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;greater&quot;</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">intercept</span> <span class="o">+</span> <span class="n">res</span><span class="o">.</span><span class="n">slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">spd_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;r--&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;r = </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">rvalue</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, p = </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">pvalue</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, intercept = </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">intercept</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">speed_masked</span><span class="p">,</span> <span class="n">theta_masked</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.rhythmicity.Rippler" class="doc doc-heading">
            <code>Rippler</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Does some spectrographic analysis and plots of LFP data
looking specifically at the ripple band</p>
<p>Until I modified the Ripple Detector plugin the duration of the TTL
pulses was variable with a more or less bimodal distribution which
is why there is a separate treatment of short and long duration TTL pulses below</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Rippler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Does some spectrographic analysis and plots of LFP data</span>
<span class="sd">    looking specifically at the ripple band</span>

<span class="sd">    Until I modified the Ripple Detector plugin the duration of the TTL</span>
<span class="sd">    pulses was variable with a more or less bimodal distribution which</span>
<span class="sd">    is why there is a separate treatment of short and long duration TTL pulses below</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_channels</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="c1"># time units are seconds, frequencies and sample rates in Hz</span>
    <span class="n">pre_ttl</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">post_ttl</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">min_ttl_duration</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="c1"># Not all TTL &quot;events&quot; in OE parlance result in a laser pulse as I modified</span>
    <span class="c1"># the plugin so that only x percent are sent to the ttl &quot;out&quot; line that goes</span>
    <span class="c1"># to the laser. All TTL events *are* recorded however on a separate TTL line</span>
    <span class="c1"># that here I am calling ttl_all_line as opposed to ttl_out_line which is the</span>
    <span class="c1"># line that goes to the laser - these values are overwritten when the Ripple</span>
    <span class="c1"># Detector plugin settings are loaded in __init__</span>
    <span class="n">ttl_all_line</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">ttl_out_line</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ttl_percent</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">100</span>  <span class="c1"># percentage of the ripple detections that get propagated to laser</span>
    <span class="p">)</span>
    <span class="n">ttl_duration</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># minimum duration of TTL pulse in seconds</span>
    <span class="n">low_band</span> <span class="o">=</span> <span class="mi">120</span>  <span class="c1"># Hz</span>
    <span class="n">high_band</span> <span class="o">=</span> <span class="mi">250</span>  <span class="c1"># Hz</span>
    <span class="n">bit_volts</span> <span class="o">=</span> <span class="mf">0.1949999928474426</span>  <span class="c1"># available in the structure.oebin file</span>
    <span class="c1"># some parameters for the FFT stuff</span>
    <span class="n">gaussian_window</span> <span class="o">=</span> <span class="mi">12</span>  <span class="c1"># in samples</span>
    <span class="n">gaussian_std</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">lfp_plotting_scale</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">500</span>  <span class="c1"># this is the scale/range I was looking at the ripple filtered lfp signal</span>
    <span class="p">)</span>
    <span class="n">ripple_std_dev</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">ripple_min_duration_ms</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        trial_root (Path) - location of the root recording directory, used to load ttls etc</span>
<span class="sd">        signal (np.ndarray) - the LFP signal (usually downsampled to about 500-1000Hz)</span>
<span class="sd">        fs (int) - the sampling rate of the signal</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pname_for_trial</span> <span class="o">=</span> <span class="n">trial_root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_sig</span> <span class="o">=</span> <span class="n">signal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">trial_root</span><span class="p">))</span>
        <span class="n">LFP</span> <span class="o">=</span> <span class="n">EEGCalcsGeneric</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LFP</span> <span class="o">=</span> <span class="n">LFP</span>
        <span class="n">detector_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">get_processor</span><span class="p">(</span><span class="s2">&quot;Ripple&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ttl_duration</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">ttl_duration</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="p">)</span>  <span class="c1"># in seconds now</span>

        <span class="n">pname_for_ttl_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_path_to_ripple_ttl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname_for_trial</span><span class="p">)</span>
        <span class="n">sync_file</span> <span class="o">=</span> <span class="n">pname_for_ttl_data</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;sync_messages.txt&quot;</span><span class="p">)</span>
        <span class="n">recording_start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_start_time</span><span class="p">(</span><span class="n">sync_file</span><span class="p">)</span>
        <span class="n">ttl_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pname_for_ttl_data</span> <span class="o">/</span> <span class="s2">&quot;timestamps.npy&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">recording_start_time</span>
        <span class="n">ttl_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pname_for_ttl_data</span> <span class="o">/</span> <span class="s2">&quot;states.npy&quot;</span><span class="p">)</span>
        <span class="n">all_ons</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_save</span><span class="p">)]</span>
        <span class="n">laser_ons</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_Out</span><span class="p">)]</span>
        <span class="n">laser_offs</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_Out</span><span class="p">)]</span>
        <span class="n">no_laser_ons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_ons</span><span class="p">,</span> <span class="n">laser_ons</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_on_ts</span> <span class="o">=</span> <span class="n">all_ons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ttl_states</span> <span class="o">=</span> <span class="n">ttl_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_ts</span> <span class="o">=</span> <span class="n">ttl_ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span> <span class="o">=</span> <span class="n">laser_ons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_ts</span> <span class="o">=</span> <span class="n">laser_offs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span> <span class="o">=</span> <span class="n">no_laser_ons</span>

        <span class="n">filtered_eeg</span> <span class="o">=</span> <span class="n">LFP</span><span class="o">.</span><span class="n">butterFilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">low_band</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_band</span><span class="p">)</span>
        <span class="n">filtered_eeg</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bit_volts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span> <span class="o">=</span> <span class="n">filtered_eeg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">LFP</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">LFP</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>  <span class="c1"># in seconds</span>

    <span class="k">def</span> <span class="nf">update_bandpass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_band</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_band</span> <span class="o">=</span> <span class="n">low</span>
        <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_band</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high_band</span> <span class="o">=</span> <span class="n">high</span>
        <span class="n">filtered_eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LFP</span><span class="o">.</span><span class="n">butterFilter</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="n">filtered_eeg</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bit_volts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span> <span class="o">=</span> <span class="n">filtered_eeg</span>

    <span class="k">def</span> <span class="nf">_load_start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_sync_message_file</span><span class="p">:</span> <span class="n">Path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the start time contained in a sync file from OE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">recording_start_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_to_sync_message_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">sync_strs</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">sync_lines</span> <span class="o">=</span> <span class="n">sync_strs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sync_lines</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;Start Time&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                    <span class="n">start_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">start_time</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">recording_start_time</span>

    <span class="k">def</span> <span class="nf">_find_path_to_continuous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates through a directory tree and finds the path to the</span>
<span class="sd">        Ripple Detector plugin data and returns its location</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exp_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;experiment&quot;</span><span class="p">,</span> <span class="s2">&quot;experiment1&quot;</span><span class="p">)</span>
        <span class="n">rec_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;recording&quot;</span><span class="p">,</span> <span class="s2">&quot;recording1&quot;</span><span class="p">)</span>
        <span class="n">folder_match</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">trial_root</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Record Node [0-9][0-9][0-9]&quot;</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">exp_name</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">rec_name</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;events&quot;</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Acquisition_Board-[0-9][0-9][0-9].*&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">trial_root</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>  <span class="c1"># ignore hidden directories</span>
                    <span class="k">if</span> <span class="s2">&quot;continuous.dat&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">folder_match</span><span class="p">)):</span>
                            <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Path</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_find_path_to_ripple_ttl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates through a directory tree and finds the path to the</span>
<span class="sd">        Ripple Detector plugin data and returns its location</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exp_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;experiment&quot;</span><span class="p">,</span> <span class="s2">&quot;experiment1&quot;</span><span class="p">)</span>
        <span class="n">rec_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;recording&quot;</span><span class="p">,</span> <span class="s2">&quot;recording1&quot;</span><span class="p">)</span>
        <span class="n">ripple_match</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">trial_root</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Record Node [0-9][0-9][0-9]&quot;</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">exp_name</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">rec_name</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;events&quot;</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Ripple_Detector-[0-9][0-9][0-9].*&quot;</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;TTL&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">trial_root</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>  <span class="c1"># ignore hidden directories</span>
                    <span class="k">if</span> <span class="s2">&quot;timestamps.npy&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ripple_match</span><span class="p">)):</span>
                            <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Path</span><span class="p">()</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_filtered_lfp_chunk</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">end_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&gt;</span> <span class="n">start_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&lt;</span> <span class="n">end_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">eeg_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">normed_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">eeg_chunk</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># in ms</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>  <span class="c1"># enlarge plot a bit</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">normed_time</span><span class="p">,</span> <span class="n">eeg_chunk</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax1</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax1</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)],</span>
            <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
            <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time to TTL(ms)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax1</span>

    <span class="k">def</span> <span class="nf">plot_rasters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laser_on</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">FigureMaker</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_path_to_continuous</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname_for_trial</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">KiloSortSession</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">)</span>
        <span class="n">F</span><span class="o">.</span><span class="n">ttl_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">laser_on</span><span class="p">:</span>
            <span class="n">F</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span>
            <span class="n">ttls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_ts</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">F</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;stim_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ttls</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1000</span>
            <span class="p">)</span>  <span class="c1"># needs to be in ms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">F</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;ttl_timestamps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span>
            <span class="n">F</span><span class="o">.</span><span class="n">ttl_data</span><span class="p">[</span><span class="s2">&quot;stim_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttl_duration</span>
        <span class="n">K</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
        <span class="n">K</span><span class="o">.</span><span class="n">removeNoiseClusters</span><span class="p">()</span>
        <span class="n">K</span><span class="o">.</span><span class="n">removeKSNoiseClusters</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">K</span><span class="o">.</span><span class="n">good_clusters</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">get_cluster_spike_times</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3e4</span>
            <span class="n">F</span><span class="o">.</span><span class="n">_getRasterPlot</span><span class="p">(</span><span class="n">spk_times</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_and_save_ripple_band_lfp_with_ttl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i_time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span><span class="p">:</span>
            <span class="n">eeg_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&gt;</span> <span class="n">i_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&lt;</span> <span class="n">i_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="n">eeg_chunk_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&gt;</span> <span class="n">i_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&lt;</span> <span class="n">i_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
            <span class="n">axTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">eeg_chunk_time</span><span class="p">,</span> <span class="n">eeg_chunk</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
                <span class="n">Rectangle</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">i_time</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lfp_plotting_scale</span><span class="p">),</span>
                    <span class="n">width</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                    <span class="n">height</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="n">axTrans</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lfp_plotting_scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_plotting_scale</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">fig</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_mean_spectrograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_mean_spectrogram</span><span class="p">(</span><span class="n">laser_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">spec1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_mean_spectrogram</span><span class="p">(</span><span class="n">laser_on</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_spectrogram</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_spectrogram</span> <span class="o">=</span> <span class="n">spec1</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">spec1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">min_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">spec1</span><span class="p">)])</span>
        <span class="n">max_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spec1</span><span class="p">)])</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_clim</span><span class="p">((</span><span class="n">min_im</span><span class="p">,</span> <span class="n">max_im</span><span class="p">))</span>
        <span class="n">im1</span><span class="o">.</span><span class="n">set_clim</span><span class="p">((</span><span class="n">min_im</span><span class="p">,</span> <span class="n">max_im</span><span class="p">))</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">n_no_laser_ttls</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span><span class="p">)</span>
        <span class="n">n_laser_ttls</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Laser off (</span><span class="si">{</span><span class="n">n_no_laser_ttls</span><span class="si">}</span><span class="s2"> events)&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Laser on (</span><span class="si">{</span><span class="n">n_laser_ttls</span><span class="si">}</span><span class="s2"> events)&quot;</span><span class="p">)</span>
        <span class="n">cb_ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.91</span><span class="p">,</span> <span class="mf">0.124</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.754</span><span class="p">])</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
            <span class="n">im1</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Power Spectral Density &quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;$20\,\log_</span><span class="si">{10}</span><span class="s2">|S_x(t, f)|$ in dB&quot;</span><span class="p">,</span>
            <span class="n">cax</span><span class="o">=</span><span class="n">cb_ax</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span>

    <span class="k">def</span> <span class="nf">plot_mean_spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laser_on</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the mean spectrogram for either &#39;long&#39; or &#39;short&#39; ttl events</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;norm&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ttls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_ts</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># max_duration used in plotting output below</span>
        <span class="n">ttl_duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ttls</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">laser_on</span><span class="p">:</span>
            <span class="n">ttls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ttl_duration</span><span class="p">)]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># breakpoint()</span>
        <span class="n">spectrograms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ttl</span> <span class="ow">in</span> <span class="n">ttls</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">SFT</span><span class="p">,</span>
                <span class="n">N</span><span class="p">,</span>
                <span class="n">spec</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spectrogram</span><span class="p">(</span><span class="n">ttl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ttl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">spectrograms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

        <span class="c1"># some spectrograms might be slightly different shapes so</span>
        <span class="c1"># truncate to the shortest length in each dimension</span>
        <span class="n">min_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
        <span class="n">min_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">spec_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ttls</span><span class="p">),</span> <span class="n">min_rows</span><span class="p">,</span> <span class="n">min_cols</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spectrograms</span><span class="p">):</span>
            <span class="n">spec_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">min_rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">min_cols</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>  <span class="c1"># enlarge plot a bit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax</span>
            <span class="n">fig1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">t_lo</span><span class="p">,</span> <span class="n">t_hi</span> <span class="o">=</span> <span class="n">SFT</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">N</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># time range of plot</span>
        <span class="nb">breakpoint</span><span class="p">()</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="n">xlabel</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Time $t$ in seconds (</span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">p_num</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="si">}</span><span class="s2"> slices, &quot;</span>
            <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;$\Delta t = </span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">delta_t</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">\,$s)&quot;</span><span class="p">,</span>
            <span class="n">ylabel</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Freq. $f$ in Hz (</span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">f_pts</span><span class="si">}</span><span class="s2"> bins, &quot;</span>
            <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;$\Delta f = </span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">delta_f</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">\,$Hz)&quot;</span><span class="p">,</span>
            <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">t_lo</span><span class="p">,</span> <span class="n">t_hi</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax1</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax1</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span> <span class="o">+</span> <span class="n">ttl_duration</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
            <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># add an annotation for the ttl duration next in between</span>
        <span class="c1"># the vertical red dashed lines</span>
        <span class="n">ttl_duration_ms</span> <span class="o">=</span> <span class="n">ttl_duration</span>  <span class="c1"># * 1000</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ttl_duration_ms</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2"> ms&quot;</span><span class="p">,</span>
            <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span> <span class="o">+</span> <span class="n">ttl_duration</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
            <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span> <span class="o">+</span> <span class="n">ttl_duration</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
            <span class="n">xycoords</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
            <span class="n">textcoords</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
            <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
            <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;small&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># imshow not respecting the image extents so use pcolormesh</span>
        <span class="c1"># mean_spec_array = np.mean(spec_array, 0)</span>
        <span class="c1"># X, Y = np.meshgrid(</span>
        <span class="c1">#     np.linspace(SFT.extent(N)[0], SFT.extent(N)[1], mean_spec_array.shape[1]),</span>
        <span class="c1">#     np.linspace(SFT.extent(N)[2], SFT.extent(N)[3], mean_spec_array.shape[0]),</span>
        <span class="c1"># )</span>
        <span class="c1"># breakpoint()</span>
        <span class="c1"># im1 = ax1.pcolormesh(</span>
        <span class="c1">#     X, Y, np.mean(spec_array, 0), cmap=&quot;magma&quot;, norm=norm, edgecolors=&quot;face&quot;</span>
        <span class="c1"># )</span>
        <span class="n">im1</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span>
            <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="n">extent</span><span class="o">=</span><span class="n">SFT</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">N</span><span class="p">),</span>
            <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;magma&quot;</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fig1</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">spec_array</span>

    <span class="k">def</span> <span class="nf">get_spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">end_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">eeg_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&gt;</span> <span class="n">start_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&lt;</span> <span class="n">start_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># breakpoint()</span>

        <span class="n">win</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_window</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_std</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">SFT</span> <span class="o">=</span> <span class="n">ShortTimeFFT</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">mfft</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">scale_to</span><span class="o">=</span><span class="s2">&quot;psd&quot;</span><span class="p">)</span>
        <span class="n">Sx2</span> <span class="o">=</span> <span class="n">SFT</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span><span class="n">eeg_chunk</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eeg_chunk</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>  <span class="c1"># enlarge plot a bit</span>
            <span class="n">t_lo</span><span class="p">,</span> <span class="n">t_hi</span> <span class="o">=</span> <span class="n">SFT</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">N</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># time range of plot</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="sa">rf</span><span class="s2">&quot;Spectrogram (</span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">m_num</span><span class="o">*</span><span class="n">SFT</span><span class="o">.</span><span class="n">T</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">$\,s$ Gaussian &quot;</span>
                <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;window, $\sigma_t=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_std</span><span class="o">*</span><span class="n">SFT</span><span class="o">.</span><span class="n">T</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">\,$s)&quot;</span>
            <span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="n">xlabel</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Time $t$ in seconds (</span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">p_num</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="si">}</span><span class="s2"> slices, &quot;</span>
                <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;$\Delta t = </span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">delta_t</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">\,$s)&quot;</span><span class="p">,</span>
                <span class="n">ylabel</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Freq. $f$ in Hz (</span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">f_pts</span><span class="si">}</span><span class="s2"> bins, &quot;</span>
                <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;$\Delta f = </span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">delta_f</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">\,$Hz)&quot;</span><span class="p">,</span>
                <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">t_lo</span><span class="p">,</span> <span class="n">t_hi</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax1</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax1</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span> <span class="o">+</span> <span class="p">(</span><span class="n">start_time</span><span class="p">)],</span>
                <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
                <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">im1</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sx2</span><span class="p">),</span>
                <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span>
                <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="n">SFT</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">N</span><span class="p">),</span>
                <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;magma&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">fig1</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
                <span class="n">im1</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Power Spectral Density &quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;$20\,\log_</span><span class="si">{10}</span><span class="s2">|S_x(t, f)|$ in dB&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SFT</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sx2</span><span class="p">)</span>

    <span class="nd">@savePlot</span>
    <span class="k">def</span> <span class="nf">plot_mean_rippleband_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the mean power in the ripple band for the laser on and no laser</span>
<span class="sd">        conditions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_on_spectrogram</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_off_spectrogram</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_off_spectrogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_band</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_band</span><span class="p">)</span>
            <span class="n">mean_power_on</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_on_spectrogram</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">mean_power_no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_off_spectrogram</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">mean_power_on_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mean_power_on</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">mean_power_off_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mean_power_no</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">mean_power_on_time</span><span class="p">,</span>
                <span class="n">mean_power_on</span><span class="p">,</span>
                <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;on&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">mean_power_off_time</span><span class="p">,</span>
                <span class="n">mean_power_no</span><span class="p">,</span>
                <span class="s2">&quot;k&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;off&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time(s)&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean power between </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">low_band</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">high_band</span><span class="si">}</span><span class="s2">Hz&quot;</span><span class="p">)</span>
            <span class="n">axTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
                <span class="n">Rectangle</span><span class="p">(</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">width</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                    <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="n">axTrans</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Laser on&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">_find_high_power_periods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find periods where the power in the ripple band is above n standard deviations</span>
<span class="sd">        for t samples. Meant to recapitulate the algorithm from the Ripple Detector</span>
<span class="sd">        plugin</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get some detection parameters from the Ripple Detector plugin</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname_for_trial</span><span class="p">)</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get_processor</span><span class="p">(</span><span class="s2">&quot;Ripple&quot;</span><span class="p">)</span>
        <span class="n">rms_window</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s2">&quot;rms_samples&quot;</span><span class="p">))</span>
        <span class="n">ripple_detect_channel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s2">&quot;Ripple_Input&quot;</span><span class="p">))</span>
        <span class="n">ripple_std</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s2">&quot;ripple_std&quot;</span><span class="p">))</span>
        <span class="n">time_thresh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s2">&quot;time_thresh&quot;</span><span class="p">))</span>
        <span class="n">rms_sig</span> <span class="o">=</span> <span class="n">window_rms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span><span class="p">,</span> <span class="n">rms_window</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter_timestamps_for_real_ripples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter out low power and short duration events from the list of timestamps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">laser_on_keep_indices</span><span class="p">,</span> <span class="n">laser_on_run_lens</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_ripple_chunks_duration_power</span><span class="p">(</span><span class="s2">&quot;laser&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">no_laser_keep_indices</span><span class="p">,</span> <span class="n">no_laser_run_lens</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_ripple_chunks_duration_power</span><span class="p">(</span><span class="s2">&quot;no_laser&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_run_lens</span> <span class="o">=</span> <span class="n">laser_on_run_lens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_run_lens</span> <span class="o">=</span> <span class="n">no_laser_run_lens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span><span class="p">[</span><span class="n">laser_on_keep_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_ts</span><span class="p">[</span><span class="n">laser_on_keep_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span><span class="p">[</span><span class="n">no_laser_keep_indices</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_calc_ripple_chunks_duration_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ttl_type</span><span class="o">=</span><span class="s2">&quot;no_laser&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the indices and durations of the events that have sufficient</span>
<span class="sd">        duration and power to be considered ripples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ttl_type (str) - which bit of the trial to do the calculation for</span>
<span class="sd">                         Either &#39;no_laser&#39; or &#39;laser&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple: the run indices to keep and the run durations in ms</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ttl_type</span> <span class="o">==</span> <span class="s2">&quot;no_laser&quot;</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span>
        <span class="k">elif</span> <span class="n">ttl_type</span> <span class="o">==</span> <span class="s2">&quot;laser&quot;</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;ttl_type not recognised. Must be one of &#39;laser&#39; or &#39;no_laser&#39;&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="p">([],)</span>
        <span class="n">eeg_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n_samples</span><span class="p">])</span>
        <span class="n">rms_signal</span> <span class="o">=</span> <span class="n">window_rms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>

        <span class="c1"># Get segments of the root mean squared and smoothed LFP signal</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&gt;</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span>
            <span class="p">)</span>
            <span class="n">eeg_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rms_signal</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Square the whole filtered LFP signal and calculate the mean power</span>
        <span class="n">mean_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rms_signal</span><span class="p">)</span>
        <span class="n">std_dev_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">rms_signal</span><span class="p">)</span>

        <span class="c1"># Find ripples that are ripple_std_dev standard deviations over the</span>
        <span class="c1"># mean power to demarcate the start and end of the ripples and longer</span>
        <span class="c1"># than ripple_min_duration_ms</span>
        <span class="n">indices_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">run_lens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eeg_chunks</span><span class="p">):</span>
            <span class="n">high_power</span> <span class="o">=</span> <span class="n">chunk</span> <span class="o">&gt;</span> <span class="n">mean_power</span> <span class="o">+</span> <span class="n">std_dev_power</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ripple_std_dev</span>
            <span class="n">run_vals</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">run_lengths</span> <span class="o">=</span> <span class="n">find_runs</span><span class="p">(</span><span class="n">high_power</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">run_vals</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">run_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">run_length</span> <span class="o">=</span> <span class="n">run_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># second run_val must be True</span>
                        <span class="n">run_length</span> <span class="o">=</span> <span class="n">run_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">run_length</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ripple_min_duration_ms</span><span class="p">:</span>
                        <span class="n">indices_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                        <span class="n">run_lens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run_length</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">indices_to_keep</span><span class="p">,</span> <span class="n">run_lens</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.Rippler.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">trial_root</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>trial_root (Path) - location of the root recording directory, used to load ttls etc
signal (np.ndarray) - the LFP signal (usually downsampled to about 500-1000Hz)
fs (int) - the sampling rate of the signal</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    trial_root (Path) - location of the root recording directory, used to load ttls etc</span>
<span class="sd">    signal (np.ndarray) - the LFP signal (usually downsampled to about 500-1000Hz)</span>
<span class="sd">    fs (int) - the sampling rate of the signal</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">pname_for_trial</span> <span class="o">=</span> <span class="n">trial_root</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">orig_sig</span> <span class="o">=</span> <span class="n">signal</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">trial_root</span><span class="p">))</span>
    <span class="n">LFP</span> <span class="o">=</span> <span class="n">EEGCalcsGeneric</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">LFP</span> <span class="o">=</span> <span class="n">LFP</span>
    <span class="n">detector_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">get_processor</span><span class="p">(</span><span class="s2">&quot;Ripple&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ttl_duration</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">float</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">ttl_duration</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="p">)</span>  <span class="c1"># in seconds now</span>

    <span class="n">pname_for_ttl_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_path_to_ripple_ttl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname_for_trial</span><span class="p">)</span>
    <span class="n">sync_file</span> <span class="o">=</span> <span class="n">pname_for_ttl_data</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;sync_messages.txt&quot;</span><span class="p">)</span>
    <span class="n">recording_start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_start_time</span><span class="p">(</span><span class="n">sync_file</span><span class="p">)</span>
    <span class="n">ttl_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pname_for_ttl_data</span> <span class="o">/</span> <span class="s2">&quot;timestamps.npy&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">recording_start_time</span>
    <span class="n">ttl_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pname_for_ttl_data</span> <span class="o">/</span> <span class="s2">&quot;states.npy&quot;</span><span class="p">)</span>
    <span class="n">all_ons</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_save</span><span class="p">)]</span>
    <span class="n">laser_ons</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_Out</span><span class="p">)]</span>
    <span class="n">laser_offs</span> <span class="o">=</span> <span class="n">ttl_ts</span><span class="p">[</span><span class="n">ttl_states</span> <span class="o">==</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">detector_settings</span><span class="o">.</span><span class="n">Ripple_Out</span><span class="p">)]</span>
    <span class="n">no_laser_ons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_ons</span><span class="p">,</span> <span class="n">laser_ons</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">all_on_ts</span> <span class="o">=</span> <span class="n">all_ons</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ttl_states</span> <span class="o">=</span> <span class="n">ttl_states</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">all_ts</span> <span class="o">=</span> <span class="n">ttl_ts</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span> <span class="o">=</span> <span class="n">laser_ons</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_ts</span> <span class="o">=</span> <span class="n">laser_offs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span> <span class="o">=</span> <span class="n">no_laser_ons</span>

    <span class="n">filtered_eeg</span> <span class="o">=</span> <span class="n">LFP</span><span class="o">.</span><span class="n">butterFilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">low_band</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_band</span><span class="p">)</span>
    <span class="n">filtered_eeg</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bit_volts</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span> <span class="o">=</span> <span class="n">filtered_eeg</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="n">LFP</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
        <span class="n">LFP</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>  <span class="c1"># in seconds</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.Rippler._calc_ripple_chunks_duration_power" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_calc_ripple_chunks_duration_power</span><span class="p">(</span><span class="n">ttl_type</span><span class="o">=</span><span class="s1">&#39;no_laser&#39;</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Find the indices and durations of the events that have sufficient
duration and power to be considered ripples.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>ttl_type</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <pre><code>         Either 'no_laser' or 'laser'
</code></pre>
              </div>
            </td>
            <td>
                  <code>&#39;no_laser&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>tuple</code></td>            <td>
                  <code>the run indices to keep and the run durations in ms</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_calc_ripple_chunks_duration_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ttl_type</span><span class="o">=</span><span class="s2">&quot;no_laser&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the indices and durations of the events that have sufficient</span>
<span class="sd">    duration and power to be considered ripples.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ttl_type (str) - which bit of the trial to do the calculation for</span>
<span class="sd">                     Either &#39;no_laser&#39; or &#39;laser&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple: the run indices to keep and the run durations in ms</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ttl_type</span> <span class="o">==</span> <span class="s2">&quot;no_laser&quot;</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span>
    <span class="k">elif</span> <span class="n">ttl_type</span> <span class="o">==</span> <span class="s2">&quot;laser&quot;</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;ttl_type not recognised. Must be one of &#39;laser&#39; or &#39;no_laser&#39;&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">([],)</span>
    <span class="n">eeg_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">n_samples</span><span class="p">])</span>
    <span class="n">rms_signal</span> <span class="o">=</span> <span class="n">window_rms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>

    <span class="c1"># Get segments of the root mean squared and smoothed LFP signal</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&gt;</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eeg_time</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span>
        <span class="p">)</span>
        <span class="n">eeg_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rms_signal</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="c1"># Square the whole filtered LFP signal and calculate the mean power</span>
    <span class="n">mean_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rms_signal</span><span class="p">)</span>
    <span class="n">std_dev_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">rms_signal</span><span class="p">)</span>

    <span class="c1"># Find ripples that are ripple_std_dev standard deviations over the</span>
    <span class="c1"># mean power to demarcate the start and end of the ripples and longer</span>
    <span class="c1"># than ripple_min_duration_ms</span>
    <span class="n">indices_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">run_lens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eeg_chunks</span><span class="p">):</span>
        <span class="n">high_power</span> <span class="o">=</span> <span class="n">chunk</span> <span class="o">&gt;</span> <span class="n">mean_power</span> <span class="o">+</span> <span class="n">std_dev_power</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ripple_std_dev</span>
        <span class="n">run_vals</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">run_lengths</span> <span class="o">=</span> <span class="n">find_runs</span><span class="p">(</span><span class="n">high_power</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">run_vals</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">run_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">run_length</span> <span class="o">=</span> <span class="n">run_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># second run_val must be True</span>
                    <span class="n">run_length</span> <span class="o">=</span> <span class="n">run_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">run_length</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ripple_min_duration_ms</span><span class="p">:</span>
                    <span class="n">indices_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">run_lens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run_length</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">indices_to_keep</span><span class="p">,</span> <span class="n">run_lens</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.Rippler._find_high_power_periods" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_find_high_power_periods</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Find periods where the power in the ripple band is above n standard deviations
for t samples. Meant to recapitulate the algorithm from the Ripple Detector
plugin</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_find_high_power_periods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find periods where the power in the ripple band is above n standard deviations</span>
<span class="sd">    for t samples. Meant to recapitulate the algorithm from the Ripple Detector</span>
<span class="sd">    plugin</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get some detection parameters from the Ripple Detector plugin</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname_for_trial</span><span class="p">)</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get_processor</span><span class="p">(</span><span class="s2">&quot;Ripple&quot;</span><span class="p">)</span>
    <span class="n">rms_window</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s2">&quot;rms_samples&quot;</span><span class="p">))</span>
    <span class="n">ripple_detect_channel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s2">&quot;Ripple_Input&quot;</span><span class="p">))</span>
    <span class="n">ripple_std</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s2">&quot;ripple_std&quot;</span><span class="p">))</span>
    <span class="n">time_thresh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s2">&quot;time_thresh&quot;</span><span class="p">))</span>
    <span class="n">rms_sig</span> <span class="o">=</span> <span class="n">window_rms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_eeg</span><span class="p">,</span> <span class="n">rms_window</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.Rippler._find_path_to_continuous" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_find_path_to_continuous</span><span class="p">(</span><span class="n">trial_root</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Iterates through a directory tree and finds the path to the
Ripple Detector plugin data and returns its location</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">963</span>
<span class="normal">964</span>
<span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span>
<span class="normal">968</span>
<span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span>
<span class="normal">983</span>
<span class="normal">984</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_find_path_to_continuous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterates through a directory tree and finds the path to the</span>
<span class="sd">    Ripple Detector plugin data and returns its location</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exp_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;experiment&quot;</span><span class="p">,</span> <span class="s2">&quot;experiment1&quot;</span><span class="p">)</span>
    <span class="n">rec_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;recording&quot;</span><span class="p">,</span> <span class="s2">&quot;recording1&quot;</span><span class="p">)</span>
    <span class="n">folder_match</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">trial_root</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Record Node [0-9][0-9][0-9]&quot;</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">exp_name</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">rec_name</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;events&quot;</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Acquisition_Board-[0-9][0-9][0-9].*&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">trial_root</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>  <span class="c1"># ignore hidden directories</span>
                <span class="k">if</span> <span class="s2">&quot;continuous.dat&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">folder_match</span><span class="p">)):</span>
                        <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Path</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.Rippler._find_path_to_ripple_ttl" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_find_path_to_ripple_ttl</span><span class="p">(</span><span class="n">trial_root</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Iterates through a directory tree and finds the path to the
Ripple Detector plugin data and returns its location</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_find_path_to_ripple_ttl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trial_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterates through a directory tree and finds the path to the</span>
<span class="sd">    Ripple Detector plugin data and returns its location</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exp_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;experiment&quot;</span><span class="p">,</span> <span class="s2">&quot;experiment1&quot;</span><span class="p">)</span>
    <span class="n">rec_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;recording&quot;</span><span class="p">,</span> <span class="s2">&quot;recording1&quot;</span><span class="p">)</span>
    <span class="n">ripple_match</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">trial_root</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Record Node [0-9][0-9][0-9]&quot;</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">exp_name</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">rec_name</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;events&quot;</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;Ripple_Detector-[0-9][0-9][0-9].*&quot;</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;TTL&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">trial_root</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>  <span class="c1"># ignore hidden directories</span>
                <span class="k">if</span> <span class="s2">&quot;timestamps.npy&quot;</span> <span class="ow">in</span> <span class="n">ff</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">PurePath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ripple_match</span><span class="p">)):</span>
                        <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Path</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.Rippler._load_start_time" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_load_start_time</span><span class="p">(</span><span class="n">path_to_sync_message_file</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the start time contained in a sync file from OE</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span>
<span class="normal">957</span>
<span class="normal">958</span>
<span class="normal">959</span>
<span class="normal">960</span>
<span class="normal">961</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">_load_start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_sync_message_file</span><span class="p">:</span> <span class="n">Path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the start time contained in a sync file from OE</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">recording_start_time</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_to_sync_message_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">sync_strs</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">sync_lines</span> <span class="o">=</span> <span class="n">sync_strs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sync_lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;Start Time&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">start_time</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">recording_start_time</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.Rippler.filter_timestamps_for_real_ripples" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">filter_timestamps_for_real_ripples</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Filter out low power and short duration events from the list of timestamps</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">filter_timestamps_for_real_ripples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter out low power and short duration events from the list of timestamps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">laser_on_keep_indices</span><span class="p">,</span> <span class="n">laser_on_run_lens</span> <span class="o">=</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_ripple_chunks_duration_power</span><span class="p">(</span><span class="s2">&quot;laser&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">no_laser_keep_indices</span><span class="p">,</span> <span class="n">no_laser_run_lens</span> <span class="o">=</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_ripple_chunks_duration_power</span><span class="p">(</span><span class="s2">&quot;no_laser&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_run_lens</span> <span class="o">=</span> <span class="n">laser_on_run_lens</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_run_lens</span> <span class="o">=</span> <span class="n">no_laser_run_lens</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span><span class="p">[</span><span class="n">laser_on_keep_indices</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_ts</span><span class="p">[</span><span class="n">laser_on_keep_indices</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span><span class="p">[</span><span class="n">no_laser_keep_indices</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.Rippler.plot_mean_rippleband_power" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_mean_rippleband_power</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots the mean power in the ripple band for the laser on and no laser
conditions</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@savePlot</span>
<span class="k">def</span> <span class="nf">plot_mean_rippleband_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the mean power in the ripple band for the laser on and no laser</span>
<span class="sd">    conditions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_on_spectrogram</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_off_spectrogram</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_off_spectrogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_band</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_band</span><span class="p">)</span>
        <span class="n">mean_power_on</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_on_spectrogram</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">mean_power_no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_off_spectrogram</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">mean_power_on_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="mi">0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mean_power_on</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">mean_power_off_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="mi">0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_ttl</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mean_power_no</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">mean_power_on_time</span><span class="p">,</span>
            <span class="n">mean_power_on</span><span class="p">,</span>
            <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;on&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">mean_power_off_time</span><span class="p">,</span>
            <span class="n">mean_power_no</span><span class="p">,</span>
            <span class="s2">&quot;k&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;off&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time(s)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean power between </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">low_band</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">high_band</span><span class="si">}</span><span class="s2">Hz&quot;</span><span class="p">)</span>
        <span class="n">axTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
            <span class="n">Rectangle</span><span class="p">(</span>
                <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">width</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">axTrans</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Laser on&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.rhythmicity.Rippler.plot_mean_spectrogram" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_mean_spectrogram</span><span class="p">(</span><span class="n">laser_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots the mean spectrogram for either 'long' or 'short' ttl events</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/rhythmicity.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">plot_mean_spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laser_on</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the mean spectrogram for either &#39;long&#39; or &#39;short&#39; ttl events</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;norm&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">ttls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">laser_on_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_off_ts</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># max_duration used in plotting output below</span>
    <span class="n">ttl_duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ttls</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">laser_on</span><span class="p">:</span>
        <span class="n">ttls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_laser_on_ts</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ttl_duration</span><span class="p">)]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># breakpoint()</span>
    <span class="n">spectrograms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ttl</span> <span class="ow">in</span> <span class="n">ttls</span><span class="p">:</span>
        <span class="p">(</span>
            <span class="n">SFT</span><span class="p">,</span>
            <span class="n">N</span><span class="p">,</span>
            <span class="n">spec</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spectrogram</span><span class="p">(</span><span class="n">ttl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ttl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">spectrograms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

    <span class="c1"># some spectrograms might be slightly different shapes so</span>
    <span class="c1"># truncate to the shortest length in each dimension</span>
    <span class="n">min_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="n">min_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">spec_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ttls</span><span class="p">),</span> <span class="n">min_rows</span><span class="p">,</span> <span class="n">min_cols</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spectrograms</span><span class="p">):</span>
        <span class="n">spec_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">min_rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">min_cols</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>  <span class="c1"># enlarge plot a bit</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="n">fig1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
    <span class="n">t_lo</span><span class="p">,</span> <span class="n">t_hi</span> <span class="o">=</span> <span class="n">SFT</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">N</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># time range of plot</span>
    <span class="nb">breakpoint</span><span class="p">()</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
        <span class="n">xlabel</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Time $t$ in seconds (</span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">p_num</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="si">}</span><span class="s2"> slices, &quot;</span>
        <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;$\Delta t = </span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">delta_t</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">\,$s)&quot;</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Freq. $f$ in Hz (</span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">f_pts</span><span class="si">}</span><span class="s2"> bins, &quot;</span>
        <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;$\Delta f = </span><span class="si">{</span><span class="n">SFT</span><span class="o">.</span><span class="n">delta_f</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">\,$Hz)&quot;</span><span class="p">,</span>
        <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">t_lo</span><span class="p">,</span> <span class="n">t_hi</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax1</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span> <span class="n">ax1</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span> <span class="o">+</span> <span class="n">ttl_duration</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
        <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># add an annotation for the ttl duration next in between</span>
    <span class="c1"># the vertical red dashed lines</span>
    <span class="n">ttl_duration_ms</span> <span class="o">=</span> <span class="n">ttl_duration</span>  <span class="c1"># * 1000</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ttl_duration_ms</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2"> ms&quot;</span><span class="p">,</span>
        <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span> <span class="o">+</span> <span class="n">ttl_duration</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
        <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_ttl</span> <span class="o">+</span> <span class="n">ttl_duration</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
        <span class="n">xycoords</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
        <span class="n">textcoords</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
        <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;small&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># imshow not respecting the image extents so use pcolormesh</span>
    <span class="c1"># mean_spec_array = np.mean(spec_array, 0)</span>
    <span class="c1"># X, Y = np.meshgrid(</span>
    <span class="c1">#     np.linspace(SFT.extent(N)[0], SFT.extent(N)[1], mean_spec_array.shape[1]),</span>
    <span class="c1">#     np.linspace(SFT.extent(N)[2], SFT.extent(N)[3], mean_spec_array.shape[0]),</span>
    <span class="c1"># )</span>
    <span class="c1"># breakpoint()</span>
    <span class="c1"># im1 = ax1.pcolormesh(</span>
    <span class="c1">#     X, Y, np.mean(spec_array, 0), cmap=&quot;magma&quot;, norm=norm, edgecolors=&quot;face&quot;</span>
    <span class="c1"># )</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spec_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span>
        <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">extent</span><span class="o">=</span><span class="n">SFT</span><span class="o">.</span><span class="n">extent</span><span class="p">(</span><span class="n">N</span><span class="p">),</span>
        <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;magma&quot;</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">fig1</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">spec_array</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h2 id="spike-calculations">Spike calculations</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.common.spikecalcs"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.spikecalcs.SpikeCalcsAxona" class="doc doc-heading">
            <code>SpikeCalcsAxona</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ephysiopy.common.spikecalcs.SpikeCalcsGeneric" href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric">SpikeCalcsGeneric</a></code></p>


        <p>Replaces SpikeCalcs from ephysiopy.axona.spikecalcs</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">SpikeCalcsAxona</span><span class="p">(</span><span class="n">SpikeCalcsGeneric</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces SpikeCalcs from ephysiopy.axona.spikecalcs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">half_amp_dur</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the half amplitude duration of a spike.</span>

<span class="sd">        Args:</span>
<span class="sd">            A (ndarray): An nSpikes x nElectrodes x nSamples array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            had (float): The half-amplitude duration for the channel</span>
<span class="sd">                (electrode) that has the strongest (highest amplitude)</span>
<span class="sd">                signal. Units are ms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>

        <span class="n">best_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">mn_wvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">wvs</span> <span class="o">=</span> <span class="n">mn_wvs</span><span class="p">[</span><span class="n">best_chan</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">half_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wvs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">half_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">wvs</span><span class="p">)</span> <span class="o">+</span> <span class="n">half_amp</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        <span class="c1"># create functions from the data using PiecewisePolynomial</span>
        <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">BPoly</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">from_derivatives</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">wvs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">from_derivatives</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">half_amp</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
        <span class="n">xs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">x_mid</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_mid</span><span class="p">:</span>
            <span class="n">root</span><span class="p">,</span> <span class="n">infodict</span><span class="p">,</span> <span class="n">ier</span><span class="p">,</span> <span class="n">mesg</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">p1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">val</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x_min</span> <span class="o">&lt;</span> <span class="n">root</span> <span class="o">&lt;</span> <span class="n">x_max</span><span class="p">:</span>
                <span class="n">roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">p2t_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The peak to trough time of a spike in ms</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster whose waveforms are to be analysed</span>

<span class="sd">        Returns:</span>
<span class="sd">            p2t (float): The mean peak-to-trough time for the channel</span>
<span class="sd">                (electrode) that has the strongest (highest amplitude) signal.</span>
<span class="sd">                Units are ms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">best_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">tP</span> <span class="o">=</span> <span class="n">get_param</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s2">&quot;tP&quot;</span><span class="p">)</span>
        <span class="n">tT</span> <span class="o">=</span> <span class="n">get_param</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s2">&quot;tT&quot;</span><span class="p">)</span>
        <span class="n">mn_tP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tP</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">mn_tT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tT</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p2t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mn_tP</span><span class="p">[</span><span class="n">best_chan</span><span class="p">]</span> <span class="o">-</span> <span class="n">mn_tT</span><span class="p">[</span><span class="n">best_chan</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">p2t</span> <span class="o">*</span> <span class="mi">1000</span>

    <span class="k">def</span> <span class="nf">plotClusterSpace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">waveforms</span><span class="p">,</span>
        <span class="n">param</span><span class="o">=</span><span class="s2">&quot;Amp&quot;</span><span class="p">,</span>
        <span class="n">clusts</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cluster_vec</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assumes the waveform data is signed 8-bit ints</span>

<span class="sd">        NB THe above assumption is mostly broken as waveforms by default are now</span>
<span class="sd">        in volts so you need to construct the trial object (AxonaTrial, OpenEphysBase</span>
<span class="sd">        etc) with volts=False (works for Axona, less sure about OE)</span>
<span class="sd">        TODO: aspect of plot boxes in ImageGrid not right as scaled by range of</span>
<span class="sd">        values now</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        waveforms (np.ndarray) - the array of waveform data. For Axona recordings this</span>
<span class="sd">                                 is nSpikes x nChannels x nSamplesPerWaveform</span>
<span class="sd">        param (str) - the parameter to plot. See get_param at the top of this file</span>
<span class="sd">                      for valid args</span>
<span class="sd">        clusts (optional - int or list) - which clusters to colour in</span>
<span class="sd">        cluster_vec (optional - np.ndarray or list) - the cluster identity of each spike in waveforms</span>
<span class="sd">                                           Must be nSpikes long</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cluster_vec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_vec</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

        <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">ImageGrid</span>
        <span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">RegularPolyCollection</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.axona.tintcolours</span> <span class="kn">import</span> <span class="n">colours</span> <span class="k">as</span> <span class="n">tcols</span>
        <span class="kn">from</span> <span class="nn">numpy.version</span> <span class="kn">import</span> <span class="n">version</span> <span class="k">as</span> <span class="n">np_vers</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy.lib.arraysetops</span> <span class="kn">import</span> <span class="n">isin</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">isin</span> <span class="k">as</span> <span class="n">isin</span>

        <span class="n">c_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">clusts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">isin</span><span class="p">(</span><span class="n">cluster_vec</span><span class="p">,</span> <span class="n">clusts</span><span class="p">)</span>
            <span class="n">c_vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">c_vec</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tcols</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c_vec</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>

        <span class="n">amps</span> <span class="o">=</span> <span class="n">get_param</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
        <span class="n">cmb</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;fig&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;fig&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">ImageGrid</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="n">nrows_ncols</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">axes_pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cmb</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">amps</span><span class="p">[:,</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">amps</span><span class="p">[:,</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">amps</span><span class="p">[:,</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">amps</span><span class="p">[:,</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span><span class="o">.</span><span class="n">T</span>
                <span class="n">rects</span> <span class="o">=</span> <span class="n">RegularPolyCollection</span><span class="p">(</span>
                    <span class="n">numsides</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">facecolors</span><span class="o">=</span><span class="n">c_vec</span><span class="p">,</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="n">c_vec</span><span class="p">,</span>
                    <span class="n">offsets</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
                    <span class="n">offset_transform</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">rects</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; v &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                <span class="mf">0.05</span><span class="p">,</span>
                <span class="mf">0.95</span><span class="p">,</span>
                <span class="n">s</span><span class="p">,</span>
                <span class="n">va</span><span class="o">=</span><span class="s2">&quot;top&quot;</span><span class="p">,</span>
                <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="s2">&quot;small&quot;</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsAxona.half_amp_dur" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">half_amp_dur</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculates the half amplitude duration of a spike.</p>
<p>Args:
    A (ndarray): An nSpikes x nElectrodes x nSamples array.</p>
<p>Returns:
    had (float): The half-amplitude duration for the channel
        (electrode) that has the strongest (highest amplitude)
        signal. Units are ms.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">half_amp_dur</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the half amplitude duration of a spike.</span>

<span class="sd">    Args:</span>
<span class="sd">        A (ndarray): An nSpikes x nElectrodes x nSamples array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        had (float): The half-amplitude duration for the channel</span>
<span class="sd">            (electrode) that has the strongest (highest amplitude)</span>
<span class="sd">            signal. Units are ms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>

    <span class="n">best_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">mn_wvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">wvs</span> <span class="o">=</span> <span class="n">mn_wvs</span><span class="p">[</span><span class="n">best_chan</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">half_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wvs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">half_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">wvs</span><span class="p">)</span> <span class="o">+</span> <span class="n">half_amp</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
    <span class="c1"># create functions from the data using PiecewisePolynomial</span>
    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">BPoly</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">from_derivatives</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">wvs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">from_derivatives</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">half_amp</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
    <span class="n">xs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">x_mid</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_mid</span><span class="p">:</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">infodict</span><span class="p">,</span> <span class="n">ier</span><span class="p">,</span> <span class="n">mesg</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">p1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">val</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x_min</span> <span class="o">&lt;</span> <span class="n">root</span> <span class="o">&lt;</span> <span class="n">x_max</span><span class="p">:</span>
            <span class="n">roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">r</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsAxona.p2t_time" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">p2t_time</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>The peak to trough time of a spike in ms</p>
<p>Args:
    cluster (int): The cluster whose waveforms are to be analysed</p>
<p>Returns:
    p2t (float): The mean peak-to-trough time for the channel
        (electrode) that has the strongest (highest amplitude) signal.
        Units are ms.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">p2t_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The peak to trough time of a spike in ms</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster whose waveforms are to be analysed</span>

<span class="sd">    Returns:</span>
<span class="sd">        p2t (float): The mean peak-to-trough time for the channel</span>
<span class="sd">            (electrode) that has the strongest (highest amplitude) signal.</span>
<span class="sd">            Units are ms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">best_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">tP</span> <span class="o">=</span> <span class="n">get_param</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s2">&quot;tP&quot;</span><span class="p">)</span>
    <span class="n">tT</span> <span class="o">=</span> <span class="n">get_param</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s2">&quot;tT&quot;</span><span class="p">)</span>
    <span class="n">mn_tP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tP</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">mn_tT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tT</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">p2t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mn_tP</span><span class="p">[</span><span class="n">best_chan</span><span class="p">]</span> <span class="o">-</span> <span class="n">mn_tT</span><span class="p">[</span><span class="n">best_chan</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">p2t</span> <span class="o">*</span> <span class="mi">1000</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsAxona.plotClusterSpace" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plotClusterSpace</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;Amp&#39;</span><span class="p">,</span> <span class="n">clusts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Assumes the waveform data is signed 8-bit ints</p>
<p>NB THe above assumption is mostly broken as waveforms by default are now
in volts so you need to construct the trial object (AxonaTrial, OpenEphysBase
etc) with volts=False (works for Axona, less sure about OE)
TODO: aspect of plot boxes in ImageGrid not right as scaled by range of
values now</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>waveforms</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <pre><code>                 is nSpikes x nChannels x nSamplesPerWaveform
</code></pre>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>param</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <pre><code>      for valid args
</code></pre>
              </div>
            </td>
            <td>
                  <code>&#39;Amp&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>clusts</code>
            </td>
            <td>
                  <code>None | <span title="int">int</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>cluster_vec</code>
            </td>
            <td>
                  <code>None | <span title="numpy.ndarray">ndarray</span> | <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <pre><code>                           Must be nSpikes long
</code></pre>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">plotClusterSpace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">waveforms</span><span class="p">,</span>
    <span class="n">param</span><span class="o">=</span><span class="s2">&quot;Amp&quot;</span><span class="p">,</span>
    <span class="n">clusts</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cluster_vec</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assumes the waveform data is signed 8-bit ints</span>

<span class="sd">    NB THe above assumption is mostly broken as waveforms by default are now</span>
<span class="sd">    in volts so you need to construct the trial object (AxonaTrial, OpenEphysBase</span>
<span class="sd">    etc) with volts=False (works for Axona, less sure about OE)</span>
<span class="sd">    TODO: aspect of plot boxes in ImageGrid not right as scaled by range of</span>
<span class="sd">    values now</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    waveforms (np.ndarray) - the array of waveform data. For Axona recordings this</span>
<span class="sd">                             is nSpikes x nChannels x nSamplesPerWaveform</span>
<span class="sd">    param (str) - the parameter to plot. See get_param at the top of this file</span>
<span class="sd">                  for valid args</span>
<span class="sd">    clusts (optional - int or list) - which clusters to colour in</span>
<span class="sd">    cluster_vec (optional - np.ndarray or list) - the cluster identity of each spike in waveforms</span>
<span class="sd">                                       Must be nSpikes long</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cluster_vec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_vec</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

    <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">ImageGrid</span>
    <span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">RegularPolyCollection</span>
    <span class="kn">from</span> <span class="nn">ephysiopy.axona.tintcolours</span> <span class="kn">import</span> <span class="n">colours</span> <span class="k">as</span> <span class="n">tcols</span>
    <span class="kn">from</span> <span class="nn">numpy.version</span> <span class="kn">import</span> <span class="n">version</span> <span class="k">as</span> <span class="n">np_vers</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy.lib.arraysetops</span> <span class="kn">import</span> <span class="n">isin</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">isin</span> <span class="k">as</span> <span class="n">isin</span>

    <span class="n">c_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">clusts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">isin</span><span class="p">(</span><span class="n">cluster_vec</span><span class="p">,</span> <span class="n">clusts</span><span class="p">)</span>
        <span class="n">c_vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">c_vec</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tcols</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c_vec</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>

    <span class="n">amps</span> <span class="o">=</span> <span class="n">get_param</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
    <span class="n">cmb</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;fig&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;fig&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">ImageGrid</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="n">nrows_ncols</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">axes_pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cmb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">amps</span><span class="p">[:,</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">amps</span><span class="p">[:,</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">amps</span><span class="p">[:,</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">amps</span><span class="p">[:,</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">rects</span> <span class="o">=</span> <span class="n">RegularPolyCollection</span><span class="p">(</span>
                <span class="n">numsides</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">facecolors</span><span class="o">=</span><span class="n">c_vec</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">c_vec</span><span class="p">,</span>
                <span class="n">offsets</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
                <span class="n">offset_transform</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">rects</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; v &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
            <span class="mf">0.05</span><span class="p">,</span>
            <span class="mf">0.95</span><span class="p">,</span>
            <span class="n">s</span><span class="p">,</span>
            <span class="n">va</span><span class="o">=</span><span class="s2">&quot;top&quot;</span><span class="p">,</span>
            <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="s2">&quot;small&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric" class="doc doc-heading">
            <code>SpikeCalcsGeneric</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Deals with the processing and analysis of spike data.
There should be one instance of this class per cluster in the
recording session. NB this differs from previous versions of this
class where there was one instance per recording session and clusters
were selected by passing in the cluster id to the methods.</p>
<p>Args:
    spike_times (array_like): The times of spikes in the trial in seconds
    waveforms (np.array, optional): An nSpikes x nChannels x nSamples array</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 342</span>
<span class="normal"> 343</span>
<span class="normal"> 344</span>
<span class="normal"> 345</span>
<span class="normal"> 346</span>
<span class="normal"> 347</span>
<span class="normal"> 348</span>
<span class="normal"> 349</span>
<span class="normal"> 350</span>
<span class="normal"> 351</span>
<span class="normal"> 352</span>
<span class="normal"> 353</span>
<span class="normal"> 354</span>
<span class="normal"> 355</span>
<span class="normal"> 356</span>
<span class="normal"> 357</span>
<span class="normal"> 358</span>
<span class="normal"> 359</span>
<span class="normal"> 360</span>
<span class="normal"> 361</span>
<span class="normal"> 362</span>
<span class="normal"> 363</span>
<span class="normal"> 364</span>
<span class="normal"> 365</span>
<span class="normal"> 366</span>
<span class="normal"> 367</span>
<span class="normal"> 368</span>
<span class="normal"> 369</span>
<span class="normal"> 370</span>
<span class="normal"> 371</span>
<span class="normal"> 372</span>
<span class="normal"> 373</span>
<span class="normal"> 374</span>
<span class="normal"> 375</span>
<span class="normal"> 376</span>
<span class="normal"> 377</span>
<span class="normal"> 378</span>
<span class="normal"> 379</span>
<span class="normal"> 380</span>
<span class="normal"> 381</span>
<span class="normal"> 382</span>
<span class="normal"> 383</span>
<span class="normal"> 384</span>
<span class="normal"> 385</span>
<span class="normal"> 386</span>
<span class="normal"> 387</span>
<span class="normal"> 388</span>
<span class="normal"> 389</span>
<span class="normal"> 390</span>
<span class="normal"> 391</span>
<span class="normal"> 392</span>
<span class="normal"> 393</span>
<span class="normal"> 394</span>
<span class="normal"> 395</span>
<span class="normal"> 396</span>
<span class="normal"> 397</span>
<span class="normal"> 398</span>
<span class="normal"> 399</span>
<span class="normal"> 400</span>
<span class="normal"> 401</span>
<span class="normal"> 402</span>
<span class="normal"> 403</span>
<span class="normal"> 404</span>
<span class="normal"> 405</span>
<span class="normal"> 406</span>
<span class="normal"> 407</span>
<span class="normal"> 408</span>
<span class="normal"> 409</span>
<span class="normal"> 410</span>
<span class="normal"> 411</span>
<span class="normal"> 412</span>
<span class="normal"> 413</span>
<span class="normal"> 414</span>
<span class="normal"> 415</span>
<span class="normal"> 416</span>
<span class="normal"> 417</span>
<span class="normal"> 418</span>
<span class="normal"> 419</span>
<span class="normal"> 420</span>
<span class="normal"> 421</span>
<span class="normal"> 422</span>
<span class="normal"> 423</span>
<span class="normal"> 424</span>
<span class="normal"> 425</span>
<span class="normal"> 426</span>
<span class="normal"> 427</span>
<span class="normal"> 428</span>
<span class="normal"> 429</span>
<span class="normal"> 430</span>
<span class="normal"> 431</span>
<span class="normal"> 432</span>
<span class="normal"> 433</span>
<span class="normal"> 434</span>
<span class="normal"> 435</span>
<span class="normal"> 436</span>
<span class="normal"> 437</span>
<span class="normal"> 438</span>
<span class="normal"> 439</span>
<span class="normal"> 440</span>
<span class="normal"> 441</span>
<span class="normal"> 442</span>
<span class="normal"> 443</span>
<span class="normal"> 444</span>
<span class="normal"> 445</span>
<span class="normal"> 446</span>
<span class="normal"> 447</span>
<span class="normal"> 448</span>
<span class="normal"> 449</span>
<span class="normal"> 450</span>
<span class="normal"> 451</span>
<span class="normal"> 452</span>
<span class="normal"> 453</span>
<span class="normal"> 454</span>
<span class="normal"> 455</span>
<span class="normal"> 456</span>
<span class="normal"> 457</span>
<span class="normal"> 458</span>
<span class="normal"> 459</span>
<span class="normal"> 460</span>
<span class="normal"> 461</span>
<span class="normal"> 462</span>
<span class="normal"> 463</span>
<span class="normal"> 464</span>
<span class="normal"> 465</span>
<span class="normal"> 466</span>
<span class="normal"> 467</span>
<span class="normal"> 468</span>
<span class="normal"> 469</span>
<span class="normal"> 470</span>
<span class="normal"> 471</span>
<span class="normal"> 472</span>
<span class="normal"> 473</span>
<span class="normal"> 474</span>
<span class="normal"> 475</span>
<span class="normal"> 476</span>
<span class="normal"> 477</span>
<span class="normal"> 478</span>
<span class="normal"> 479</span>
<span class="normal"> 480</span>
<span class="normal"> 481</span>
<span class="normal"> 482</span>
<span class="normal"> 483</span>
<span class="normal"> 484</span>
<span class="normal"> 485</span>
<span class="normal"> 486</span>
<span class="normal"> 487</span>
<span class="normal"> 488</span>
<span class="normal"> 489</span>
<span class="normal"> 490</span>
<span class="normal"> 491</span>
<span class="normal"> 492</span>
<span class="normal"> 493</span>
<span class="normal"> 494</span>
<span class="normal"> 495</span>
<span class="normal"> 496</span>
<span class="normal"> 497</span>
<span class="normal"> 498</span>
<span class="normal"> 499</span>
<span class="normal"> 500</span>
<span class="normal"> 501</span>
<span class="normal"> 502</span>
<span class="normal"> 503</span>
<span class="normal"> 504</span>
<span class="normal"> 505</span>
<span class="normal"> 506</span>
<span class="normal"> 507</span>
<span class="normal"> 508</span>
<span class="normal"> 509</span>
<span class="normal"> 510</span>
<span class="normal"> 511</span>
<span class="normal"> 512</span>
<span class="normal"> 513</span>
<span class="normal"> 514</span>
<span class="normal"> 515</span>
<span class="normal"> 516</span>
<span class="normal"> 517</span>
<span class="normal"> 518</span>
<span class="normal"> 519</span>
<span class="normal"> 520</span>
<span class="normal"> 521</span>
<span class="normal"> 522</span>
<span class="normal"> 523</span>
<span class="normal"> 524</span>
<span class="normal"> 525</span>
<span class="normal"> 526</span>
<span class="normal"> 527</span>
<span class="normal"> 528</span>
<span class="normal"> 529</span>
<span class="normal"> 530</span>
<span class="normal"> 531</span>
<span class="normal"> 532</span>
<span class="normal"> 533</span>
<span class="normal"> 534</span>
<span class="normal"> 535</span>
<span class="normal"> 536</span>
<span class="normal"> 537</span>
<span class="normal"> 538</span>
<span class="normal"> 539</span>
<span class="normal"> 540</span>
<span class="normal"> 541</span>
<span class="normal"> 542</span>
<span class="normal"> 543</span>
<span class="normal"> 544</span>
<span class="normal"> 545</span>
<span class="normal"> 546</span>
<span class="normal"> 547</span>
<span class="normal"> 548</span>
<span class="normal"> 549</span>
<span class="normal"> 550</span>
<span class="normal"> 551</span>
<span class="normal"> 552</span>
<span class="normal"> 553</span>
<span class="normal"> 554</span>
<span class="normal"> 555</span>
<span class="normal"> 556</span>
<span class="normal"> 557</span>
<span class="normal"> 558</span>
<span class="normal"> 559</span>
<span class="normal"> 560</span>
<span class="normal"> 561</span>
<span class="normal"> 562</span>
<span class="normal"> 563</span>
<span class="normal"> 564</span>
<span class="normal"> 565</span>
<span class="normal"> 566</span>
<span class="normal"> 567</span>
<span class="normal"> 568</span>
<span class="normal"> 569</span>
<span class="normal"> 570</span>
<span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">SpikeCalcsGeneric</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deals with the processing and analysis of spike data.</span>
<span class="sd">    There should be one instance of this class per cluster in the</span>
<span class="sd">    recording session. NB this differs from previous versions of this</span>
<span class="sd">    class where there was one instance per recording session and clusters</span>
<span class="sd">    were selected by passing in the cluster id to the methods.</span>

<span class="sd">    Args:</span>
<span class="sd">        spike_times (array_like): The times of spikes in the trial in seconds</span>
<span class="sd">        waveforms (np.array, optional): An nSpikes x nChannels x nSamples array</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spike_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">waveforms</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span>  <span class="c1"># IN SECONDS</span>
        <span class="k">if</span> <span class="n">waveforms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the times that events occured IN SECONDS</span>
        <span class="c1"># window, in seconds, either side of the stimulus, to examine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mf">0.050</span><span class="p">,</span> <span class="mf">0.100</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stim_width</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the width, in ms, of the stimulus</span>
        <span class="c1"># used to increase / decrease size of bins in psth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_secs_per_bin</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sample_rate</span> <span class="o">=</span> <span class="mi">30000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_sample_rate</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># these values should be specific to OE data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pre_spike_samples</span> <span class="o">=</span> <span class="mi">16</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_spike_samples</span> <span class="o">=</span> <span class="mi">34</span>
        <span class="c1"># values from running KS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ksmeta</span> <span class="o">=</span> <span class="n">KSMetaTuple</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># update the __dict__ attribute with the kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_rate</span>

    <span class="nd">@sample_rate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sample_rate</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_sample_rate</span>

    <span class="nd">@pos_sample_rate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pos_sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_sample_rate</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pre_spike_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pre_spike_samples</span>

    <span class="nd">@pre_spike_samples</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pre_spike_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pre_spike_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">post_spike_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_spike_samples</span>

    <span class="nd">@post_spike_samples</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">post_spike_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_spike_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_post_spike_samples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_id</span><span class="p">:</span> <span class="n">Sequence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">channel_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">channel_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel_id</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span><span class="p">[:,</span> <span class="n">channel_id</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of spikes in the cluster</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The number of spikes in the cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">event_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span>

    <span class="nd">@event_ts</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">event_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span>

    <span class="nd">@duration</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">KSMeta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">KSMetaTuple</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ksmeta</span>

    <span class="k">def</span> <span class="nf">update_KSMeta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes in a TemplateModel instance from a phy session and</span>
<span class="sd">        parses out the relevant metrics for the cluster and places</span>
<span class="sd">        into the namedtuple KSMeta</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metavals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">KSMetaTuple</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">metavals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">metavals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metavals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ksmeta</span> <span class="o">=</span> <span class="n">KSMetaTuple</span><span class="p">(</span><span class="o">*</span><span class="n">metavals</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">event_window</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_window</span>

    <span class="nd">@event_window</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">event_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_window</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stim_width</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stim_width</span>

    <span class="nd">@stim_width</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">stim_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stim_width</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">secs_per_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_secs_per_bin</span>

    <span class="nd">@secs_per_bin</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">secs_per_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_secs_per_bin</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_filter</span><span class="p">:</span> <span class="n">TrialFilter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a mask to the spike times</span>

<span class="sd">        Args</span>
<span class="sd">            mask (list or tuple): The mask to apply to the spike times</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">trial_filter</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i_filter</span> <span class="ow">in</span> <span class="n">trial_filter</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i_filter</span><span class="p">,</span> <span class="n">TrialFilter</span><span class="p">),</span> <span class="s2">&quot;Filter must be a TrialFilter&quot;</span>
                <span class="k">assert</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;Only time filters are supported&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trial_filter</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">trial_filter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i_filter</span> <span class="ow">in</span> <span class="n">trial_filter</span><span class="p">:</span>
                <span class="n">i_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span>
                <span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">i_mask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">acorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Trange</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the autocorrelogram of a spike train</span>

<span class="sd">        Args:</span>
<span class="sd">            ts (np.ndarray): The spike times</span>
<span class="sd">            Trange (np.ndarray): The range of times to calculate the</span>
<span class="sd">                autocorrelogram over</span>

<span class="sd">        Returns:</span>
<span class="sd">        result: (BinnedData): Container for the binned data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">xcorr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">Trange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trial_mean_fr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># Returns the trial mean firing rate for the cluster</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;No duration provided, give me one!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_spikes</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span>

    <span class="k">def</span> <span class="nf">mean_isi_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isi_range</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the mean of the autocorrelation from 0 to n milliseconds</span>
<span class="sd">        Used to help classify a neurons type (principal, interneuron etc)</span>

<span class="sd">        Args:</span>
<span class="sd">            isi_range (int): The range in ms to calculate the mean over</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The mean of the autocorrelogram between 0 and n milliseconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="mi">201</span>
        <span class="n">trange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">))</span>
        <span class="n">ac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acorr</span><span class="p">(</span><span class="n">Trange</span><span class="o">=</span><span class="n">trange</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="n">isi_range</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

    <span class="k">def</span> <span class="nf">mean_waveform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_id</span><span class="p">:</span> <span class="n">Sequence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the mean waveform and sem for a given spike train on a</span>
<span class="sd">        particular channel</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_id (int): The cluster to get the mean waveform for</span>

<span class="sd">        Returns:</span>
<span class="sd">            mn_wvs (ndarray): The mean waveforms, usually 4x50 for tetrode</span>
<span class="sd">                                recordings</span>
<span class="sd">            std_wvs (ndarray): The standard deviations of the waveforms,</span>
<span class="sd">                                usually 4x50 for tetrode recordings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">(</span><span class="n">channel_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">psth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the PSTH of event_ts against the spiking of a cell</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_id (int): The cluster for which to calculate the psth</span>

<span class="sd">        Returns:</span>
<span class="sd">            x, y (list): The list of time differences between the spikes of</span>
<span class="sd">                            the cluster and the events (x) and the trials (y)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need some event timestamps! Aborting&quot;</span><span class="p">)</span>
        <span class="n">event_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_ts</span>
        <span class="n">event_ts</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event_ts</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">event_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">event_ts</span><span class="p">)</span>

        <span class="n">irange</span> <span class="o">=</span> <span class="n">event_ts</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">event_ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">psch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_width_secs</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the peri-stimulus *count* histogram of a cell&#39;s spiking</span>
<span class="sd">        against event times.</span>

<span class="sd">        Args:</span>
<span class="sd">            bin_width_secs (float): The width of each bin in seconds.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (np.ndarray): Rows are counts of spikes per bin_width_secs.</span>
<span class="sd">            Size of columns ranges from self.event_window[0] to</span>
<span class="sd">            self.event_window[1] with bin_width_secs steps;</span>
<span class="sd">            so x is count, y is &quot;event&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need some event timestamps! Aborting&quot;</span><span class="p">)</span>
        <span class="n">event_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_ts</span>
        <span class="n">event_ts</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event_ts</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">event_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">event_ts</span><span class="p">)</span>

        <span class="n">irange</span> <span class="o">=</span> <span class="n">event_ts</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_width_secs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_ts</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">event_ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span>
            <span class="n">result</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">get_shuffled_ifr_sp_corr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">speed</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">nShuffles</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="c1"># shift spikes by at least 30 seconds after trial start and</span>
        <span class="c1"># 30 seconds before trial end</span>
        <span class="n">nSamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
        <span class="n">random_seed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;random_seed&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
        <span class="n">timeSteps</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">30</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nShuffles</span><span class="p">)</span>
        <span class="n">shuffled_ifr_sp_corrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">timeSteps</span><span class="p">:</span>
            <span class="n">shift_ts</span> <span class="o">=</span> <span class="n">shift_vector</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="n">nSamples</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifr_sp_corr</span><span class="p">(</span><span class="n">shift_ts</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">shuffled_ifr_sp_corrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">statistic</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shuffled_ifr_sp_corrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ifr_sp_corr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ts</span><span class="p">,</span>
        <span class="n">speed</span><span class="p">,</span>
        <span class="n">minSpeed</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
        <span class="n">maxSpeed</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">nShuffles</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the correlation between the instantaneous firing rate and</span>
<span class="sd">        speed.</span>

<span class="sd">        Args:</span>
<span class="sd">            ts (np.array): The times in seconds at which the cluster fired.</span>
<span class="sd">            speed (np.array): Instantaneous speed (1 x nSamples).</span>
<span class="sd">            minSpeed (float, optional): Speeds below this value are ignored.</span>
<span class="sd">                Defaults to 2.0 cm/s as with Kropff et al., 2015.</span>
<span class="sd">            maxSpeed (float, optional): Speeds above this value are ignored.</span>
<span class="sd">                Defaults to 40.0 cm/s.</span>
<span class="sd">            sigma (int, optional): The standard deviation of the gaussian used</span>
<span class="sd">                to smooth the spike train. Defaults to 3.</span>
<span class="sd">            nShuffles (int, optional): The number of resamples to feed into</span>
<span class="sd">                the permutation test. Defaults to 9999.</span>
<span class="sd">                See scipy.stats.PermutationMethod.</span>
<span class="sd">            plot (bool, optional): Whether to plot the result.</span>
<span class="sd">                Defaults to False.</span>
<span class="sd">        kwargs:</span>
<span class="sd">            method: how the significance of the speed vs firing rate correlation</span>
<span class="sd">                    is calculated - see the documentation for scipy.stats.PermutationMethod</span>

<span class="sd">                    An example of how I was calculating this is:</span>

<span class="sd">                    &gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">                    &gt;&gt; method = stats.PermutationMethod(n_resamples=nShuffles, random_state=rng)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">orig_speed_mask</span> <span class="o">=</span> <span class="n">speed</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">posSampRate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
        <span class="n">nSamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ts</span> <span class="o">*</span> <span class="n">posSampRate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># crop the end of the timestamps if longer than the pos data</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x1</span> <span class="o">&gt;=</span> <span class="n">nSamples</span><span class="p">))</span>
        <span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nSamples</span><span class="p">)</span>
        <span class="c1"># smooth the spk_hist (which is a temporal histogram) with a 250ms</span>
        <span class="c1"># gaussian as with Kropff et al., 2015</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
        <span class="c1"># filter for low and high speeds</span>
        <span class="n">speed_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="n">minSpeed</span><span class="p">,</span> <span class="n">speed</span> <span class="o">&gt;</span> <span class="n">maxSpeed</span><span class="p">)</span>
        <span class="c1"># make sure the original mask is preserved</span>
        <span class="n">speed_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">speed_mask</span><span class="p">,</span> <span class="n">orig_speed_mask</span><span class="p">)</span>
        <span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">speed_mask</span><span class="p">)</span>
        <span class="c1">## speed might contain nans so mask these too</span>
        <span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">fix_invalid</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">)</span>
        <span class="n">speed_mask</span> <span class="o">=</span> <span class="n">speed_filt</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">spk_hist_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spk_hist</span><span class="p">,</span> <span class="n">speed_mask</span><span class="p">)</span>
        <span class="n">spk_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spk_hist_filt</span><span class="p">)</span>
        <span class="n">sm_spk_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spk_sm</span> <span class="o">*</span> <span class="n">posSampRate</span><span class="p">,</span> <span class="n">speed_mask</span><span class="p">)</span>
        <span class="c1"># the permutation test for significance, only perform</span>
        <span class="c1"># on the non-masked data</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">PermutationMethod</span><span class="p">(</span><span class="n">n_resamples</span><span class="o">=</span><span class="n">nShuffles</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span>
            <span class="n">sm_spk_rate</span><span class="o">.</span><span class="n">compressed</span><span class="p">(),</span> <span class="n">speed_filt</span><span class="o">.</span><span class="n">compressed</span><span class="p">(),</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">get_ifr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the instantaneous firing rate of the cluster</span>

<span class="sd">        Args:</span>
<span class="sd">            ts (np.array): The times in seconds at which the cluster fired.</span>
<span class="sd">            n_samples (int): The number of samples to use in the calculation.</span>
<span class="sd">                             Practically this should be the number of position</span>
<span class="sd">                             samples in the recording.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ifr (np.array): The instantaneous firing rate of the cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">posSampRate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">spike_times</span> <span class="o">*</span> <span class="n">posSampRate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
        <span class="n">spk_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spk_hist</span><span class="p">)</span>
        <span class="n">ifr</span> <span class="o">=</span> <span class="n">spk_sm</span> <span class="o">*</span> <span class="n">posSampRate</span>
        <span class="k">return</span> <span class="n">ifr</span>

    <span class="k">def</span> <span class="nf">responds_to_stimulus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_contiguous</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">return_activity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_magnitude</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether a cluster responds to a laser stimulus.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster to check.</span>
<span class="sd">            threshold (float): The amount of activity the cluster needs to go</span>
<span class="sd">                beyond to be classified as a responder (1.5 = 50% more or less</span>
<span class="sd">                than the baseline activity).</span>
<span class="sd">            min_contiguous (int): The number of contiguous samples in the</span>
<span class="sd">                post-stimulus period for which the cluster needs to be active</span>
<span class="sd">                beyond the threshold value to be classed as a responder.</span>
<span class="sd">            return_activity (bool): Whether to return the mean reponse curve.</span>
<span class="sd">            return_magnitude (int): Whether to return the magnitude of the</span>
<span class="sd">                response. NB this is either +1 for excited or -1 for inhibited.</span>

<span class="sd">        Returns:</span>
<span class="sd">            responds (bool): Whether the cell responds or not.</span>
<span class="sd">            OR</span>
<span class="sd">            tuple: responds (bool), normed_response_curve (np.ndarray).</span>
<span class="sd">            OR</span>
<span class="sd">            tuple: responds (bool), normed_response_curve (np.ndarray),</span>
<span class="sd">                response_magnitude (np.ndarray).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spk_count_by_trial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_secs_per_bin</span><span class="p">)</span>
        <span class="n">firing_rate_by_trial</span> <span class="o">=</span> <span class="n">spk_count_by_trial</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">secs_per_bin</span>
        <span class="n">mean_firing_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">firing_rate_by_trial</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># smooth with a moving average</span>
        <span class="c1"># check nothing in kwargs first</span>
        <span class="k">if</span> <span class="s2">&quot;window_len&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">window_len</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;window_len&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">window_len</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="k">if</span> <span class="s2">&quot;window&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;window&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="s2">&quot;flat&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;flat&quot;</span> <span class="ow">in</span> <span class="n">window</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">Box1DKernel</span><span class="p">(</span><span class="n">window_len</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;gauss&quot;</span> <span class="ow">in</span> <span class="n">window</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian1DKernel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_len</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;do_smooth&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">do_smooth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;do_smooth&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">do_smooth</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">do_smooth</span><span class="p">:</span>
            <span class="n">smoothed_binned_spikes</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">mean_firing_rate</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">smoothed_binned_spikes</span> <span class="o">=</span> <span class="n">mean_firing_rate</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">secs_per_bin</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbins</span><span class="p">))</span>
        <span class="c1"># normalize all activity by activity in the time before</span>
        <span class="c1"># the laser onset</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">normd</span> <span class="o">=</span> <span class="n">min_max_norm</span><span class="p">(</span>
            <span class="n">smoothed_binned_spikes</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">smoothed_binned_spikes</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">smoothed_binned_spikes</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="c1"># mask the array outside of a threshold value so that</span>
        <span class="c1"># only True values in the masked array are those that</span>
        <span class="c1"># exceed the threshold (positively or negatively)</span>
        <span class="c1"># the threshold provided to this function is expressed</span>
        <span class="c1"># as a % above / below unit normality so adjust that now</span>
        <span class="c1"># so it is expressed as a pre-stimulus firing rate mean</span>
        <span class="c1"># pre_stim_mean = np.mean(smoothed_binned_spikes[idx])</span>
        <span class="c1"># pre_stim_max = pre_stim_mean * threshold</span>
        <span class="c1"># pre_stim_min = pre_stim_mean * (threshold-1.0)</span>
        <span class="c1"># updated so threshold is double (+ or -) the pre-stim</span>
        <span class="c1"># norm (lies between )</span>
        <span class="n">normd_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_inside</span><span class="p">(</span><span class="n">normd</span><span class="p">,</span> <span class="o">-</span><span class="n">threshold</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="c1"># find the contiguous runs in the masked array</span>
        <span class="c1"># that are at least as long as the min_contiguous value</span>
        <span class="c1"># and classify this as a True response</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">notmasked_contiguous</span><span class="p">(</span><span class="n">normd_masked</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slices</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">normd</span><span class="p">)):</span>
            <span class="c1"># make sure that slices are within the first 25ms post-stim</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">75</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">return_activity</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">return_magnitude</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">normd</span><span class="p">,</span> <span class="mi">0</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">normd</span>
            <span class="n">max_runlength</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">normd_masked</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">max_runlength</span> <span class="o">&gt;=</span> <span class="n">min_contiguous</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">return_activity</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">return_magnitude</span><span class="p">:</span>
                        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">slc</span>
                            <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">slices</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">slc</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_runlength</span>
                        <span class="p">]</span>
                        <span class="n">mag</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">normd</span><span class="p">[</span><span class="n">sl</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">normd</span><span class="p">,</span> <span class="n">mag</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">normd</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_activity</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_magnitude</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">normd</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">normd</span>

    <span class="k">def</span> <span class="nf">theta_mod_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a theta modulation index of a spike train based on the cells</span>
<span class="sd">        autocorrelogram.</span>

<span class="sd">        The difference of the mean power in the theta frequency band (6-11 Hz) and</span>
<span class="sd">        the mean power in the 1-50 Hz frequency band is divided by their sum to give</span>
<span class="sd">        a metric that lives between 0 and 1</span>

<span class="sd">        Args:</span>
<span class="sd">            x1 (np.array): The spike time-series.</span>

<span class="sd">        Returns:</span>
<span class="sd">            thetaMod (float): The difference of the values at the first peak</span>
<span class="sd">            and trough of the autocorrelogram.</span>

<span class="sd">        NB This is a fairly skewed metric with a distribution strongly biased</span>
<span class="sd">        to -1 (although more evenly distributed than theta_mod_idxV2 below)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acorr</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Take the fft of the spike train autocorr (from -500 to +500ms)</span>
        <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">periodogram</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;binsize&quot;</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">)</span>
        <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Smooth the power over +/- 1Hz when fs=200</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">boxcar</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># another filter type - blackman?</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>

        <span class="c1"># Square the amplitude first to get power</span>
        <span class="n">sqd_amp</span> <span class="o">=</span> <span class="n">h</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># Get the mean theta band power - mtbp</span>
        <span class="n">mtbp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sqd_amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;=</span> <span class="mi">11</span><span class="p">)])</span>
        <span class="c1"># Find the mean amplitude in the 1-50Hz range</span>
        <span class="c1"># Get the mean in the other band - mobp</span>
        <span class="n">mobp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sqd_amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)])</span>
        <span class="c1"># Find the ratio of these two - this is the theta modulation index</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="n">mtbp</span> <span class="o">-</span> <span class="n">mobp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mtbp</span> <span class="o">+</span> <span class="n">mobp</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">theta_mod_idxV2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a simpler alternative to the theta_mod_idx method in that it</span>
<span class="sd">        calculates the difference between the normalized temporal</span>
<span class="sd">        autocorrelogram at the trough between 50-70ms and the</span>
<span class="sd">        peak between 100-140ms over their sum (data is binned into 5ms bins)</span>

<span class="sd">        Measure used in Cacucci et al., 2004 and Kropff et al 2015</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acorr</span><span class="p">()</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># &#39;close&#39; the right-hand bin</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># normalise corr so max is 1.0</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">corr</span><span class="p">))</span>
        <span class="n">thetaAntiPhase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
            <span class="n">corr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="mi">70</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">thetaPhase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="n">corr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="mi">140</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="n">thetaPhase</span> <span class="o">-</span> <span class="n">thetaAntiPhase</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">thetaPhase</span> <span class="o">+</span> <span class="n">thetaAntiPhase</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">theta_mod_idxV3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Another theta modulation index score this time based on the method used</span>
<span class="sd">        by Kornienko et al., (2024) (Kevin Allens lab)</span>
<span class="sd">        see https://doi.org/10.7554/eLife.35949.001</span>

<span class="sd">        Basically uses the binned spike train instead of the autocorrelogram as</span>
<span class="sd">        the input to the periodogram function (they use pwelch in R; periodogram is a</span>
<span class="sd">        simplified call to welch in scipy.signal)</span>

<span class="sd">        The resulting metric is similar to the one in theta_mod_idx above except</span>
<span class="sd">        that the frequency bands compared to the theta band are narrower and</span>
<span class="sd">        exclusive of the theta band</span>

<span class="sd">        Produces a fairly normally distributed looking score with a mean and median</span>
<span class="sd">        pretty close to 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ifr_power_spectrum</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># smooth with a boxcar filter with a 0.5Hz window</span>
        <span class="n">win_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">boxcar</span><span class="p">(</span><span class="n">win_len</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
        <span class="n">sqd_amp</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">mtbp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sqd_amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)])</span>
        <span class="n">mobp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
            <span class="n">sqd_amp</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="n">mtbp</span> <span class="o">-</span> <span class="n">mobp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mtbp</span> <span class="o">+</span> <span class="n">mobp</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_ifr_power_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the power spectrum of the instantaneous firing rate of a cell</span>

<span class="sd">        This is what is used to calculate the theta_mod_idxV3 score above</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">binned_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
            <span class="n">minlength</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="c1"># possibly smooth the spike train...</span>
        <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">binned_spikes</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span>

    <span class="k">def</span> <span class="nf">theta_band_max_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the frequency with the maximum power in the theta band (6-12Hz)</span>
<span class="sd">        of a spike train&#39;s autocorrelogram.</span>

<span class="sd">        This function is used to look for differences in theta frequency in</span>
<span class="sd">        different running directions as per Blair.</span>
<span class="sd">        See Welday paper - https://doi.org/10.1523/jneurosci.0712-11.2011</span>

<span class="sd">        Args:</span>
<span class="sd">            x1 (np.ndarray): The spike train for which the autocorrelogram will be</span>
<span class="sd">                calculated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The frequency with the maximum power in the theta band.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the input spike train is not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acorr</span><span class="p">()</span>
        <span class="c1"># Take the fft of the spike train autocorr (from -500 to +500ms)</span>
        <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">periodogram</span>

        <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">power_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">freqs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">power_masked</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">smooth_spike_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">npos</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a spike train the same length as num pos samples that has been</span>
<span class="sd">        smoothed in time with a gaussian kernel M in width and standard</span>
<span class="sd">        deviation equal to sigma.</span>

<span class="sd">        Args:</span>
<span class="sd">            x1 (np.array): The pos indices the spikes occurred at.</span>
<span class="sd">            npos (int): The number of position samples captured.</span>
<span class="sd">            sigma (float): The standard deviation of the gaussian used to</span>
<span class="sd">                smooth the spike train.</span>
<span class="sd">            shuffle (int, optional): The number of seconds to shift the spike</span>
<span class="sd">                train by. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            smoothed_spikes (np.array): The smoothed spike train.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">npos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spk_hist</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">shuffle</span> <span class="o">*</span> <span class="mi">50</span><span class="p">))</span>
        <span class="c1"># smooth the spk_hist (which is a temporal histogram) with a 250ms</span>
        <span class="c1"># gaussian as with Kropff et al., 2015</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spk_hist</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">contamination_percent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">Qi</span><span class="p">,</span> <span class="n">Q00</span><span class="p">,</span> <span class="n">Q01</span><span class="p">,</span> <span class="n">Ri</span> <span class="o">=</span> <span class="n">contamination_percent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Qi</span> <span class="o">/</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">Q00</span><span class="p">,</span> <span class="n">Q01</span><span class="p">)))</span>  <span class="c1"># this is a measure of refractoriness</span>
        <span class="c1"># this is a second measure of refractoriness (kicks in for very low</span>
        <span class="c1"># firing rates)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">Ri</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.n_spikes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">n_spikes</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the number of spikes in the cluster</p>
<p>Returns:
    int: The number of spikes in the cluster</p>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.acorr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">acorr</span><span class="p">(</span><span class="n">Trange</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculates the autocorrelogram of a spike train</p>
<p>Args:
    ts (np.ndarray): The spike times
    Trange (np.ndarray): The range of times to calculate the
        autocorrelogram over</p>
<p>Returns:
result: (BinnedData): Container for the binned data</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">acorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Trange</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the autocorrelogram of a spike train</span>

<span class="sd">    Args:</span>
<span class="sd">        ts (np.ndarray): The spike times</span>
<span class="sd">        Trange (np.ndarray): The range of times to calculate the</span>
<span class="sd">            autocorrelogram over</span>

<span class="sd">    Returns:</span>
<span class="sd">    result: (BinnedData): Container for the binned data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">xcorr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">Trange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.apply_filter" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">apply_filter</span><span class="p">(</span><span class="o">*</span><span class="n">trial_filter</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Applies a mask to the spike times</p>
<p>Args
    mask (list or tuple): The mask to apply to the spike times</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_filter</span><span class="p">:</span> <span class="n">TrialFilter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a mask to the spike times</span>

<span class="sd">    Args</span>
<span class="sd">        mask (list or tuple): The mask to apply to the spike times</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trial_filter</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i_filter</span> <span class="ow">in</span> <span class="n">trial_filter</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i_filter</span><span class="p">,</span> <span class="n">TrialFilter</span><span class="p">),</span> <span class="s2">&quot;Filter must be a TrialFilter&quot;</span>
            <span class="k">assert</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;Only time filters are supported&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">trial_filter</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">trial_filter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i_filter</span> <span class="ow">in</span> <span class="n">trial_filter</span><span class="p">:</span>
            <span class="n">i_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">&gt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">&lt;</span> <span class="n">i_filter</span><span class="o">.</span><span class="n">end</span>
            <span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">i_mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_waves</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_ifr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_ifr</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the instantaneous firing rate of the cluster</p>
<p>Args:
    ts (np.array): The times in seconds at which the cluster fired.
    n_samples (int): The number of samples to use in the calculation.
                     Practically this should be the number of position
                     samples in the recording.</p>
<p>Returns:
    ifr (np.array): The instantaneous firing rate of the cluster</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_ifr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the instantaneous firing rate of the cluster</span>

<span class="sd">    Args:</span>
<span class="sd">        ts (np.array): The times in seconds at which the cluster fired.</span>
<span class="sd">        n_samples (int): The number of samples to use in the calculation.</span>
<span class="sd">                         Practically this should be the number of position</span>
<span class="sd">                         samples in the recording.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ifr (np.array): The instantaneous firing rate of the cluster</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">posSampRate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">spike_times</span> <span class="o">*</span> <span class="n">posSampRate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">n_samples</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
    <span class="n">spk_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spk_hist</span><span class="p">)</span>
    <span class="n">ifr</span> <span class="o">=</span> <span class="n">spk_sm</span> <span class="o">*</span> <span class="n">posSampRate</span>
    <span class="k">return</span> <span class="n">ifr</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_ifr_power_spectrum" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_ifr_power_spectrum</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the power spectrum of the instantaneous firing rate of a cell</p>
<p>This is what is used to calculate the theta_mod_idxV3 score above</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span>
<span class="normal">983</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_ifr_power_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the power spectrum of the instantaneous firing rate of a cell</span>

<span class="sd">    This is what is used to calculate the theta_mod_idxV3 score above</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binned_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
        <span class="n">minlength</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="c1"># possibly smooth the spike train...</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">binned_spikes</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.ifr_sp_corr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">ifr_sp_corr</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">minSpeed</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">maxSpeed</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nShuffles</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculates the correlation between the instantaneous firing rate and
speed.</p>
<p>Args:
    ts (np.array): The times in seconds at which the cluster fired.
    speed (np.array): Instantaneous speed (1 x nSamples).
    minSpeed (float, optional): Speeds below this value are ignored.
        Defaults to 2.0 cm/s as with Kropff et al., 2015.
    maxSpeed (float, optional): Speeds above this value are ignored.
        Defaults to 40.0 cm/s.
    sigma (int, optional): The standard deviation of the gaussian used
        to smooth the spike train. Defaults to 3.
    nShuffles (int, optional): The number of resamples to feed into
        the permutation test. Defaults to 9999.
        See scipy.stats.PermutationMethod.
    plot (bool, optional): Whether to plot the result.
        Defaults to False.
kwargs:
    method: how the significance of the speed vs firing rate correlation
            is calculated - see the documentation for scipy.stats.PermutationMethod</p>
<pre><code>        An example of how I was calculating this is:

        &gt;&gt; rng = np.random.default_rng()
        &gt;&gt; method = stats.PermutationMethod(n_resamples=nShuffles, random_state=rng)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">ifr_sp_corr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">ts</span><span class="p">,</span>
    <span class="n">speed</span><span class="p">,</span>
    <span class="n">minSpeed</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
    <span class="n">maxSpeed</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span>
    <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">nShuffles</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the correlation between the instantaneous firing rate and</span>
<span class="sd">    speed.</span>

<span class="sd">    Args:</span>
<span class="sd">        ts (np.array): The times in seconds at which the cluster fired.</span>
<span class="sd">        speed (np.array): Instantaneous speed (1 x nSamples).</span>
<span class="sd">        minSpeed (float, optional): Speeds below this value are ignored.</span>
<span class="sd">            Defaults to 2.0 cm/s as with Kropff et al., 2015.</span>
<span class="sd">        maxSpeed (float, optional): Speeds above this value are ignored.</span>
<span class="sd">            Defaults to 40.0 cm/s.</span>
<span class="sd">        sigma (int, optional): The standard deviation of the gaussian used</span>
<span class="sd">            to smooth the spike train. Defaults to 3.</span>
<span class="sd">        nShuffles (int, optional): The number of resamples to feed into</span>
<span class="sd">            the permutation test. Defaults to 9999.</span>
<span class="sd">            See scipy.stats.PermutationMethod.</span>
<span class="sd">        plot (bool, optional): Whether to plot the result.</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">    kwargs:</span>
<span class="sd">        method: how the significance of the speed vs firing rate correlation</span>
<span class="sd">                is calculated - see the documentation for scipy.stats.PermutationMethod</span>

<span class="sd">                An example of how I was calculating this is:</span>

<span class="sd">                &gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">                &gt;&gt; method = stats.PermutationMethod(n_resamples=nShuffles, random_state=rng)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">orig_speed_mask</span> <span class="o">=</span> <span class="n">speed</span><span class="o">.</span><span class="n">mask</span>
    <span class="n">posSampRate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
    <span class="n">nSamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ts</span> <span class="o">*</span> <span class="n">posSampRate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># crop the end of the timestamps if longer than the pos data</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x1</span> <span class="o">&gt;=</span> <span class="n">nSamples</span><span class="p">))</span>
    <span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nSamples</span><span class="p">)</span>
    <span class="c1"># smooth the spk_hist (which is a temporal histogram) with a 250ms</span>
    <span class="c1"># gaussian as with Kropff et al., 2015</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
    <span class="c1"># filter for low and high speeds</span>
    <span class="n">speed_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="n">minSpeed</span><span class="p">,</span> <span class="n">speed</span> <span class="o">&gt;</span> <span class="n">maxSpeed</span><span class="p">)</span>
    <span class="c1"># make sure the original mask is preserved</span>
    <span class="n">speed_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">speed_mask</span><span class="p">,</span> <span class="n">orig_speed_mask</span><span class="p">)</span>
    <span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">speed_mask</span><span class="p">)</span>
    <span class="c1">## speed might contain nans so mask these too</span>
    <span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">fix_invalid</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">)</span>
    <span class="n">speed_mask</span> <span class="o">=</span> <span class="n">speed_filt</span><span class="o">.</span><span class="n">mask</span>
    <span class="n">spk_hist_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spk_hist</span><span class="p">,</span> <span class="n">speed_mask</span><span class="p">)</span>
    <span class="n">spk_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spk_hist_filt</span><span class="p">)</span>
    <span class="n">sm_spk_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spk_sm</span> <span class="o">*</span> <span class="n">posSampRate</span><span class="p">,</span> <span class="n">speed_mask</span><span class="p">)</span>
    <span class="c1"># the permutation test for significance, only perform</span>
    <span class="c1"># on the non-masked data</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">PermutationMethod</span><span class="p">(</span><span class="n">n_resamples</span><span class="o">=</span><span class="n">nShuffles</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span>
        <span class="n">sm_spk_rate</span><span class="o">.</span><span class="n">compressed</span><span class="p">(),</span> <span class="n">speed_filt</span><span class="o">.</span><span class="n">compressed</span><span class="p">(),</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.mean_isi_range" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">mean_isi_range</span><span class="p">(</span><span class="n">isi_range</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculates the mean of the autocorrelation from 0 to n milliseconds
Used to help classify a neurons type (principal, interneuron etc)</p>
<p>Args:
    isi_range (int): The range in ms to calculate the mean over</p>
<p>Returns:
    float: The mean of the autocorrelogram between 0 and n milliseconds</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">mean_isi_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isi_range</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the mean of the autocorrelation from 0 to n milliseconds</span>
<span class="sd">    Used to help classify a neurons type (principal, interneuron etc)</span>

<span class="sd">    Args:</span>
<span class="sd">        isi_range (int): The range in ms to calculate the mean over</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The mean of the autocorrelogram between 0 and n milliseconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="mi">201</span>
    <span class="n">trange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">))</span>
    <span class="n">ac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acorr</span><span class="p">(</span><span class="n">Trange</span><span class="o">=</span><span class="n">trange</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="n">isi_range</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.mean_waveform" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">mean_waveform</span><span class="p">(</span><span class="n">channel_id</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the mean waveform and sem for a given spike train on a
particular channel</p>
<p>Args:
    cluster_id (int): The cluster to get the mean waveform for</p>
<p>Returns:
    mn_wvs (ndarray): The mean waveforms, usually 4x50 for tetrode
                        recordings
    std_wvs (ndarray): The standard deviations of the waveforms,
                        usually 4x50 for tetrode recordings</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">mean_waveform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_id</span><span class="p">:</span> <span class="n">Sequence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the mean waveform and sem for a given spike train on a</span>
<span class="sd">    particular channel</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster_id (int): The cluster to get the mean waveform for</span>

<span class="sd">    Returns:</span>
<span class="sd">        mn_wvs (ndarray): The mean waveforms, usually 4x50 for tetrode</span>
<span class="sd">                            recordings</span>
<span class="sd">        std_wvs (ndarray): The standard deviations of the waveforms,</span>
<span class="sd">                            usually 4x50 for tetrode recordings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">(</span><span class="n">channel_id</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.psch" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">psch</span><span class="p">(</span><span class="n">bin_width_secs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate the peri-stimulus <em>count</em> histogram of a cell's spiking
against event times.</p>
<p>Args:
    bin_width_secs (float): The width of each bin in seconds.</p>
<p>Returns:
    result (np.ndarray): Rows are counts of spikes per bin_width_secs.
    Size of columns ranges from self.event_window[0] to
    self.event_window[1] with bin_width_secs steps;
    so x is count, y is "event".</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">psch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_width_secs</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the peri-stimulus *count* histogram of a cell&#39;s spiking</span>
<span class="sd">    against event times.</span>

<span class="sd">    Args:</span>
<span class="sd">        bin_width_secs (float): The width of each bin in seconds.</span>

<span class="sd">    Returns:</span>
<span class="sd">        result (np.ndarray): Rows are counts of spikes per bin_width_secs.</span>
<span class="sd">        Size of columns ranges from self.event_window[0] to</span>
<span class="sd">        self.event_window[1] with bin_width_secs steps;</span>
<span class="sd">        so x is count, y is &quot;event&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need some event timestamps! Aborting&quot;</span><span class="p">)</span>
    <span class="n">event_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_ts</span>
    <span class="n">event_ts</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event_ts</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">event_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">event_ts</span><span class="p">)</span>

    <span class="n">irange</span> <span class="o">=</span> <span class="n">event_ts</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_width_secs</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_ts</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">event_ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.psth" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">psth</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate the PSTH of event_ts against the spiking of a cell</p>
<p>Args:
    cluster_id (int): The cluster for which to calculate the psth</p>
<p>Returns:
    x, y (list): The list of time differences between the spikes of
                    the cluster and the events (x) and the trials (y)</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">psth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the PSTH of event_ts against the spiking of a cell</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster_id (int): The cluster for which to calculate the psth</span>

<span class="sd">    Returns:</span>
<span class="sd">        x, y (list): The list of time differences between the spikes of</span>
<span class="sd">                        the cluster and the events (x) and the trials (y)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need some event timestamps! Aborting&quot;</span><span class="p">)</span>
    <span class="n">event_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_ts</span>
    <span class="n">event_ts</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event_ts</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">event_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">event_ts</span><span class="p">)</span>

    <span class="n">irange</span> <span class="o">=</span> <span class="n">event_ts</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">event_ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.responds_to_stimulus" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">responds_to_stimulus</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">min_contiguous</span><span class="p">,</span> <span class="n">return_activity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_magnitude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Checks whether a cluster responds to a laser stimulus.</p>
<p>Args:
    cluster (int): The cluster to check.
    threshold (float): The amount of activity the cluster needs to go
        beyond to be classified as a responder (1.5 = 50% more or less
        than the baseline activity).
    min_contiguous (int): The number of contiguous samples in the
        post-stimulus period for which the cluster needs to be active
        beyond the threshold value to be classed as a responder.
    return_activity (bool): Whether to return the mean reponse curve.
    return_magnitude (int): Whether to return the magnitude of the
        response. NB this is either +1 for excited or -1 for inhibited.</p>
<p>Returns:
    responds (bool): Whether the cell responds or not.
    OR
    tuple: responds (bool), normed_response_curve (np.ndarray).
    OR
    tuple: responds (bool), normed_response_curve (np.ndarray),
        response_magnitude (np.ndarray).</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">responds_to_stimulus</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">min_contiguous</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">return_activity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_magnitude</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether a cluster responds to a laser stimulus.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster to check.</span>
<span class="sd">        threshold (float): The amount of activity the cluster needs to go</span>
<span class="sd">            beyond to be classified as a responder (1.5 = 50% more or less</span>
<span class="sd">            than the baseline activity).</span>
<span class="sd">        min_contiguous (int): The number of contiguous samples in the</span>
<span class="sd">            post-stimulus period for which the cluster needs to be active</span>
<span class="sd">            beyond the threshold value to be classed as a responder.</span>
<span class="sd">        return_activity (bool): Whether to return the mean reponse curve.</span>
<span class="sd">        return_magnitude (int): Whether to return the magnitude of the</span>
<span class="sd">            response. NB this is either +1 for excited or -1 for inhibited.</span>

<span class="sd">    Returns:</span>
<span class="sd">        responds (bool): Whether the cell responds or not.</span>
<span class="sd">        OR</span>
<span class="sd">        tuple: responds (bool), normed_response_curve (np.ndarray).</span>
<span class="sd">        OR</span>
<span class="sd">        tuple: responds (bool), normed_response_curve (np.ndarray),</span>
<span class="sd">            response_magnitude (np.ndarray).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spk_count_by_trial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_secs_per_bin</span><span class="p">)</span>
    <span class="n">firing_rate_by_trial</span> <span class="o">=</span> <span class="n">spk_count_by_trial</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">secs_per_bin</span>
    <span class="n">mean_firing_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">firing_rate_by_trial</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># smooth with a moving average</span>
    <span class="c1"># check nothing in kwargs first</span>
    <span class="k">if</span> <span class="s2">&quot;window_len&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">window_len</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;window_len&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">window_len</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="k">if</span> <span class="s2">&quot;window&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;window&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="s2">&quot;flat&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;flat&quot;</span> <span class="ow">in</span> <span class="n">window</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Box1DKernel</span><span class="p">(</span><span class="n">window_len</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;gauss&quot;</span> <span class="ow">in</span> <span class="n">window</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian1DKernel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_len</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;do_smooth&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">do_smooth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;do_smooth&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">do_smooth</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">do_smooth</span><span class="p">:</span>
        <span class="n">smoothed_binned_spikes</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">mean_firing_rate</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">smoothed_binned_spikes</span> <span class="o">=</span> <span class="n">mean_firing_rate</span>
    <span class="n">nbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">secs_per_bin</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbins</span><span class="p">))</span>
    <span class="c1"># normalize all activity by activity in the time before</span>
    <span class="c1"># the laser onset</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="n">normd</span> <span class="o">=</span> <span class="n">min_max_norm</span><span class="p">(</span>
        <span class="n">smoothed_binned_spikes</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">smoothed_binned_spikes</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">smoothed_binned_spikes</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
    <span class="p">)</span>
    <span class="c1"># mask the array outside of a threshold value so that</span>
    <span class="c1"># only True values in the masked array are those that</span>
    <span class="c1"># exceed the threshold (positively or negatively)</span>
    <span class="c1"># the threshold provided to this function is expressed</span>
    <span class="c1"># as a % above / below unit normality so adjust that now</span>
    <span class="c1"># so it is expressed as a pre-stimulus firing rate mean</span>
    <span class="c1"># pre_stim_mean = np.mean(smoothed_binned_spikes[idx])</span>
    <span class="c1"># pre_stim_max = pre_stim_mean * threshold</span>
    <span class="c1"># pre_stim_min = pre_stim_mean * (threshold-1.0)</span>
    <span class="c1"># updated so threshold is double (+ or -) the pre-stim</span>
    <span class="c1"># norm (lies between )</span>
    <span class="n">normd_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_inside</span><span class="p">(</span><span class="n">normd</span><span class="p">,</span> <span class="o">-</span><span class="n">threshold</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="c1"># find the contiguous runs in the masked array</span>
    <span class="c1"># that are at least as long as the min_contiguous value</span>
    <span class="c1"># and classify this as a True response</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">notmasked_contiguous</span><span class="p">(</span><span class="n">normd_masked</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slices</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">normd</span><span class="p">)):</span>
        <span class="c1"># make sure that slices are within the first 25ms post-stim</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">75</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">return_activity</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_magnitude</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">normd</span><span class="p">,</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">normd</span>
        <span class="n">max_runlength</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">normd_masked</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">max_runlength</span> <span class="o">&gt;=</span> <span class="n">min_contiguous</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">return_activity</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_magnitude</span><span class="p">:</span>
                    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">slc</span>
                        <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">slices</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">slc</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_runlength</span>
                    <span class="p">]</span>
                    <span class="n">mag</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">normd</span><span class="p">[</span><span class="n">sl</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">normd</span><span class="p">,</span> <span class="n">mag</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">normd</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_activity</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_magnitude</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">normd</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">normd</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.smooth_spike_train" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">smooth_spike_train</span><span class="p">(</span><span class="n">npos</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns a spike train the same length as num pos samples that has been
smoothed in time with a gaussian kernel M in width and standard
deviation equal to sigma.</p>
<p>Args:
    x1 (np.array): The pos indices the spikes occurred at.
    npos (int): The number of position samples captured.
    sigma (float): The standard deviation of the gaussian used to
        smooth the spike train.
    shuffle (int, optional): The number of seconds to shift the spike
        train by. Default is None.</p>
<p>Returns:
    smoothed_spikes (np.array): The smoothed spike train.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">smooth_spike_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">npos</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a spike train the same length as num pos samples that has been</span>
<span class="sd">    smoothed in time with a gaussian kernel M in width and standard</span>
<span class="sd">    deviation equal to sigma.</span>

<span class="sd">    Args:</span>
<span class="sd">        x1 (np.array): The pos indices the spikes occurred at.</span>
<span class="sd">        npos (int): The number of position samples captured.</span>
<span class="sd">        sigma (float): The standard deviation of the gaussian used to</span>
<span class="sd">            smooth the spike train.</span>
<span class="sd">        shuffle (int, optional): The number of seconds to shift the spike</span>
<span class="sd">            train by. Default is None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        smoothed_spikes (np.array): The smoothed spike train.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">npos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spk_hist</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">shuffle</span> <span class="o">*</span> <span class="mi">50</span><span class="p">))</span>
    <span class="c1"># smooth the spk_hist (which is a temporal histogram) with a 250ms</span>
    <span class="c1"># gaussian as with Kropff et al., 2015</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spk_hist</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_band_max_freq" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">theta_band_max_freq</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculates the frequency with the maximum power in the theta band (6-12Hz)
of a spike train's autocorrelogram.</p>
<p>This function is used to look for differences in theta frequency in
different running directions as per Blair.
See Welday paper - https://doi.org/10.1523/jneurosci.0712-11.2011</p>
<p>Args:
    x1 (np.ndarray): The spike train for which the autocorrelogram will be
        calculated.</p>
<p>Returns:
    float: The frequency with the maximum power in the theta band.</p>
<p>Raises:
    ValueError: If the input spike train is not valid.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">theta_band_max_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the frequency with the maximum power in the theta band (6-12Hz)</span>
<span class="sd">    of a spike train&#39;s autocorrelogram.</span>

<span class="sd">    This function is used to look for differences in theta frequency in</span>
<span class="sd">    different running directions as per Blair.</span>
<span class="sd">    See Welday paper - https://doi.org/10.1523/jneurosci.0712-11.2011</span>

<span class="sd">    Args:</span>
<span class="sd">        x1 (np.ndarray): The spike train for which the autocorrelogram will be</span>
<span class="sd">            calculated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The frequency with the maximum power in the theta band.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the input spike train is not valid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acorr</span><span class="p">()</span>
    <span class="c1"># Take the fft of the spike train autocorr (from -500 to +500ms)</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">periodogram</span>

    <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">power_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">freqs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">power_masked</span><span class="p">)]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idx" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">theta_mod_idx</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculates a theta modulation index of a spike train based on the cells
autocorrelogram.</p>
<p>The difference of the mean power in the theta frequency band (6-11 Hz) and
the mean power in the 1-50 Hz frequency band is divided by their sum to give
a metric that lives between 0 and 1</p>
<p>Args:
    x1 (np.array): The spike time-series.</p>
<p>Returns:
    thetaMod (float): The difference of the values at the first peak
    and trough of the autocorrelogram.</p>
<p>NB This is a fairly skewed metric with a distribution strongly biased
to -1 (although more evenly distributed than theta_mod_idxV2 below)</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">theta_mod_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates a theta modulation index of a spike train based on the cells</span>
<span class="sd">    autocorrelogram.</span>

<span class="sd">    The difference of the mean power in the theta frequency band (6-11 Hz) and</span>
<span class="sd">    the mean power in the 1-50 Hz frequency band is divided by their sum to give</span>
<span class="sd">    a metric that lives between 0 and 1</span>

<span class="sd">    Args:</span>
<span class="sd">        x1 (np.array): The spike time-series.</span>

<span class="sd">    Returns:</span>
<span class="sd">        thetaMod (float): The difference of the values at the first peak</span>
<span class="sd">        and trough of the autocorrelogram.</span>

<span class="sd">    NB This is a fairly skewed metric with a distribution strongly biased</span>
<span class="sd">    to -1 (although more evenly distributed than theta_mod_idxV2 below)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acorr</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Take the fft of the spike train autocorr (from -500 to +500ms)</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">periodogram</span>

    <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;binsize&quot;</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">)</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Smooth the power over +/- 1Hz when fs=200</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">boxcar</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># another filter type - blackman?</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>

    <span class="c1"># Square the amplitude first to get power</span>
    <span class="n">sqd_amp</span> <span class="o">=</span> <span class="n">h</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># Get the mean theta band power - mtbp</span>
    <span class="n">mtbp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sqd_amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;=</span> <span class="mi">11</span><span class="p">)])</span>
    <span class="c1"># Find the mean amplitude in the 1-50Hz range</span>
    <span class="c1"># Get the mean in the other band - mobp</span>
    <span class="n">mobp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sqd_amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)])</span>
    <span class="c1"># Find the ratio of these two - this is the theta modulation index</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="n">mtbp</span> <span class="o">-</span> <span class="n">mobp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mtbp</span> <span class="o">+</span> <span class="n">mobp</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idxV2" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">theta_mod_idxV2</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>This is a simpler alternative to the theta_mod_idx method in that it
calculates the difference between the normalized temporal
autocorrelogram at the trough between 50-70ms and the
peak between 100-140ms over their sum (data is binned into 5ms bins)</p>
<p>Measure used in Cacucci et al., 2004 and Kropff et al 2015</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">theta_mod_idxV2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a simpler alternative to the theta_mod_idx method in that it</span>
<span class="sd">    calculates the difference between the normalized temporal</span>
<span class="sd">    autocorrelogram at the trough between 50-70ms and the</span>
<span class="sd">    peak between 100-140ms over their sum (data is binned into 5ms bins)</span>

<span class="sd">    Measure used in Cacucci et al., 2004 and Kropff et al 2015</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acorr</span><span class="p">()</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># &#39;close&#39; the right-hand bin</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># normalise corr so max is 1.0</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">corr</span><span class="p">))</span>
    <span class="n">thetaAntiPhase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
        <span class="n">corr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="mi">70</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="n">thetaPhase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
        <span class="n">corr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="mi">140</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="n">thetaPhase</span> <span class="o">-</span> <span class="n">thetaAntiPhase</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">thetaPhase</span> <span class="o">+</span> <span class="n">thetaAntiPhase</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idxV3" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">theta_mod_idxV3</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Another theta modulation index score this time based on the method used
by Kornienko et al., (2024) (Kevin Allens lab)
see https://doi.org/10.7554/eLife.35949.001</p>
<p>Basically uses the binned spike train instead of the autocorrelogram as
the input to the periodogram function (they use pwelch in R; periodogram is a
simplified call to welch in scipy.signal)</p>
<p>The resulting metric is similar to the one in theta_mod_idx above except
that the frequency bands compared to the theta band are narrower and
exclusive of the theta band</p>
<p>Produces a fairly normally distributed looking score with a mean and median
pretty close to 0</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span>
<span class="normal">944</span>
<span class="normal">945</span>
<span class="normal">946</span>
<span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span>
<span class="normal">957</span>
<span class="normal">958</span>
<span class="normal">959</span>
<span class="normal">960</span>
<span class="normal">961</span>
<span class="normal">962</span>
<span class="normal">963</span>
<span class="normal">964</span>
<span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">theta_mod_idxV3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Another theta modulation index score this time based on the method used</span>
<span class="sd">    by Kornienko et al., (2024) (Kevin Allens lab)</span>
<span class="sd">    see https://doi.org/10.7554/eLife.35949.001</span>

<span class="sd">    Basically uses the binned spike train instead of the autocorrelogram as</span>
<span class="sd">    the input to the periodogram function (they use pwelch in R; periodogram is a</span>
<span class="sd">    simplified call to welch in scipy.signal)</span>

<span class="sd">    The resulting metric is similar to the one in theta_mod_idx above except</span>
<span class="sd">    that the frequency bands compared to the theta band are narrower and</span>
<span class="sd">    exclusive of the theta band</span>

<span class="sd">    Produces a fairly normally distributed looking score with a mean and median</span>
<span class="sd">    pretty close to 0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ifr_power_spectrum</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># smooth with a boxcar filter with a 0.5Hz window</span>
    <span class="n">win_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">boxcar</span><span class="p">(</span><span class="n">win_len</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
    <span class="n">sqd_amp</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">mtbp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sqd_amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)])</span>
    <span class="n">mobp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
        <span class="n">sqd_amp</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="n">mtbp</span> <span class="o">-</span> <span class="n">mobp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mtbp</span> <span class="o">+</span> <span class="n">mobp</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsGeneric.update_KSMeta" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">update_KSMeta</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Takes in a TemplateModel instance from a phy session and
parses out the relevant metrics for the cluster and places
into the namedtuple KSMeta</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">update_KSMeta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes in a TemplateModel instance from a phy session and</span>
<span class="sd">    parses out the relevant metrics for the cluster and places</span>
<span class="sd">    into the namedtuple KSMeta</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metavals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">KSMetaTuple</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">metavals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metavals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metavals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_ksmeta</span> <span class="o">=</span> <span class="n">KSMetaTuple</span><span class="p">(</span><span class="o">*</span><span class="n">metavals</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys" class="doc doc-heading">
            <code>SpikeCalcsOpenEphys</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ephysiopy.common.spikecalcs.SpikeCalcsGeneric" href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric">SpikeCalcsGeneric</a></code></p>







              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">SpikeCalcsOpenEphys</span><span class="p">(</span><span class="n">SpikeCalcsGeneric</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">41</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TemplateModel</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">cluster_data</span><span class="p">:</span> <span class="n">KiloSortSession</span><span class="p">,</span>
        <span class="n">n_waveforms</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
        <span class="n">n_channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
        <span class="n">channel_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns waveforms for a cluster.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster (int): The cluster to return the waveforms for.</span>
<span class="sd">            cluster_data (KiloSortSession): The KiloSortSession object for the</span>
<span class="sd">                session that contains the cluster.</span>
<span class="sd">            n_waveforms (int, optional): The number of waveforms to return.</span>
<span class="sd">                Defaults to 2000.</span>
<span class="sd">            n_channels (int, optional): The number of channels in the</span>
<span class="sd">                recording. Defaults to 64.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># instantiate the TemplateModel - this is used to get the waveforms</span>
        <span class="c1"># for the cluster. TemplateModel encapsulates the results of KiloSort</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">TemplateModel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TemplateModel</span> <span class="o">=</span> <span class="n">TemplateModel</span><span class="p">(</span>
                <span class="n">dir_path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cluster_data</span><span class="o">.</span><span class="n">fname_root</span><span class="p">),</span>
                <span class="n">sample_rate</span><span class="o">=</span><span class="mf">3e4</span><span class="p">,</span>
                <span class="n">dat_path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cluster_data</span><span class="o">.</span><span class="n">fname_root</span><span class="p">,</span> <span class="s2">&quot;continuous.dat&quot;</span><span class="p">),</span>
                <span class="n">n_channels_dat</span><span class="o">=</span><span class="n">n_channels</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># get the waveforms for the given cluster on the best channel only</span>
        <span class="n">waveforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TemplateModel</span><span class="o">.</span><span class="n">get_cluster_spike_waveforms</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="c1"># get a random subset of the waveforms</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
        <span class="n">total_waves</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_waveforms</span> <span class="o">=</span> <span class="n">n_waveforms</span> <span class="k">if</span> <span class="n">n_waveforms</span> <span class="o">&lt;</span> <span class="n">total_waves</span> <span class="k">else</span> <span class="n">total_waves</span>
        <span class="n">waveforms_subset</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">n_waveforms</span><span class="p">)</span>
        <span class="c1"># return the waveforms</span>
        <span class="k">if</span> <span class="n">channel_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">waveforms_subset</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_range</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">waveforms_subset</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel_range</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Invalid channel_range sequence&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_channel_depth_from_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">:</span> <span class="n">Path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine depth of template as well as closest channel. Adopted from</span>
<span class="sd">        &#39;templatePositionsAmplitudes&#39; by N. Steinmetz</span>
<span class="sd">        (https://github.com/cortex-lab/spikes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load inverse whitening matrix</span>
        <span class="n">Winv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;whitening_mat_inv.npy&quot;</span><span class="p">))</span>
        <span class="c1"># Load templates</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;templates.npy&quot;</span><span class="p">))</span>
        <span class="c1"># Load channel_map and positions</span>
        <span class="n">channel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;channel_map.npy&quot;</span><span class="p">))</span>
        <span class="n">channel_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;channel_positions.npy&quot;</span><span class="p">))</span>
        <span class="n">map_and_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">channel_map</span><span class="p">),</span> <span class="n">channel_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="c1"># unwhiten all the templates</span>
        <span class="n">tempsUnW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">templates</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">templates</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">tempsUnW</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">templates</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">@</span> <span class="n">Winv</span>

        <span class="n">tempAmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tempsUnW</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tempsUnW</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">tempAmpsUnscaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tempAmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># need to zero-out the potentially-many low values on distant channels</span>
        <span class="n">threshVals</span> <span class="o">=</span> <span class="n">tempAmpsUnscaled</span> <span class="o">*</span> <span class="mf">0.3</span>
        <span class="n">tempAmp</span><span class="p">[</span><span class="n">tempAmp</span> <span class="o">&lt;</span> <span class="n">threshVals</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Compute the depth as a centre of mass</span>
        <span class="n">templateDepths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tempAmp</span> <span class="o">*</span> <span class="n">map_and_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tempAmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">maxChanIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">templateDepths</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">map_and_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">templateDepths</span><span class="p">,</span> <span class="n">maxChanIdx</span>

    <span class="k">def</span> <span class="nf">get_template_id_for_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the best channel (one with highest amplitude spikes)</span>
<span class="sd">        for a given cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spike_templates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;spike_templates.npy&quot;</span><span class="p">))</span>
        <span class="n">spike_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;spike_times.npy&quot;</span><span class="p">))</span>
        <span class="n">spike_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;spike_clusters.npy&quot;</span><span class="p">))</span>
        <span class="n">cluster_times</span> <span class="o">=</span> <span class="n">spike_times</span><span class="p">[</span><span class="n">spike_clusters</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]</span>
        <span class="n">rez_mat</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;rez.mat&quot;</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">st3</span> <span class="o">=</span> <span class="n">rez_mat</span><span class="p">[</span><span class="s2">&quot;rez&quot;</span><span class="p">][</span><span class="s2">&quot;st3&quot;</span><span class="p">]</span>
        <span class="n">st_spike_times</span> <span class="o">=</span> <span class="n">st3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">st_spike_times</span><span class="p">,</span> <span class="n">cluster_times</span><span class="p">)</span>
        <span class="n">template_idx</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">spike_templates</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">template_idx</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys.get_channel_depth_from_templates" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_channel_depth_from_templates</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Determine depth of template as well as closest channel. Adopted from
'templatePositionsAmplitudes' by N. Steinmetz
(https://github.com/cortex-lab/spikes)</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_channel_depth_from_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">:</span> <span class="n">Path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine depth of template as well as closest channel. Adopted from</span>
<span class="sd">    &#39;templatePositionsAmplitudes&#39; by N. Steinmetz</span>
<span class="sd">    (https://github.com/cortex-lab/spikes)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load inverse whitening matrix</span>
    <span class="n">Winv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;whitening_mat_inv.npy&quot;</span><span class="p">))</span>
    <span class="c1"># Load templates</span>
    <span class="n">templates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;templates.npy&quot;</span><span class="p">))</span>
    <span class="c1"># Load channel_map and positions</span>
    <span class="n">channel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;channel_map.npy&quot;</span><span class="p">))</span>
    <span class="n">channel_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;channel_positions.npy&quot;</span><span class="p">))</span>
    <span class="n">map_and_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">channel_map</span><span class="p">),</span> <span class="n">channel_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="c1"># unwhiten all the templates</span>
    <span class="n">tempsUnW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">templates</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">templates</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">tempsUnW</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">templates</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">@</span> <span class="n">Winv</span>

    <span class="n">tempAmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tempsUnW</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tempsUnW</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">tempAmpsUnscaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tempAmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># need to zero-out the potentially-many low values on distant channels</span>
    <span class="n">threshVals</span> <span class="o">=</span> <span class="n">tempAmpsUnscaled</span> <span class="o">*</span> <span class="mf">0.3</span>
    <span class="n">tempAmp</span><span class="p">[</span><span class="n">tempAmp</span> <span class="o">&lt;</span> <span class="n">threshVals</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Compute the depth as a centre of mass</span>
    <span class="n">templateDepths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tempAmp</span> <span class="o">*</span> <span class="n">map_and_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tempAmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">maxChanIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">templateDepths</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">map_and_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">templateDepths</span><span class="p">,</span> <span class="n">maxChanIdx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys.get_template_id_for_cluster" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_template_id_for_cluster</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Determine the best channel (one with highest amplitude spikes)
for a given cluster.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_template_id_for_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pname</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the best channel (one with highest amplitude spikes)</span>
<span class="sd">    for a given cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spike_templates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;spike_templates.npy&quot;</span><span class="p">))</span>
    <span class="n">spike_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;spike_times.npy&quot;</span><span class="p">))</span>
    <span class="n">spike_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;spike_clusters.npy&quot;</span><span class="p">))</span>
    <span class="n">cluster_times</span> <span class="o">=</span> <span class="n">spike_times</span><span class="p">[</span><span class="n">spike_clusters</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]</span>
    <span class="n">rez_mat</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s2">&quot;rez.mat&quot;</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">st3</span> <span class="o">=</span> <span class="n">rez_mat</span><span class="p">[</span><span class="s2">&quot;rez&quot;</span><span class="p">][</span><span class="s2">&quot;st3&quot;</span><span class="p">]</span>
    <span class="n">st_spike_times</span> <span class="o">=</span> <span class="n">st3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">st_spike_times</span><span class="p">,</span> <span class="n">cluster_times</span><span class="p">)</span>
    <span class="n">template_idx</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">spike_templates</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">template_idx</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.spikecalcs.SpikeCalcsOpenEphys.get_waveforms" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_waveforms</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">cluster_data</span><span class="p">,</span> <span class="n">n_waveforms</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">channel_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns waveforms for a cluster.</p>
<p>Args:
    cluster (int): The cluster to return the waveforms for.
    cluster_data (KiloSortSession): The KiloSortSession object for the
        session that contains the cluster.
    n_waveforms (int, optional): The number of waveforms to return.
        Defaults to 2000.
    n_channels (int, optional): The number of channels in the
        recording. Defaults to 64.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_waveforms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">cluster_data</span><span class="p">:</span> <span class="n">KiloSortSession</span><span class="p">,</span>
    <span class="n">n_waveforms</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="n">n_channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
    <span class="n">channel_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns waveforms for a cluster.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster (int): The cluster to return the waveforms for.</span>
<span class="sd">        cluster_data (KiloSortSession): The KiloSortSession object for the</span>
<span class="sd">            session that contains the cluster.</span>
<span class="sd">        n_waveforms (int, optional): The number of waveforms to return.</span>
<span class="sd">            Defaults to 2000.</span>
<span class="sd">        n_channels (int, optional): The number of channels in the</span>
<span class="sd">            recording. Defaults to 64.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># instantiate the TemplateModel - this is used to get the waveforms</span>
    <span class="c1"># for the cluster. TemplateModel encapsulates the results of KiloSort</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">TemplateModel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TemplateModel</span> <span class="o">=</span> <span class="n">TemplateModel</span><span class="p">(</span>
            <span class="n">dir_path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cluster_data</span><span class="o">.</span><span class="n">fname_root</span><span class="p">),</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="mf">3e4</span><span class="p">,</span>
            <span class="n">dat_path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cluster_data</span><span class="o">.</span><span class="n">fname_root</span><span class="p">,</span> <span class="s2">&quot;continuous.dat&quot;</span><span class="p">),</span>
            <span class="n">n_channels_dat</span><span class="o">=</span><span class="n">n_channels</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="c1"># get the waveforms for the given cluster on the best channel only</span>
    <span class="n">waveforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TemplateModel</span><span class="o">.</span><span class="n">get_cluster_spike_waveforms</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
    <span class="c1"># get a random subset of the waveforms</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
    <span class="n">total_waves</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_waveforms</span> <span class="o">=</span> <span class="n">n_waveforms</span> <span class="k">if</span> <span class="n">n_waveforms</span> <span class="o">&lt;</span> <span class="n">total_waves</span> <span class="k">else</span> <span class="n">total_waves</span>
    <span class="n">waveforms_subset</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">n_waveforms</span><span class="p">)</span>
    <span class="c1"># return the waveforms</span>
    <span class="k">if</span> <span class="n">channel_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">waveforms_subset</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_range</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">waveforms_subset</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel_range</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Invalid channel_range sequence&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.spikecalcs.SpikeCalcsProbe" class="doc doc-heading">
            <code>SpikeCalcsProbe</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ephysiopy.common.spikecalcs.SpikeCalcsGeneric" href="#ephysiopy.common.spikecalcs.SpikeCalcsGeneric">SpikeCalcsGeneric</a></code></p>


        <p>Encapsulates methods specific to probe-based recordings</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">SpikeCalcsProbe</span><span class="p">(</span><span class="n">SpikeCalcsGeneric</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encapsulates methods specific to probe-based recordings</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.spikecalcs.cluster_quality" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">cluster_quality</span><span class="p">(</span><span class="n">waveforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spike_clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fet</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns the L-ratio and Isolation Distance measures calculated
on the principal components of the energy in a spike matrix.</p>
<p>Args:
    waveforms (np.ndarray, optional): The waveforms to be processed.
        If None, the function will return None.
    spike_clusters (np.ndarray, optional): The spike clusters to be
        processed.
    cluster_id (int, optional): The ID of the cluster to be processed.
    fet (int, default=1): The feature to be used in the PCA calculation.</p>
<p>Returns:
    tuple: A tuple containing the L-ratio and Isolation Distance of the
        cluster.</p>
<p>Raises:
    Exception: If an error occurs during the calculation of the L-ratio or
        Isolation Distance.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">cluster_quality</span><span class="p">(</span>
    <span class="n">waveforms</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spike_clusters</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cluster_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fet</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the L-ratio and Isolation Distance measures calculated</span>
<span class="sd">    on the principal components of the energy in a spike matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        waveforms (np.ndarray, optional): The waveforms to be processed.</span>
<span class="sd">            If None, the function will return None.</span>
<span class="sd">        spike_clusters (np.ndarray, optional): The spike clusters to be</span>
<span class="sd">            processed.</span>
<span class="sd">        cluster_id (int, optional): The ID of the cluster to be processed.</span>
<span class="sd">        fet (int, default=1): The feature to be used in the PCA calculation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the L-ratio and Isolation Distance of the</span>
<span class="sd">            cluster.</span>

<span class="sd">    Raises:</span>
<span class="sd">        Exception: If an error occurs during the calculation of the L-ratio or</span>
<span class="sd">            Isolation Distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">waveforms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">nSpikes</span><span class="p">,</span> <span class="n">nElectrodes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">wvs</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">waveforms</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">zeroIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="p">[:,</span> <span class="o">~</span><span class="n">zeroIdx</span><span class="p">]</span>
    <span class="n">wvs</span> <span class="o">=</span> <span class="n">wvs</span><span class="p">[:,</span> <span class="o">~</span><span class="n">zeroIdx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">normdWaves</span> <span class="o">=</span> <span class="p">(</span><span class="n">wvs</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">E</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">PCA_m</span> <span class="o">=</span> <span class="n">get_param</span><span class="p">(</span><span class="n">normdWaves</span><span class="p">,</span> <span class="s2">&quot;PCA&quot;</span><span class="p">,</span> <span class="n">fet</span><span class="o">=</span><span class="n">fet</span><span class="p">)</span>
    <span class="n">badIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">PCA_m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">PCA_m</span> <span class="o">=</span> <span class="n">PCA_m</span><span class="p">[:,</span> <span class="o">~</span><span class="n">badIdx</span><span class="p">]</span>
    <span class="c1"># get mahalanobis distance</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">spike_clusters</span> <span class="o">==</span> <span class="n">cluster_id</span>
    <span class="n">nClustSpikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">mahal</span><span class="p">(</span><span class="n">PCA_m</span><span class="p">,</span> <span class="n">PCA_m</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># get the indices of the spikes not in the cluster</span>
        <span class="n">M_noise</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">((</span><span class="n">fet</span><span class="p">,</span> <span class="n">nElectrodes</span><span class="p">))</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">M_noise</span><span class="p">,</span> <span class="n">df</span><span class="p">))</span>
        <span class="n">L_ratio</span> <span class="o">=</span> <span class="n">L</span> <span class="o">/</span> <span class="n">nClustSpikes</span>
        <span class="c1"># calculate isolation distance</span>
        <span class="k">if</span> <span class="n">nClustSpikes</span> <span class="o">&lt;</span> <span class="n">nSpikes</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">M_noise</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">isolation_dist</span> <span class="o">=</span> <span class="n">M_noise</span><span class="p">[</span><span class="n">nClustSpikes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isolation_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">isolation_dist</span> <span class="o">=</span> <span class="n">L_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">L_ratio</span><span class="p">,</span> <span class="n">isolation_dist</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.spikecalcs.contamination_percent" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">contamination_percent</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Computes the cross-correlogram between two sets of spikes and
estimates how refractory the cross-correlogram is.</p>
<p>Args:
    st1 (np.array): The first set of spikes.
    st2 (np.array): The second set of spikes.</p>
<p>kwargs:
    Anything that can be fed into xcorr above</p>
<p>Returns:
    Q (float): a measure of refractoriness
    R (float): a second measure of refractoriness
            (kicks in for very low firing rates)</p>
<p>Notes:
    Taken from KiloSorts ccg.m</p>
<pre><code>The contamination metrics are calculated based on
an analysis of the 'shoulders' of the cross-correlogram.
Specifically, the spike counts in the ranges +/-5-25ms and
+/-250-500ms are compared for refractoriness
</code></pre>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">contamination_percent</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the cross-correlogram between two sets of spikes and</span>
<span class="sd">    estimates how refractory the cross-correlogram is.</span>

<span class="sd">    Args:</span>
<span class="sd">        st1 (np.array): The first set of spikes.</span>
<span class="sd">        st2 (np.array): The second set of spikes.</span>

<span class="sd">    kwargs:</span>
<span class="sd">        Anything that can be fed into xcorr above</span>

<span class="sd">    Returns:</span>
<span class="sd">        Q (float): a measure of refractoriness</span>
<span class="sd">        R (float): a second measure of refractoriness</span>
<span class="sd">                (kicks in for very low firing rates)</span>

<span class="sd">    Notes:</span>
<span class="sd">        Taken from KiloSorts ccg.m</span>

<span class="sd">        The contamination metrics are calculated based on</span>
<span class="sd">        an analysis of the &#39;shoulders&#39; of the cross-correlogram.</span>
<span class="sd">        Specifically, the spike counts in the ranges +/-5-25ms and</span>
<span class="sd">        +/-250-500ms are compared for refractoriness</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="n">xcorr</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01</span><span class="p">]]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.051</span><span class="p">]]</span>
    <span class="n">far</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.249</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.501</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">get_shoulder</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="nb">all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">all</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">inner_left</span> <span class="o">=</span> <span class="n">get_shoulder</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
    <span class="n">inner_right</span> <span class="o">=</span> <span class="n">get_shoulder</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="n">outer</span> <span class="o">=</span> <span class="n">get_shoulder</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">far</span><span class="p">)</span>

    <span class="n">tbin</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">Tr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]))</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">get_normd_shoulder</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">tbin</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="n">Tr</span>
        <span class="p">)</span>

    <span class="n">Q00</span> <span class="o">=</span> <span class="n">get_normd_shoulder</span><span class="p">(</span><span class="n">outer</span><span class="p">)</span>
    <span class="n">Q01</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">get_normd_shoulder</span><span class="p">(</span><span class="n">inner_left</span><span class="p">),</span> <span class="n">get_normd_shoulder</span><span class="p">(</span><span class="n">inner_right</span><span class="p">))</span>

    <span class="n">R00</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">outer</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">inner_left</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">inner_right</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
    <span class="p">)</span>

    <span class="n">middle_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">middle_idx</span><span class="p">]</span>
    <span class="n">c</span><span class="p">[</span><span class="n">middle_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Qi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">Ri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="c1"># enumerate through the central range of the xcorr</span>
    <span class="c1"># saving the same calculation as done above</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>
        <span class="n">irange</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">]]</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">get_shoulder</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
        <span class="c1"># compute the same normalized ratio as above;</span>
        <span class="c1"># this should be 1 if there is no refractoriness</span>
        <span class="n">Qi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_normd_shoulder</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>  <span class="c1"># save the normd prob</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">chunk</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="n">R00</span> <span class="o">*</span> <span class="n">i</span>
        <span class="c1"># this is tricky: we approximate the Poisson likelihood with a</span>
        <span class="c1"># gaussian of equal mean and variance</span>
        <span class="c1"># that allows us to integrate the probability that we would see &lt;N</span>
        <span class="c1"># spikes in the center of the</span>
        <span class="c1"># cross-correlogram from a distribution with mean R00*i spikes</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">erf</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">lam</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lam</span><span class="p">)))</span>

        <span class="n">Ri</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>  <span class="c1"># keep track of p for each bin size i</span>

    <span class="n">c</span><span class="p">[</span><span class="n">middle_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>  <span class="c1"># restore the center value of the cross-correlogram</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">Qi</span><span class="p">,</span> <span class="n">Q00</span><span class="p">,</span> <span class="n">Q01</span><span class="p">,</span> <span class="n">Ri</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.spikecalcs.fit_smoothed_curve_to_xcorr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">fit_smoothed_curve_to_xcorr</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Idea is to smooth out the result of an auto- or cross-correlogram with
a view to correlating the result with another auto- or cross-correlogram
to see how similar two of these things are.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">fit_smoothed_curve_to_xcorr</span><span class="p">(</span><span class="n">xc</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Idea is to smooth out the result of an auto- or cross-correlogram with</span>
<span class="sd">    a view to correlating the result with another auto- or cross-correlogram</span>
<span class="sd">    to see how similar two of these things are.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.spikecalcs.get_param" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_param</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;Amp&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">fet</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns the requested parameter from a spike train as a numpy array</p>
<p>Args:
    waveforms (numpy array): Shape of array can be nSpikes x nSamples
        OR
        a nSpikes x nElectrodes x nSamples
    param (str): Valid values are:
        'Amp' - peak-to-trough amplitude (default)
        'P' - height of peak
        'T' - depth of trough
        'Vt' height at time t
        'tP' - time of peak (in seconds)
        'tT' - time of trough (in seconds)
        'PCA' - first n fet principal components (defaults to 1)
    t (int): The time used for Vt
    fet (int): The number of principal components
        (use with param 'PCA')</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_param</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s2">&quot;Amp&quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">fet</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the requested parameter from a spike train as a numpy array</span>

<span class="sd">    Args:</span>
<span class="sd">        waveforms (numpy array): Shape of array can be nSpikes x nSamples</span>
<span class="sd">            OR</span>
<span class="sd">            a nSpikes x nElectrodes x nSamples</span>
<span class="sd">        param (str): Valid values are:</span>
<span class="sd">            &#39;Amp&#39; - peak-to-trough amplitude (default)</span>
<span class="sd">            &#39;P&#39; - height of peak</span>
<span class="sd">            &#39;T&#39; - depth of trough</span>
<span class="sd">            &#39;Vt&#39; height at time t</span>
<span class="sd">            &#39;tP&#39; - time of peak (in seconds)</span>
<span class="sd">            &#39;tT&#39; - time of trough (in seconds)</span>
<span class="sd">            &#39;PCA&#39; - first n fet principal components (defaults to 1)</span>
<span class="sd">        t (int): The time used for Vt</span>
<span class="sd">        fet (int): The number of principal components</span>
<span class="sd">            (use with param &#39;PCA&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
    <span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

    <span class="k">if</span> <span class="n">param</span> <span class="o">==</span> <span class="s2">&quot;Amp&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">waveforms</span> <span class="o">+</span> <span class="mi">128</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s2">&quot;P&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s2">&quot;Vt&quot;</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">waveforms</span><span class="p">[:,</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
        <span class="k">elif</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">waveforms</span><span class="p">[:,</span> <span class="p">:,</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
    <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s2">&quot;tP&quot;</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s2">&quot;tT&quot;</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s2">&quot;PCA&quot;</span><span class="p">:</span>
        <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">fet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">fet</span><span class="p">))</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">fet</span><span class="p">,</span> <span class="n">fet</span><span class="p">)</span>
            <span class="n">en</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">fet</span><span class="p">,</span> <span class="n">fet</span> <span class="o">+</span> <span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">fet</span><span class="p">),</span> <span class="n">fet</span><span class="p">)</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">st</span><span class="p">,</span> <span class="n">en</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">waveforms</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:])):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                        <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">waveforms</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                            <span class="n">waveforms</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">out</span><span class="p">[:,</span> <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span><span class="p">[:,</span> <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>
            <span class="k">return</span> <span class="n">out</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.spikecalcs.mahal" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">mahal</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns the L-ratio and Isolation Distance measures calculated on the
principal components of the energy in a spike matrix.</p>
<p>Args:
    waveforms (np.ndarray, optional): The waveforms to be processed. If
        None, the function will return None.
    spike_clusters (np.ndarray, optional): The spike clusters to be
        processed.
    cluster_id (int, optional): The ID of the cluster to be processed.
    fet (int, default=1): The feature to be used in the PCA calculation.</p>
<p>Returns:
    tuple: A tuple containing the L-ratio and Isolation Distance of the
        cluster.</p>
<p>Raises:
    Exception: If an error occurs during the calculation of the L-ratio or
        Isolation Distance.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">mahal</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the L-ratio and Isolation Distance measures calculated on the</span>
<span class="sd">    principal components of the energy in a spike matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        waveforms (np.ndarray, optional): The waveforms to be processed. If</span>
<span class="sd">            None, the function will return None.</span>
<span class="sd">        spike_clusters (np.ndarray, optional): The spike clusters to be</span>
<span class="sd">            processed.</span>
<span class="sd">        cluster_id (int, optional): The ID of the cluster to be processed.</span>
<span class="sd">        fet (int, default=1): The feature to be used in the PCA calculation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the L-ratio and Isolation Distance of the</span>
<span class="sd">            cluster.</span>

<span class="sd">    Raises:</span>
<span class="sd">        Exception: If an error occurs during the calculation of the L-ratio or</span>
<span class="sd">            Isolation Distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u_sz</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">v_sz</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">u_sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v_sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Input size mismatch: </span><span class="se">\</span>
<span class="s2">                        matrices must have same num of columns&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">v_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v_sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Too few rows: v must have more rows than columns&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No complex inputs are allowed&quot;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="n">u_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="n">v_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">ri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ri</span> <span class="o">*</span> <span class="n">ri</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="n">v_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.spikecalcs.xcorr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">xcorr</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span> <span class="n">binsize</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculates the ISIs in x1 or x1 vs x2 within a given range</p>
<p>Args:
    x1, x2 (array_like): The times of the spikes emitted by the
                        cluster(s) in seconds
    Trange (array_like): Range of times to bin up in seconds
                            Defaults to [-0.5, +0.5]
    binsize (float): The size of the bins in seconds
    normed (bool): Whether to divide the counts by the total
                    number of spikes to give a probabilty
    **kwargs - just there to suck up spare parameters</p>
<p>Returns:
    BinnedData: A BinnedData object containing the binned data and the
                bin edges</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/spikecalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">xcorr</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">Trange</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span>
    <span class="n">binsize</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">normed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the ISIs in x1 or x1 vs x2 within a given range</span>

<span class="sd">    Args:</span>
<span class="sd">        x1, x2 (array_like): The times of the spikes emitted by the</span>
<span class="sd">                            cluster(s) in seconds</span>
<span class="sd">        Trange (array_like): Range of times to bin up in seconds</span>
<span class="sd">                                Defaults to [-0.5, +0.5]</span>
<span class="sd">        binsize (float): The size of the bins in seconds</span>
<span class="sd">        normed (bool): Whether to divide the counts by the total</span>
<span class="sd">                        number of spikes to give a probabilty</span>
<span class="sd">        **kwargs - just there to suck up spare parameters</span>

<span class="sd">    Returns:</span>
<span class="sd">        BinnedData: A BinnedData object containing the binned data and the</span>
<span class="sd">                    bin edges</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Trange</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">Trange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Trange</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">irange</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">Trange</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
        <span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">x1</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">counts</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
        <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">Trange</span><span class="p">)</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="n">Trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Trange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">normed</span><span class="p">:</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BinnedData</span><span class="p">(</span>
        <span class="n">variable</span><span class="o">=</span><span class="n">VariableToBin</span><span class="o">.</span><span class="n">TIME</span><span class="p">,</span>
        <span class="n">map_type</span><span class="o">=</span><span class="n">MapType</span><span class="o">.</span><span class="n">SPK</span><span class="p">,</span>
        <span class="n">binned_data</span><span class="o">=</span><span class="p">[</span><span class="n">counts</span><span class="p">],</span>
        <span class="n">bin_edges</span><span class="o">=</span><span class="p">[</span><span class="n">bins</span><span class="p">],</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="statistics">Statistics</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.common.statscalcs"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.statscalcs.V_test" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">V_test</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">test_direction</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>The Watson U2 tests whether the observed angles have a tendency to
cluster around a given angle indicating a lack of randomness in the
distribution. Also known as the modified Rayleigh test.</p>
<p>Args:
    angles (array_like): Vector of angular values in degrees.
    test_direction (int): A single angular value in degrees.</p>
<p>Notes:
    For grouped data the length of the mean vector must be adjusted,
    and for axial data all angles must be doubled.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/statscalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">V_test</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">test_direction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Watson U2 tests whether the observed angles have a tendency to</span>
<span class="sd">    cluster around a given angle indicating a lack of randomness in the</span>
<span class="sd">    distribution. Also known as the modified Rayleigh test.</span>

<span class="sd">    Args:</span>
<span class="sd">        angles (array_like): Vector of angular values in degrees.</span>
<span class="sd">        test_direction (int): A single angular value in degrees.</span>

<span class="sd">    Notes:</span>
<span class="sd">        For grouped data the length of the mean vector must be adjusted,</span>
<span class="sd">        and for axial data all angles must be doubled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">x_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angles</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">y_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angles</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x_hat</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y_hat</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">theta_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">y_hat</span> <span class="o">/</span> <span class="n">x_hat</span><span class="p">))</span>
    <span class="n">v_squiggle</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta_hat</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">test_direction</span><span class="p">))</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_squiggle</span>
    <span class="k">return</span> <span class="n">V</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.statscalcs.circ_r" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">circ_r</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Computes the mean resultant vector length for circular data.</p>
<p>Args:
    alpha (array or list): Sample of angles in radians.
    w (array or list): Counts in the case of binned data.
        Must be same length as alpha.
    d (array or list, optional): Spacing of bin centres for binned data; if
        supplied, correction factor is used to correct for bias in
        estimation of r, in radians.
    axis (int, optional): The dimension along which to compute.
        Default is 0.</p>
<p>Returns:
    r (float): The mean resultant vector length.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/statscalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">circ_r</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the mean resultant vector length for circular data.</span>

<span class="sd">    Args:</span>
<span class="sd">        alpha (array or list): Sample of angles in radians.</span>
<span class="sd">        w (array or list): Counts in the case of binned data.</span>
<span class="sd">            Must be same length as alpha.</span>
<span class="sd">        d (array or list, optional): Spacing of bin centres for binned data; if</span>
<span class="sd">            supplied, correction factor is used to correct for bias in</span>
<span class="sd">            estimation of r, in radians.</span>
<span class="sd">        axis (int, optional): The dimension along which to compute.</span>
<span class="sd">            Default is 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        r (float): The mean resultant vector length.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># TODO: error check for size constancy</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">d</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">r</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.statscalcs.duplicates_as_complex" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">duplicates_as_complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">already_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Finds duplicates in x</p>
<p>Args:
    x (array_like): The list to find duplicates in.
    already_sorted (bool, optional): Whether x is already sorted.
        Default False.</p>
<p>Returns:
    x (array_like): A complex array where the complex part is the count of
        the number of duplicates of the real value.</p>
<p>Examples:
    &gt;&gt;&gt;     x = [9.9, 9.9, 12.3, 15.2, 15.2, 15.2]
    &gt;&gt;&gt; ret = duplicates_as_complex(x)
    &gt;&gt;&gt;     print(ret)
    [9.9+0j, 9.9+1j,  12.3+0j, 15.2+0j, 15.2+1j, 15.2+2j]</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/statscalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">duplicates_as_complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">already_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds duplicates in x</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array_like): The list to find duplicates in.</span>
<span class="sd">        already_sorted (bool, optional): Whether x is already sorted.</span>
<span class="sd">            Default False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        x (array_like): A complex array where the complex part is the count of</span>
<span class="sd">            the number of duplicates of the real value.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt;	x = [9.9, 9.9, 12.3, 15.2, 15.2, 15.2]</span>
<span class="sd">        &gt;&gt;&gt; ret = duplicates_as_complex(x)</span>
<span class="sd">        &gt;&gt;&gt;	print(ret)</span>
<span class="sd">        [9.9+0j, 9.9+1j,  12.3+0j, 15.2+0j, 15.2+1j, 15.2+2j]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">already_sorted</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">is_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">is_start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">is_start</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">is_start</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">sub_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">is_start</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">labels</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">sub_idx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.statscalcs.mean_resultant_vector" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">mean_resultant_vector</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculate the mean resultant length and direction for angles.</p>
<p>Args:
    angles (np.array): Sample of angles in radians.</p>
<p>Returns:
    r (float): The mean resultant vector length.
    th (float): The mean resultant vector direction.</p>
<p>Notes:
Taken from Directional Statistics by Mardia &amp; Jupp, 2000</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/statscalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">mean_resultant_vector</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the mean resultant length and direction for angles.</span>

<span class="sd">    Args:</span>
<span class="sd">        angles (np.array): Sample of angles in radians.</span>

<span class="sd">    Returns:</span>
<span class="sd">        r (float): The mean resultant vector length.</span>
<span class="sd">        th (float): The mean resultant vector direction.</span>

<span class="sd">    Notes:</span>
<span class="sd">    Taken from Directional Statistics by Mardia &amp; Jupp, 2000</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">C</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">th</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">th</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.statscalcs.watsonWilliams" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">watsonWilliams</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>The Watson-Williams F test tests whether a set of mean directions are
equal given that the concentrations are unknown, but equal, given that
the groups each follow a von Mises distribution.</p>
<p>Args:
    a, b (array_like): The directional samples</p>
<p>Returns:
    F_stat (float): The F-statistic</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/statscalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">watsonWilliams</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Watson-Williams F test tests whether a set of mean directions are</span>
<span class="sd">    equal given that the concentrations are unknown, but equal, given that</span>
<span class="sd">    the groups each follow a von Mises distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        a, b (array_like): The directional samples</span>

<span class="sd">    Returns:</span>
<span class="sd">        F_stat (float): The F-statistic</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span>
    <span class="c1"># v_1 = 1 # needed to do p-value lookup in table of critical values</span>
    <span class="c1">#  of F distribution</span>
    <span class="c1"># v_2 = N - 2 # needed to do p-value lookup in table of critical values</span>
    <span class="c1"># of F distribution</span>
    <span class="n">C_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
    <span class="n">S_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
    <span class="n">C_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
    <span class="n">S_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">C_1</span> <span class="o">+</span> <span class="n">C_2</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S_1</span> <span class="o">+</span> <span class="n">S_2</span>
    <span class="n">R_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">C_1</span><span class="p">,</span> <span class="n">S_1</span><span class="p">)</span>
    <span class="n">R_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">C_2</span><span class="p">,</span> <span class="n">S_2</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
    <span class="n">R_hat</span> <span class="o">=</span> <span class="p">(</span><span class="n">R_1</span> <span class="o">+</span> <span class="n">R_2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">ephysiopy.common.mle_von_mises_vals</span> <span class="kn">import</span> <span class="n">vals</span>

    <span class="n">mle_von_mises</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
    <span class="n">mle_von_mises</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">mle_von_mises</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">k_hat</span> <span class="o">=</span> <span class="n">mle_von_mises</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mle_von_mises</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R_hat</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">k_hat</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">R_1</span> <span class="o">+</span> <span class="n">R_2</span> <span class="o">-</span> <span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">R_1</span> <span class="o">+</span> <span class="n">R_2</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">F</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.statscalcs.watsonsU2" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">watsonsU2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Tests whether two samples from circular observations differ significantly
from each other with regard to mean direction or angular variance.</p>
<p>Args:
    a, b (array_like): The two samples to be tested</p>
<p>Returns:
    U2 (float): The test statistic</p>
<p>Notes:
    Both samples must come from a continuous distribution. In the case of
    grouping the class interval should not exceed 5.
    Taken from '100 Statistical Tests' G.J.Kanji, 2006 Sage Publications</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/statscalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">watsonsU2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests whether two samples from circular observations differ significantly</span>
<span class="sd">    from each other with regard to mean direction or angular variance.</span>

<span class="sd">    Args:</span>
<span class="sd">        a, b (array_like): The two samples to be tested</span>

<span class="sd">    Returns:</span>
<span class="sd">        U2 (float): The test statistic</span>

<span class="sd">    Notes:</span>
<span class="sd">        Both samples must come from a continuous distribution. In the case of</span>
<span class="sd">        grouping the class interval should not exceed 5.</span>
<span class="sd">        Taken from &#39;100 Statistical Tests&#39; G.J.Kanji, 2006 Sage Publications</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="n">n_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_a</span> <span class="o">+</span> <span class="n">n_b</span><span class="p">)</span>
    <span class="n">a_complex</span> <span class="o">=</span> <span class="n">duplicates_as_complex</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">b_complex</span> <span class="o">=</span> <span class="n">duplicates_as_complex</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">a_and_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">a_complex</span><span class="p">,</span> <span class="n">b_complex</span><span class="p">)</span>

    <span class="c1"># get index for a</span>
    <span class="n">a_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_and_b</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">a_ind</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">a_and_b</span><span class="p">,</span> <span class="n">a_complex</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">a_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a_ind</span><span class="p">)</span>

    <span class="c1"># same for b</span>
    <span class="n">b_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_and_b</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">b_ind</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">a_and_b</span><span class="p">,</span> <span class="n">b_complex</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">b_ind</span><span class="p">)</span>

    <span class="n">d_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_ind</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_a</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">b_ind</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_b</span><span class="p">))</span>

    <span class="n">d_k_sq</span> <span class="o">=</span> <span class="n">d_k</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">U2</span> <span class="o">=</span> <span class="p">((</span><span class="n">n_a</span> <span class="o">*</span> <span class="n">n_b</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d_k_sq</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">U2</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.statscalcs.watsonsU2n" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">watsonsU2n</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Tests whether the given distribution fits a random sample of angular
values.</p>
<p>Args:
    angles (array_like): The angular samples.</p>
<p>Returns:
    U2n (float): The test statistic.</p>
<p>Notes:
    This test is suitable for both unimodal and the multimodal cases.
    It can be used as a test for randomness.
    Taken from '100 Statistical Tests' G.J.Kanji, 2006 Sage Publications.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/statscalcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">watsonsU2n</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests whether the given distribution fits a random sample of angular</span>
<span class="sd">    values.</span>

<span class="sd">    Args:</span>
<span class="sd">        angles (array_like): The angular samples.</span>

<span class="sd">    Returns:</span>
<span class="sd">        U2n (float): The test statistic.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This test is suitable for both unimodal and the multimodal cases.</span>
<span class="sd">        It can be used as a test for randomness.</span>
<span class="sd">        Taken from &#39;100 Statistical Tests&#39; G.J.Kanji, 2006 Sage Publications.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">Vi</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">360</span><span class="p">)</span>
    <span class="n">sum_Vi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Vi</span><span class="p">)</span>
    <span class="n">sum_sq_Vi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Vi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Ci</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">sum_Ci_Vi_ov_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Ci</span> <span class="o">*</span> <span class="n">Vi</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">V_bar</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">sum_Vi</span>
    <span class="n">U2n</span> <span class="o">=</span> <span class="n">sum_sq_Vi</span> <span class="o">-</span> <span class="n">sum_Ci_Vi_ov_n</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">V_bar</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">test_vals</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;0.1&quot;</span><span class="p">:</span> <span class="mf">0.152</span><span class="p">,</span>
        <span class="s2">&quot;0.05&quot;</span><span class="p">:</span> <span class="mf">0.187</span><span class="p">,</span>
        <span class="s2">&quot;0.025&quot;</span><span class="p">:</span> <span class="mf">0.221</span><span class="p">,</span>
        <span class="s2">&quot;0.01&quot;</span><span class="p">:</span> <span class="mf">0.267</span><span class="p">,</span>
        <span class="s2">&quot;0.005&quot;</span><span class="p">:</span> <span class="mf">0.302</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">test_vals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">U2n</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;The Watsons U2 statistic is </span><span class="si">{0}</span><span class="s2"> which is </span><span class="se">\</span>
<span class="s2">                greater than</span><span class="se">\n</span><span class="s2"> the critical value of </span><span class="si">{1}</span><span class="s2"> at p=</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">U2n</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">key</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;The Watsons U2 statistic is not </span><span class="se">\</span>
<span class="s2">                significant at p=</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">key</span>
                <span class="p">)</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">U2n</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="utility-functions">Utility functions</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.common.utils"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.common.utils.BinnedData" class="doc doc-heading">
            <code>BinnedData</code>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">







              <details class="quote">
                <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">BinnedData</span><span class="p">:</span>
    <span class="n">variable</span><span class="p">:</span> <span class="n">VariableToBin</span> <span class="o">=</span> <span class="n">VariableToBin</span><span class="o">.</span><span class="n">XY</span>
    <span class="n">map_type</span><span class="p">:</span> <span class="n">MapType</span> <span class="o">=</span> <span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span>
    <span class="n">binned_data</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">bin_edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="c1"># bin_units: int = 1</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span>

    <span class="k">def</span> <span class="nf">__assert_equal_bin_edges__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sbe</span> <span class="o">==</span> <span class="n">obe</span><span class="p">)</span> <span class="k">for</span> <span class="n">sbe</span><span class="p">,</span> <span class="n">obe</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)]</span>
        <span class="p">),</span> <span class="s2">&quot;Bin edges do not match&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BinnedData</span><span class="p">(</span>
            <span class="n">variable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
            <span class="n">map_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_type</span><span class="p">,</span>
            <span class="n">binned_data</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BinnedData</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__assert_equal_bin_edges__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">map_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">map_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">SPK</span><span class="o">.</span><span class="n">value</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">BinnedData</span><span class="p">(</span>
                            <span class="n">variable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                            <span class="n">map_type</span><span class="o">=</span><span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span><span class="p">,</span>
                            <span class="n">binned_data</span><span class="o">=</span><span class="p">[</span>
                                <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
                                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span>
                                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">binned_data</span>
                            <span class="p">],</span>
                            <span class="n">bin_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span>
                        <span class="p">)</span>

            <span class="k">return</span> <span class="n">BinnedData</span><span class="p">(</span>
                <span class="n">variable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                <span class="n">map_type</span><span class="o">=</span><span class="n">MapType</span><span class="o">.</span><span class="n">RATE</span><span class="p">,</span>
                <span class="n">binned_data</span><span class="o">=</span><span class="p">[</span>
                    <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="n">bin_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BinnedData</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__assert_equal_bin_edges__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BinnedData</span><span class="p">(</span>
                <span class="n">variable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                <span class="n">map_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_type</span><span class="p">,</span>
                <span class="n">binned_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">,</span>
                <span class="n">bin_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BinnedData</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__assert_equal_bin_edges__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sbd</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">obd</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">sbd</span><span class="p">,</span> <span class="n">obd</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sbd</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sbd</span><span class="p">)]</span> <span class="o">==</span> <span class="n">obd</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">obd</span><span class="p">)])</span>
                    <span class="k">for</span> <span class="n">sbd</span><span class="p">,</span> <span class="n">obd</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">set_nan_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BinnedData</span><span class="p">(</span>
            <span class="n">variable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
            <span class="n">map_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_type</span><span class="p">,</span>
            <span class="n">binned_data</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">],</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to correlate the binned data of this BinnedData</span>
<span class="sd">        instance with the binned data of another BinnedData instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (BinnedData): The other BinnedData instance to correlate with.</span>
<span class="sd">                If None, then correlations are performed between all the data held</span>
<span class="sd">                in the list self.binned_data</span>
<span class="sd">            as_matrix (bool): If True will return the full correlation matrix for</span>
<span class="sd">                all of the correlations in the list of data in self.binned_data. If</span>
<span class="sd">                False, a list of the unique correlations for the comparisons in</span>
<span class="sd">                self.binned_data are returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            BinnedData: A new BinnedData instance with the correlation of the</span>
<span class="sd">                binned data of this instance and the other instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BinnedData</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__assert_equal_bin_edges__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">[</span><span class="n">corr_maps</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">],</span>
                <span class="n">newshape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">[</span><span class="n">corr_maps</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">],</span>
                <span class="n">newshape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">as_matrix</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pick out the relevant diagonal</span>
            <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span>
                    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.common.utils.BinnedData.correlate" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">correlate</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>This method is used to correlate the binned data of this BinnedData
instance with the binned data of another BinnedData instance.</p>
<p>Args:
    other (BinnedData): The other BinnedData instance to correlate with.
        If None, then correlations are performed between all the data held
        in the list self.binned_data
    as_matrix (bool): If True will return the full correlation matrix for
        all of the correlations in the list of data in self.binned_data. If
        False, a list of the unique correlations for the comparisons in
        self.binned_data are returned.</p>
<p>Returns:
    BinnedData: A new BinnedData instance with the correlation of the
        binned data of this instance and the other instance.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method is used to correlate the binned data of this BinnedData</span>
<span class="sd">    instance with the binned data of another BinnedData instance.</span>

<span class="sd">    Args:</span>
<span class="sd">        other (BinnedData): The other BinnedData instance to correlate with.</span>
<span class="sd">            If None, then correlations are performed between all the data held</span>
<span class="sd">            in the list self.binned_data</span>
<span class="sd">        as_matrix (bool): If True will return the full correlation matrix for</span>
<span class="sd">            all of the correlations in the list of data in self.binned_data. If</span>
<span class="sd">            False, a list of the unique correlations for the comparisons in</span>
<span class="sd">            self.binned_data are returned.</span>

<span class="sd">    Returns:</span>
<span class="sd">        BinnedData: A new BinnedData instance with the correlation of the</span>
<span class="sd">            binned data of this instance and the other instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BinnedData</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__assert_equal_bin_edges__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">[</span><span class="n">corr_maps</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">],</span>
            <span class="n">newshape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)),</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">[</span><span class="n">corr_maps</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">],</span>
            <span class="n">newshape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)),</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">as_matrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># pick out the relevant diagonal</span>
        <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_data</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.applyFilter2Labels" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">applyFilter2Labels</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>M is a logical mask specifying which label numbers to keep
x is an array of positive integer labels</p>
<p>This method sets the undesired labels to 0 and renumbers the remaining
labels 1 to n when n is the number of trues in M</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">applyFilter2Labels</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    M is a logical mask specifying which label numbers to keep</span>
<span class="sd">    x is an array of positive integer labels</span>

<span class="sd">    This method sets the undesired labels to 0 and renumbers the remaining</span>
<span class="sd">    labels 1 to n when n is the number of trues in M</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newVals</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">newVals</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.blur_image" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">blur_image</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;boxcar&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Smooths a 2D image by convolving with a filter.</p>
<p>Args:
    im (BinnedData): Contains the array to smooth.
    n, ny (int): The size of the smoothing kernel.
    ftype (str): The type of smoothing kernel.
        Either 'boxcar' or 'gaussian'.</p>
<p>Returns:
    res (BinnedData): BinnedData instance with the smoothed data.</p>
<p>Notes:
    This essentially does the smoothing in-place</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">blur_image</span><span class="p">(</span>
    <span class="n">im</span><span class="p">:</span> <span class="n">BinnedData</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ny</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ftype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;boxcar&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinnedData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooths a 2D image by convolving with a filter.</span>

<span class="sd">    Args:</span>
<span class="sd">        im (BinnedData): Contains the array to smooth.</span>
<span class="sd">        n, ny (int): The size of the smoothing kernel.</span>
<span class="sd">        ftype (str): The type of smoothing kernel.</span>
<span class="sd">            Either &#39;boxcar&#39; or &#39;gaussian&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        res (BinnedData): BinnedData instance with the smoothed data.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This essentially does the smoothing in-place</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stddev</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;stddev&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;boundary&quot;</span><span class="p">,</span> <span class="s2">&quot;extend&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">ny</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ny</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ny</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">cnv</span><span class="o">.</span><span class="n">Box2DKernel</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;box&quot;</span> <span class="ow">in</span> <span class="n">ftype</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">cnv</span><span class="o">.</span><span class="n">Box1DKernel</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;gaussian&quot;</span> <span class="ow">in</span> <span class="n">ftype</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">cnv</span><span class="o">.</span><span class="n">Gaussian1DKernel</span><span class="p">(</span><span class="n">stddev</span><span class="p">,</span> <span class="n">x_size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">cnv</span><span class="o">.</span><span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">stddev</span><span class="p">,</span> <span class="n">x_size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">y_size</span><span class="o">=</span><span class="n">ny</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">binned_data</span><span class="p">):</span>
        <span class="n">im</span><span class="o">.</span><span class="n">binned_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnv</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">im</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.bwperim" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">bwperim</span><span class="p">(</span><span class="n">bw</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Finds the perimeter of objects in binary images.</p>
<p>A pixel is part of an object perimeter if its value is one and there
is at least one zero-valued pixel in its neighborhood.</p>
<p>By default the neighborhood of a pixel is 4 nearest pixels, but
if <code>n</code> is set to 8 the 8 nearest pixels will be considered.</p>
<p>Args:
    bw (array_like): A black-and-white image.
    n (int, optional): Connectivity. Must be 4 or 8. Default is 8.</p>
<p>Returns:
    perim (array_like): A boolean image.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">bwperim</span><span class="p">(</span><span class="n">bw</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the perimeter of objects in binary images.</span>

<span class="sd">    A pixel is part of an object perimeter if its value is one and there</span>
<span class="sd">    is at least one zero-valued pixel in its neighborhood.</span>

<span class="sd">    By default the neighborhood of a pixel is 4 nearest pixels, but</span>
<span class="sd">    if `n` is set to 8 the 8 nearest pixels will be considered.</span>

<span class="sd">    Args:</span>
<span class="sd">        bw (array_like): A black-and-white image.</span>
<span class="sd">        n (int, optional): Connectivity. Must be 4 or 8. Default is 8.</span>

<span class="sd">    Returns:</span>
<span class="sd">        perim (array_like): A boolean image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mahotas.bwperim: n must be 4 or 8&quot;</span><span class="p">)</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">bw</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Translate image by one pixel in all directions</span>
    <span class="n">north</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
    <span class="n">south</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
    <span class="n">west</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
    <span class="n">east</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>

    <span class="n">north</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">bw</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
    <span class="n">south</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">bw</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">west</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bw</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">east</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">bw</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">north</span> <span class="o">==</span> <span class="n">bw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">south</span> <span class="o">==</span> <span class="n">bw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">west</span> <span class="o">==</span> <span class="n">bw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">east</span> <span class="o">==</span> <span class="n">bw</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="n">north_east</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">north_west</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">south_east</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">south_west</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">north_east</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">bw</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">north_west</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bw</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">south_east</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">bw</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">south_west</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bw</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">idx</span> <span class="o">&amp;=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">north_east</span> <span class="o">==</span> <span class="n">bw</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">south_east</span> <span class="o">==</span> <span class="n">bw</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">south_west</span> <span class="o">==</span> <span class="n">bw</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">north_west</span> <span class="o">==</span> <span class="n">bw</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="o">~</span><span class="n">idx</span> <span class="o">*</span> <span class="n">bw</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.clean_kwargs" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">clean_kwargs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>This function is used to remove any keyword arguments that are not
accepted by the function. It is useful for passing keyword arguments
to other functions without having to worry about whether they are
accepted by the function or not.</p>
<p>Args:
    func (function): The function to check for keyword arguments.
    kwargs (dict): The keyword arguments to check.</p>
<p>Returns:
    dict: A dictionary containing only the keyword arguments that are
    accepted by the function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">clean_kwargs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is used to remove any keyword arguments that are not</span>
<span class="sd">    accepted by the function. It is useful for passing keyword arguments</span>
<span class="sd">    to other functions without having to worry about whether they are</span>
<span class="sd">    accepted by the function or not.</span>

<span class="sd">    Args:</span>
<span class="sd">        func (function): The function to check for keyword arguments.</span>
<span class="sd">        kwargs (dict): The keyword arguments to check.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary containing only the keyword arguments that are</span>
<span class="sd">        accepted by the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">valid_kwargs</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">kwonlyargs</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">valid_kwargs</span><span class="p">}</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.corr_maps" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">corr_maps</span><span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <span class="n">maptype</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>correlates two ratemaps together ignoring areas that have zero sampling</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">corr_maps</span><span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <span class="n">maptype</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    correlates two ratemaps together ignoring areas that have zero sampling</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">map1</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;</span> <span class="n">map2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">map2</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">map2</span><span class="p">,</span> <span class="n">map1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">map1</span><span class="o">.</span><span class="n">shape</span> <span class="o">&lt;</span> <span class="n">map2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">map1</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
    <span class="n">map1</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">map2</span> <span class="o">=</span> <span class="n">map2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">valid_map1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">map1</span><span class="p">)</span>
    <span class="n">valid_map2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">map2</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;normal&quot;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">((</span><span class="n">map1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">map1</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">valid_map1</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">((</span><span class="n">map2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">map2</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">valid_map2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;grid&quot;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">valid_map1</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">map2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">valid_map2</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">valid_map1</span><span class="p">,</span> <span class="n">valid_map2</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">map1</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">map2</span><span class="p">[</span><span class="n">valid</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.count_runs_and_unique_numbers" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">count_runs_and_unique_numbers</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Counts the number of continuous runs of numbers in a 1D numpy array
and returns the count of runs for each unique number and the unique
numbers.</p>
<p>Args:
    arr (np.ndarray): The input 1D numpy array of numbers.</p>
<p>Returns:
    tuple: A tuple containing a dictionary with the count of runs for
    each unique number and the set of unique numbers in the array.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">count_runs_and_unique_numbers</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts the number of continuous runs of numbers in a 1D numpy array</span>
<span class="sd">    and returns the count of runs for each unique number and the unique</span>
<span class="sd">    numbers.</span>

<span class="sd">    Args:</span>
<span class="sd">        arr (np.ndarray): The input 1D numpy array of numbers.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing a dictionary with the count of runs for</span>
<span class="sd">        each unique number and the set of unique numbers in the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{},</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">unique_numbers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">runs_count</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">unique_numbers</span><span class="p">:</span>
        <span class="n">runs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">arr</span> <span class="o">==</span> <span class="n">num</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="c1"># Add 1 because diff reduces the size by 1</span>
        <span class="n">runs_count</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">runs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">runs_count</span><span class="p">,</span> <span class="n">unique_numbers</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.count_to" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">count_to</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>This function is equivalent to hstack((arange(n_i) for n_i in n)).
It seems to be faster for some possible inputs and encapsulates
a task in a function.</p>
<p>Example:
    Given n = [0, 0, 3, 0, 0, 2, 0, 2, 1],
    the result would be [0, 1, 2, 0, 1, 0, 1, 0].</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">count_to</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is equivalent to hstack((arange(n_i) for n_i in n)).</span>
<span class="sd">    It seems to be faster for some possible inputs and encapsulates</span>
<span class="sd">    a task in a function.</span>

<span class="sd">    Example:</span>
<span class="sd">        Given n = [0, 0, 3, 0, 0, 2, 0, 2, 1],</span>
<span class="sd">        the result would be [0, 1, 2, 0, 1, 0, 1, 0].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;n is supposed to be 1d array.&quot;</span><span class="p">)</span>

    <span class="n">n_mask</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">n_cumsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_cumsum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ret</span><span class="p">[</span><span class="n">n_cumsum</span><span class="p">[</span><span class="n">n_mask</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">n</span><span class="p">[</span><span class="n">n_mask</span><span class="p">]</span>
    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ret</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.find_runs" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">find_runs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Find runs of consecutive items in an array.</p>
<p>Taken from:
https://gist.github.com/alimanfoo/c5977e87111abe8127453b21204c1065</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">find_runs</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find runs of consecutive items in an array.</span>

<span class="sd">    Taken from:</span>
<span class="sd">    https://gist.github.com/alimanfoo/c5977e87111abe8127453b21204c1065</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ensure array</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only 1D array supported&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># handle empty array</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># find run starts</span>
        <span class="n">loc_run_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">loc_run_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">out</span><span class="o">=</span><span class="n">loc_run_start</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">run_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">loc_run_start</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># find run values</span>
        <span class="n">run_values</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">loc_run_start</span><span class="p">]</span>

        <span class="c1"># find run lengths</span>
        <span class="n">run_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run_starts</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">run_values</span><span class="p">,</span> <span class="n">run_starts</span><span class="p">,</span> <span class="n">run_lengths</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.fixAngle" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">fixAngle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Ensure angles lie between -pi and pi
a must be in radians</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">fixAngle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensure angles lie between -pi and pi</span>
<span class="sd">    a must be in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">b</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.get_z_score" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_z_score</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculate the z-scores for array x based on the mean
and standard deviation in that sample, unless stated</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_z_score</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the z-scores for array x based on the mean</span>
<span class="sd">    and standard deviation in that sample, unless stated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mean</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">/</span> <span class="n">sd</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">sd</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.min_max_norm" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">min_max_norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Normalise the input array x to lie between min and max</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>x</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>min</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>max</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>axis</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>out (np.ndarray) - the normalised array</code>
            </td>
            <td>
              <div class="doc-md-description">
                
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">min_max_norm</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalise the input array x to lie between min and max</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x (np.ndarray) - the array to normalise</span>
<span class="sd">    min (float) - the minimun value in the returned array</span>
<span class="sd">    max (float) - the maximum value in the returned array</span>
<span class="sd">    axis - the axis along which to operate. Default 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out (np.ndarray) - the normalised array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">min</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.polar" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">polar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Converts from rectangular coordinates to polar ones.</p>
<p>Args:
    x, y (array_like, list_like): The x and y coordinates.
    deg (int): Radian if deg=0; degree if deg=1.</p>
<p>Returns:
    p (array_like): The polar version of x and y.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">polar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts from rectangular coordinates to polar ones.</span>

<span class="sd">    Args:</span>
<span class="sd">        x, y (array_like, list_like): The x and y coordinates.</span>
<span class="sd">        deg (int): Radian if deg=0; degree if deg=1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p (array_like): The polar version of x and y.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.rect" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">rect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert from polar (r,w) to rectangular (x,y)
x = r cos(w)
y = r sin(w)</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">rect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert from polar (r,w) to rectangular (x,y)</span>
<span class="sd">    x = r cos(w)</span>
<span class="sd">    y = r sin(w)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># radian if deg=0; degree if deg=1</span>
    <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">w</span> <span class="o">/</span> <span class="mf">180.0</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.remap_to_range" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">remap_to_range</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Remap the values of x to the range [new_min, new_max].</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">remap_to_range</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">new_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remap the values of x to the range [new_min, new_max].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">new_max</span> <span class="o">-</span> <span class="n">new_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">new_min</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">new_max</span> <span class="o">-</span> <span class="n">new_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">new_min</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.repeat_ind" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">repeat_ind</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Examples:
    &gt;&gt;&gt; n = [0, 0, 3, 0, 0, 2, 0, 2, 1]
    &gt;&gt;&gt; res = repeat_ind(n)
    &gt;&gt;&gt; res = [2, 2, 2, 5, 5, 7, 7, 8]</p>
<p>The input specifies how many times to repeat the given index.
It is equivalent to something like this:</p>
<pre><code>hstack((zeros(n_i,dtype=int)+i for i, n_i in enumerate(n)))
</code></pre>
<p>But this version seems to be faster, and probably scales better.
At any rate, it encapsulates a task in a function.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">repeat_ind</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; n = [0, 0, 3, 0, 0, 2, 0, 2, 1]</span>
<span class="sd">        &gt;&gt;&gt; res = repeat_ind(n)</span>
<span class="sd">        &gt;&gt;&gt; res = [2, 2, 2, 5, 5, 7, 7, 8]</span>

<span class="sd">    The input specifies how many times to repeat the given index.</span>
<span class="sd">    It is equivalent to something like this:</span>

<span class="sd">        hstack((zeros(n_i,dtype=int)+i for i, n_i in enumerate(n)))</span>

<span class="sd">    But this version seems to be faster, and probably scales better.</span>
<span class="sd">    At any rate, it encapsulates a task in a function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;n is supposed to be 1d array.&quot;</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.shift_vector" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">shift_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Shifts the elements of a vector by a given amount.
A bit like numpys roll function but when the shift goes
beyond some limit that limit is subtracted from the shift.
The result is then sorted and returned.</p>
<p>Args:
    v (array_like): The input vector.
    shift (int): The amount to shift the elements.
    fill_value (int): The value to fill the empty spaces.</p>
<p>Returns:
    array_like: The shifted vector.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">shift_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shifts the elements of a vector by a given amount.</span>
<span class="sd">    A bit like numpys roll function but when the shift goes</span>
<span class="sd">    beyond some limit that limit is subtracted from the shift.</span>
<span class="sd">    The result is then sorted and returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        v (array_like): The input vector.</span>
<span class="sd">        shift (int): The amount to shift the elements.</span>
<span class="sd">        fill_value (int): The value to fill the empty spaces.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array_like: The shifted vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">shift</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="k">if</span> <span class="n">maxlen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">shifted</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">shift</span>
        <span class="n">shifted</span><span class="p">[</span><span class="n">shifted</span> <span class="o">&gt;=</span> <span class="n">maxlen</span><span class="p">]</span> <span class="o">-=</span> <span class="n">maxlen</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">shifted</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.smooth" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">smooth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Smooth the data using a window with requested size.</p>
<p>This method is based on the convolution of a scaled window with the signal.
The signal is prepared by introducing reflected copies of the signal
(with the window size) in both ends so that transient parts are minimized
in the beginning and end part of the output signal.</p>
<p>Args:
    x (array_like): The input signal.
    window_len (int): The length of the smoothing window.
    window (str): The type of window from 'flat', 'hanning', 'hamming',
        'bartlett', 'blackman'. 'flat' window will produce a moving average
        smoothing.</p>
<p>Returns:
    out (array_like): The smoothed signal.</p>
<p>Example:
    &gt;&gt;&gt; t=linspace(-2,2,0.1)
    &gt;&gt;&gt; x=sin(t)+randn(len(t))*0.1
    &gt;&gt;&gt; y=smooth(x)</p>
<p>See Also:
    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman,
    numpy.convolve, scipy.signal.lfilter</p>
<p>Notes:
    The window parameter could be the window itself if an array instead of
    a string.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hanning&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth the data using a window with requested size.</span>

<span class="sd">    This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">    The signal is prepared by introducing reflected copies of the signal</span>
<span class="sd">    (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">    in the beginning and end part of the output signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array_like): The input signal.</span>
<span class="sd">        window_len (int): The length of the smoothing window.</span>
<span class="sd">        window (str): The type of window from &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;,</span>
<span class="sd">            &#39;bartlett&#39;, &#39;blackman&#39;. &#39;flat&#39; window will produce a moving average</span>
<span class="sd">            smoothing.</span>

<span class="sd">    Returns:</span>
<span class="sd">        out (array_like): The smoothed signal.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; t=linspace(-2,2,0.1)</span>
<span class="sd">        &gt;&gt;&gt; x=sin(t)+randn(len(t))*0.1</span>
<span class="sd">        &gt;&gt;&gt; y=smooth(x)</span>

<span class="sd">    See Also:</span>
<span class="sd">        numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman,</span>
<span class="sd">        numpy.convolve, scipy.signal.lfilter</span>

<span class="sd">    Notes:</span>
<span class="sd">        The window parameter could be the window itself if an array instead of</span>
<span class="sd">        a string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;smooth only accepts 1 dimension arrays.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">window_len</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;length of x: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;window_len: &quot;</span><span class="p">,</span> <span class="n">window_len</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input vector needs to be bigger than window size.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window_len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">window_len</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">window_len</span> <span class="o">=</span> <span class="n">window_len</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">window</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;flat&quot;</span><span class="p">,</span> <span class="s2">&quot;hanning&quot;</span><span class="p">,</span> <span class="s2">&quot;hamming&quot;</span><span class="p">,</span> <span class="s2">&quot;bartlett&quot;</span><span class="p">,</span> <span class="s2">&quot;blackman&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Window is on of &#39;flat&#39;, &#39;hanning&#39;, </span><span class="se">\</span>
<span class="s2">                &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s2">&quot;flat&quot;</span><span class="p">:</span>  <span class="c1"># moving average</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;np.&quot;</span> <span class="o">+</span> <span class="n">window</span> <span class="o">+</span> <span class="s2">&quot;(window_len)&quot;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">cnv</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">normalize_kernel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s2">&quot;extend&quot;</span><span class="p">)</span>
    <span class="c1"># return the smoothed signal</span>
    <span class="k">return</span> <span class="n">y</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ephysiopy.common.utils.window_rms" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">window_rms</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns the root mean square of the input a over a window of
size window_size</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/common/utils.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">window_rms</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the root mean square of the input a over a window of</span>
<span class="sd">    size window_size</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="s2">&quot;same&quot;</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="axona-input-output">Axona input/ output</h2>


<div class="doc doc-object doc-module">



<a id="ephysiopy.axona.axonaIO"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.axona.axonaIO.ClusterSession" class="doc doc-heading">
            <code>ClusterSession</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Loads all the cut file data and timestamps from the data
associated with the *.set filename given to <strong>init</strong></p>
<p>Meant to be a method-replica of the KiloSortSession class
but really both should inherit from the same meta-class</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">ClusterSession</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads all the cut file data and timestamps from the data</span>
<span class="sd">    associated with the *.set filename given to __init__</span>

<span class="sd">    Meant to be a method-replica of the KiloSortSession class</span>
<span class="sd">    but really both should inherit from the same meta-class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fname_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">fname_root</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">fname_root</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.set&quot;</span>
        <span class="k">assert</span> <span class="n">fname_root</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_root</span> <span class="o">=</span> <span class="n">fname_root</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">good_clusters</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname_root</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;^&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;_[1-9][0-9].cut&quot;</span>
        <span class="p">)</span>
        <span class="n">pattern1</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;^&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;_[1-9]$.cut&quot;</span>
        <span class="p">)</span>
        <span class="n">cut_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span>
                <span class="n">f</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">pname</span><span class="o">.</span><span class="n">iterdir</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="ow">or</span> <span class="n">pattern1</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># extract the clusters from each cut file</span>
        <span class="c1"># get the corresponding tetrode files</span>
        <span class="n">tet_files</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cut_files</span><span class="p">]</span>
        <span class="n">tet_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tet_files</span><span class="p">]</span>
        <span class="n">tetrode_clusters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">tet_files</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">IO</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="n">tetnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fname</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
            <span class="n">cut</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">getCut</span><span class="p">(</span><span class="n">tetnum</span><span class="p">)</span>
            <span class="n">tetrode_clusters</span><span class="p">[</span><span class="n">tetnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">cut</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">good_clusters</span> <span class="o">=</span> <span class="n">tetrode_clusters</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.axona.axonaIO.EEG" class="doc doc-heading">
            <code>EEG</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ephysiopy.axona.axonaIO.IO" href="#ephysiopy.axona.axonaIO.IO">IO</a></code></p>


        <p>Processes eeg data collected with the Axona recording system</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>filename_root</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The fully qualified filename without the suffix</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>egf</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to read the 'eeg' file or the 'egf' file. 0 is False, 1 is True</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>eeg_file</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If more than one eeg channel was recorded from then they are numbered
from 1 onwards i.e. trial.eeg, trial.eeg1, trial.eeg2 etc
This number specifies that</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">EEG</span><span class="p">(</span><span class="n">IO</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes eeg data collected with the Axona recording system</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    filename_root : str</span>
<span class="sd">        The fully qualified filename without the suffix</span>
<span class="sd">    egf: int</span>
<span class="sd">        Whether to read the &#39;eeg&#39; file or the &#39;egf&#39; file. 0 is False, 1 is True</span>
<span class="sd">    eeg_file: int</span>
<span class="sd">        If more than one eeg channel was recorded from then they are numbered</span>
<span class="sd">        from 1 onwards i.e. trial.eeg, trial.eeg1, trial.eeg2 etc</span>
<span class="sd">        This number specifies that</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">eeg_file</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">egf</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showfigs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">filename_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">=</span> <span class="n">filename_root</span>
        <span class="k">if</span> <span class="n">egf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eeg_file</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">eeg_suffix</span> <span class="o">=</span> <span class="s2">&quot;.eeg&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eeg_suffix</span> <span class="o">=</span> <span class="s2">&quot;.eeg&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">eeg_file</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">egf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eeg_file</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">eeg_suffix</span> <span class="o">=</span> <span class="s2">&quot;.egf&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eeg_suffix</span> <span class="o">=</span> <span class="s2">&quot;.egf&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">eeg_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="n">eeg_suffix</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="n">eeg_suffix</span><span class="p">))[</span><span class="s2">&quot;eeg&quot;</span><span class="p">]</span>
        <span class="c1"># sometimes the eeg record is longer than reported in</span>
        <span class="c1"># the &#39;num_EEG_samples&#39;</span>
        <span class="c1"># value of the header so eeg record should be truncated</span>
        <span class="c1"># to match &#39;num_EEG_samples&#39;</span>
        <span class="c1"># TODO: this could be taken care of in the IO base class</span>
        <span class="k">if</span> <span class="n">egf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eeg</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;num_EGF_samples&quot;</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eeg</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;num_EEG_samples&quot;</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;sample_rate&quot;</span><span class="p">))</span>
        <span class="n">set_header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.set&quot;</span><span class="p">))</span>
        <span class="n">eeg_ch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">set_header</span><span class="p">[</span><span class="s2">&quot;EEG_ch_1&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">eeg_gain</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">set_header</span><span class="p">[</span><span class="s2">&quot;gain_ch_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">eeg_ch</span><span class="p">)])</span>
        <span class="c1"># EEG polarity is determined by the &quot;mode_ch_n&quot; key in the setfile</span>
        <span class="c1"># where n is the channel # for the eeg. The possibles values to these</span>
        <span class="c1"># keys are as follows:</span>
        <span class="c1"># 0 = Signal</span>
        <span class="c1"># 1 = Ref</span>
        <span class="c1"># 2 = -Signal</span>
        <span class="c1"># 3 = -Ref</span>
        <span class="c1"># 4 = Sig-Ref</span>
        <span class="c1"># 5 = Ref-Sig</span>
        <span class="c1"># 6 = grounded</span>
        <span class="c1"># So if the EEG has been recorded with -Signal (2) then the recorded</span>
        <span class="c1"># polarity is inverted with respect to that in the brain</span>
        <span class="n">eeg_mode</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">set_header</span><span class="p">[</span><span class="s2">&quot;mode_ch_&quot;</span> <span class="o">+</span> <span class="n">set_header</span><span class="p">[</span><span class="s2">&quot;EEG_ch_1&quot;</span><span class="p">]])</span>
        <span class="n">polarity</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># ensure it always has a value</span>
        <span class="k">if</span> <span class="n">eeg_mode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">polarity</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">ADC_mv</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">set_header</span><span class="p">[</span><span class="s2">&quot;ADC_fullscale_mv&quot;</span><span class="p">])</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADC_mv</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">eeg_gain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span> <span class="o">=</span> <span class="n">scaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain</span> <span class="o">=</span> <span class="n">eeg_gain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polarity</span> <span class="o">=</span> <span class="n">polarity</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mf">128.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eeg</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span> <span class="o">*</span> <span class="n">scaling</span> <span class="o">*</span> <span class="n">polarity</span>  <span class="c1"># eeg in microvolts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EEGphase</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># x1 / x2 are the lower and upper limits of the eeg filter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="mi">12</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.axona.axonaIO.IO" class="doc doc-heading">
            <code>IO</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Axona data I/O. Also reads .clu files generated from KlustaKwik</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>filename_root</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The fully-qualified filename</p>
              </div>
            </td>
            <td>
                  <code>&#39;&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">IO</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Axona data I/O. Also reads .clu files generated from KlustaKwik</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename_root : str</span>
<span class="sd">        The fully-qualified filename</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tetrode_files</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">)],</span>
        <span class="c1"># ts is a big-endian 32-bit integer</span>
        <span class="c1"># waveform is 50 signed 8-bit ints (a signed byte)</span>
        <span class="p">[(</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;i&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;waveform&quot;</span><span class="p">,</span> <span class="s2">&quot;50b&quot;</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="n">other_files</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;.pos&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;i&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pos&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;8h&quot;</span><span class="p">)],</span>
        <span class="s2">&quot;.eeg&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;eeg&quot;</span><span class="p">,</span> <span class="s2">&quot;=b&quot;</span><span class="p">)],</span>
        <span class="s2">&quot;.eeg2&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;eeg&quot;</span><span class="p">,</span> <span class="s2">&quot;=b&quot;</span><span class="p">)],</span>
        <span class="s2">&quot;.egf&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;eeg&quot;</span><span class="p">,</span> <span class="s2">&quot;int16&quot;</span><span class="p">)],</span>
        <span class="s2">&quot;.egf2&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;eeg&quot;</span><span class="p">,</span> <span class="s2">&quot;int16&quot;</span><span class="p">)],</span>
        <span class="s2">&quot;.inp&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;i4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;b&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;2b&quot;</span><span class="p">)],</span>
        <span class="s2">&quot;.log&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;state&quot;</span><span class="p">,</span> <span class="s2">&quot;S3&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;i&quot;</span><span class="p">)],</span>
        <span class="s2">&quot;.stm&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;i&quot;</span><span class="p">)],</span>
    <span class="p">}</span>

    <span class="c1"># this only works in &gt;= Python3.5</span>
    <span class="n">axona_files</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">other_files</span><span class="p">,</span> <span class="o">**</span><span class="n">tetrode_files</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">=</span> <span class="n">filename_root</span>

    <span class="k">def</span> <span class="nf">getData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the data part of an Axona data file i.e. from &quot;data_start&quot; to</span>
<span class="sd">        &quot;data_end&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename_root:  str</span>
<span class="sd">            Fully qualified path name to the data file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : ndarray</span>
<span class="sd">            The data part of whatever file was fed in</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_samps</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">fType</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axona_files</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fType</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;num_*_samples&quot;</span><span class="p">):</span>
                        <span class="n">n_samps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;num_spikes&quot;</span><span class="p">):</span>
                        <span class="n">n_samps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">*</span> <span class="mi">4</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_files</span><span class="p">[</span><span class="n">fType</span><span class="p">])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">n_samps</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;File not in list of recognised Axona files&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">getCluCut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tet</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a clu file and return as an array of integers</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tet : int</span>
<span class="sd">            The tetrode the clu file relates to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : ndarray</span>
<span class="sd">            Data read from the clu file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="s2">&quot;clu.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tet</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename_root</span><span class="p">):</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;i&quot;</span><span class="p">)])</span>
            <span class="n">clu_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">clu_data</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">::]</span>  <span class="c1"># first entry is num of clusters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getCut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tet</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cut file as a list of integers</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tet : int</span>
<span class="sd">            The tetrode the cut file relates to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : ndarray</span>
<span class="sd">            The data read from the cut file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">filename_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tet</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.cut&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename_root</span><span class="p">):</span>
            <span class="n">cut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCluCut</span><span class="p">(</span><span class="n">tet</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cut</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># clusters 1 indexed in clu</span>
            <span class="k">return</span> <span class="n">cut</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">cut_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;spikes: &quot;</span><span class="p">)</span>
        <span class="n">tmp1</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">cut</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">setHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="n">dataclass</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes out the header to the specified file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        filename_root : str</span>
<span class="sd">            A fully qualified path to a file with the relevant suffix at</span>
<span class="sd">            the end (e.g. &quot;.set&quot;, &quot;.pos&quot; or whatever)</span>

<span class="sd">        header : dataclass</span>
<span class="sd">            See ephysiopy.axona.file_headers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="n">header</span><span class="o">.</span><span class="n">print</span><span class="p">()</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;data_end&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setCut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">cut_header</span><span class="p">:</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">cut_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="n">fpath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span>
        <span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cut_data</span><span class="p">))</span>
        <span class="n">cluster_entries</span> <span class="o">=</span> <span class="n">make_cluster_cut_entries</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="n">cut_header</span><span class="o">.</span><span class="n">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">cluster_entries</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exact_cut_for: </span><span class="si">{</span><span class="n">fpath</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">    spikes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cut_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes Axona format data to the given filename</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename_root : str</span>
<span class="sd">            The fully qualified filename including the suffix</span>

<span class="sd">        data : ndarray</span>
<span class="sd">            The data that will be saved</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fType</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axona_files</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;rb+&quot;</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;data_end&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads and returns the header of a specified data file as a dictionary</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename_root : str</span>
<span class="sd">            Fully qualified filename of Axona type</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        headerDict : dict</span>
<span class="sd">            key - value pairs of the header part of an Axona type file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;.set&quot;</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">st</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">headerDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ISO-8859-1&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">headerDict</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">headerDict</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="n">headerDict</span>

    <span class="k">def</span> <span class="nf">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a value from the header as an int</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        header : dict</span>
<span class="sd">            The header dictionary to read</span>
<span class="sd">        key : str</span>
<span class="sd">            The key to look up</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : int</span>
<span class="sd">            The value of `key` as an int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">val</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.IO.getCluCut" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getCluCut</span><span class="p">(</span><span class="n">tet</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Load a clu file and return as an array of integers</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>tet</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The tetrode the clu file relates to</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>out</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Data read from the clu file</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getCluCut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tet</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a clu file and return as an array of integers</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tet : int</span>
<span class="sd">        The tetrode the clu file relates to</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Data read from the clu file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filename_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="s2">&quot;clu.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tet</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename_root</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;i&quot;</span><span class="p">)])</span>
        <span class="n">clu_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clu_data</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">::]</span>  <span class="c1"># first entry is num of clusters</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.IO.getCut" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getCut</span><span class="p">(</span><span class="n">tet</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the cut file as a list of integers</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>tet</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The tetrode the cut file relates to</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>out</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The data read from the cut file</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getCut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tet</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the cut file as a list of integers</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tet : int</span>
<span class="sd">        The tetrode the cut file relates to</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The data read from the cut file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">filename_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tet</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.cut&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename_root</span><span class="p">):</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCluCut</span><span class="p">(</span><span class="n">tet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cut</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># clusters 1 indexed in clu</span>
        <span class="k">return</span> <span class="n">cut</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">cut_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;spikes: &quot;</span><span class="p">)</span>
    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">cut</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">a</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.IO.getData" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getData</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the data part of an Axona data file i.e. from "data_start" to
"data_end"</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>filename_root</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Fully qualified path name to the data file</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>output</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The data part of whatever file was fed in</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the data part of an Axona data file i.e. from &quot;data_start&quot; to</span>
<span class="sd">    &quot;data_end&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename_root:  str</span>
<span class="sd">        Fully qualified path name to the data file</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        The data part of whatever file was fed in</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_samps</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">fType</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axona_files</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fType</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;num_*_samples&quot;</span><span class="p">):</span>
                    <span class="n">n_samps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;num_spikes&quot;</span><span class="p">):</span>
                    <span class="n">n_samps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">*</span> <span class="mi">4</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_files</span><span class="p">[</span><span class="n">fType</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">n_samps</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;File not in list of recognised Axona files&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.IO.getHeader" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getHeader</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Reads and returns the header of a specified data file as a dictionary</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>filename_root</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Fully qualified filename of Axona type</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>headerDict</code></td>            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>key - value pairs of the header part of an Axona type file</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads and returns the header of a specified data file as a dictionary</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename_root : str</span>
<span class="sd">        Fully qualified filename of Axona type</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    headerDict : dict</span>
<span class="sd">        key - value pairs of the header part of an Axona type file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;.set&quot;</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">st</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">headerDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ISO-8859-1&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">headerDict</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">headerDict</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">return</span> <span class="n">headerDict</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.IO.getHeaderVal" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getHeaderVal</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get a value from the header as an int</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>header</code>
            </td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The header dictionary to read</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>key</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The key to look up</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>value</code></td>            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The value of <code>key</code> as an int</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a value from the header as an int</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    header : dict</span>
<span class="sd">        The header dictionary to read</span>
<span class="sd">    key : str</span>
<span class="sd">        The key to look up</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    value : int</span>
<span class="sd">        The value of `key` as an int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">val</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.IO.setData" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">setData</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Writes Axona format data to the given filename</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>filename_root</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The fully qualified filename including the suffix</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>data</code>
            </td>
            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The data that will be saved</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">setData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes Axona format data to the given filename</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename_root : str</span>
<span class="sd">        The fully qualified filename including the suffix</span>

<span class="sd">    data : ndarray</span>
<span class="sd">        The data that will be saved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fType</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axona_files</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;rb+&quot;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;data_end&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.IO.setHeader" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">setHeader</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Writes out the header to the specified file</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>filename_root</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A fully qualified path to a file with the relevant suffix at
the end (e.g. ".set", ".pos" or whatever)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>header</code>
            </td>
            <td>
                  <code><span title="dataclasses.dataclass">dataclass</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>See ephysiopy.axona.file_headers</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">setHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="n">dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes out the header to the specified file</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    filename_root : str</span>
<span class="sd">        A fully qualified path to a file with the relevant suffix at</span>
<span class="sd">        the end (e.g. &quot;.set&quot;, &quot;.pos&quot; or whatever)</span>

<span class="sd">    header : dataclass</span>
<span class="sd">        See ephysiopy.axona.file_headers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">header</span><span class="o">.</span><span class="n">print</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;data_start&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;data_end&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.axona.axonaIO.Pos" class="doc doc-heading">
            <code>Pos</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ephysiopy.axona.axonaIO.IO" href="#ephysiopy.axona.axonaIO.IO">IO</a></code></p>


        <p>Processs position data recorded with the Axona recording system</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>filename_root</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The basename of the file i.e mytrial as opposed to mytrial.pos</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Notes</summary>
  <p>Currently the only arg that does anything is 'cm' which will convert
the xy data to cm, assuming that the pixels per metre value has been
set correctly</p>
</details>





              <details class="quote">
                <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Pos</span><span class="p">(</span><span class="n">IO</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processs position data recorded with the Axona recording system</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename_root : str</span>
<span class="sd">        The basename of the file i.e mytrial as opposed to mytrial.pos</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Currently the only arg that does anything is &#39;cm&#39; which will convert</span>
<span class="sd">    the xy data to cm, assuming that the pixels per metre value has been</span>
<span class="sd">    set correctly</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">filename_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename_root</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.set&quot;</span><span class="p">:</span>
            <span class="n">filename_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">=</span> <span class="n">filename_root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.pos&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setheader</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setheader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.set&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posProcessed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">posData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.pos&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nLEDs</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">setheader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nLEDs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">,</span> <span class="s2">&quot;colactive_1&quot;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">,</span> <span class="s2">&quot;colactive_2&quot;</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nLEDs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">led_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">posData</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">led_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">([</span><span class="n">posData</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">][:,</span> <span class="mi">4</span><span class="p">]])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nLEDs</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">led_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">posData</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">led_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">posData</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">][:,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">led_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">led_pos</span><span class="p">,</span> <span class="mi">1023</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">led_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">led_pix</span><span class="p">,</span> <span class="mi">1023</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">posData</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">led_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npos</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">npos</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir_disp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">npos</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">npos</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;sample_rate&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;cm&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;cm&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ppm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ppm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;pixels_per_metre&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppm</span>

    <span class="nd">@ppm</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ppm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppm</span> <span class="o">=</span> <span class="n">value</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.axona.axonaIO.Stim" class="doc doc-heading">
            <code>Stim</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="dict">dict</span></code>, <code><a class="autorefs autorefs-internal" title="ephysiopy.axona.axonaIO.IO" href="#ephysiopy.axona.axonaIO.IO">IO</a></code></p>


        <p>Processes the stimulation data recorded using Axona</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>filename_root</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The fully qualified filename without the suffix</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Stim</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">IO</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes the stimulation data recorded using Axona</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename_root : str</span>
<span class="sd">        The fully qualified filename without the suffix</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">filename_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">=</span> <span class="n">filename_root</span>
        <span class="n">stmData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.stm&quot;</span><span class="p">))</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">stmData</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">]</span>
        <span class="n">stmHdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.stm&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">stmHdr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">tb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;timebase&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timebase</span> <span class="o">=</span> <span class="n">tb</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span> <span class="o">/</span> <span class="n">tb</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="s2">&quot;ttl_timestamps&quot;</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>  <span class="c1"># in SECONDS</span>
        <span class="c1"># the &#39;duration&#39; value in the header of the .stm file</span>
        <span class="c1"># is not correct so we need to read this from the .set</span>
        <span class="c1"># file and update</span>
        <span class="n">setHdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.set&quot;</span><span class="p">))</span>
        <span class="n">stim_duration</span> <span class="o">=</span> <span class="p">[</span><span class="n">setHdr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">setHdr</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;stim_pwidth&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stim_duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stim_duration</span><span class="p">)</span>
        <span class="n">stim_duration</span> <span class="o">=</span> <span class="n">stim_duration</span>  <span class="c1"># in seconds</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="s2">&quot;stim_duration&quot;</span><span class="p">,</span> <span class="n">stim_duration</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="nb">dict</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ephysiopy.axona.axonaIO.Tetrode" class="doc doc-heading">
            <code>Tetrode</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ephysiopy.axona.axonaIO.IO" href="#ephysiopy.axona.axonaIO.IO">IO</a></code></p>


        <p>Processes tetrode files recorded with the Axona recording system</p>
<p>Mostly this class deals with interpolating tetrode and position timestamps
and getting indices for particular clusters.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>filename_root</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The fully qualified name of the file without it's suffix</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tetrode</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of the tetrode</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>volts</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to convert the data values volts. Default True</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Tetrode</span><span class="p">(</span><span class="n">IO</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes tetrode files recorded with the Axona recording system</span>

<span class="sd">    Mostly this class deals with interpolating tetrode and position timestamps</span>
<span class="sd">    and getting indices for particular clusters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    filename_root : str</span>
<span class="sd">        The fully qualified name of the file without it&#39;s suffix</span>
<span class="sd">    tetrode : int</span>
<span class="sd">        The number of the tetrode</span>
<span class="sd">    volts : bool, optional</span>
<span class="sd">        Whether to convert the data values volts. Default True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">volts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">filename_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename_root</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.set&quot;</span><span class="p">:</span>
            <span class="n">filename_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">=</span> <span class="n">filename_root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tetrode</span> <span class="o">=</span> <span class="n">tetrode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volts</span> <span class="o">=</span> <span class="n">volts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tetrode</span><span class="p">)))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tetrode</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">][::</span><span class="mi">4</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nChans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;num_chans&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;samples_per_spike&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nSpikes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;num_spikes&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;duration&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posSampleRate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.pos&quot;</span><span class="p">)),</span> <span class="s2">&quot;sample_rate&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;waveform&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSpikes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">del</span> <span class="n">data</span>
        <span class="k">if</span> <span class="n">volts</span><span class="p">:</span>
            <span class="n">set_header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.set&quot;</span><span class="p">))</span>
            <span class="n">gains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="p">(</span><span class="n">tetrode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)):</span>
                <span class="n">gains</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">set_header</span><span class="p">[</span><span class="s2">&quot;gain_ch_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">)])</span>
            <span class="n">ADC_mv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">set_header</span><span class="p">[</span><span class="s2">&quot;ADC_fullscale_mv&quot;</span><span class="p">])</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADC_mv</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">gains</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span> <span class="o">=</span> <span class="n">scaling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="n">gains</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span> <span class="o">/</span> <span class="mf">128.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">scaling</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timebase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;timebase&quot;</span><span class="p">)</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCut</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetrode</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getSpkTS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all the timestamps for all the spikes on the tetrode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getClustTS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the timestamps for a cluster on the tetrode</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster : int</span>
<span class="sd">            The cluster whose timestamps we want</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clustTS : ndarray</span>
<span class="sd">            The timestamps</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If None is supplied as input then all timestamps for all clusters</span>
<span class="sd">        is returned i.e. getSpkTS() is called</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clustTS</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">cluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clustTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSpkTS</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCut</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetrode</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clustTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]</span>
                <span class="c1"># clustTS = np.ma.compressed(self.spike_times[self.cut == cluster])</span>
        <span class="k">return</span> <span class="n">clustTS</span>

    <span class="k">def</span> <span class="nf">getPosSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the pos samples at which the spikes were captured</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getSpkTS</span><span class="p">()</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timebase</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">posSampleRate</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_samples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getClustSpks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the waveforms of `cluster`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster : int</span>
<span class="sd">            The cluster whose waveforms we want</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        waveforms : ndarray</span>
<span class="sd">            The waveforms on all 4 electrodes of the tgtrode so the shape of</span>
<span class="sd">            the returned array is [nClusterSpikes, 4, 50]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">getClustIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the indices of the position samples corresponding to the cluster</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster : int</span>
<span class="sd">            The cluster whose position indices we want</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pos_samples : ndarray</span>
<span class="sd">            The indices of the position samples, dtype is int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCut</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetrode</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getPosSamples</span><span class="p">()</span>  <span class="c1"># sets self.pos_samples</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getUniqueClusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the unique clusters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCut</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetrode</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a mask to the data</span>

<span class="sd">        Args:</span>
<span class="sd">            mask (np.ndarray): The mask to be applied. For use with</span>
<span class="sd">                               np.ma.MaskedArray&#39;s mask attribute</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        Note:</span>
<span class="sd">        The times inside the bounds are masked ie the mask is set to True</span>
<span class="sd">        The mask can be a list of tuples, in which case the mask is applied</span>
<span class="sd">        for each tuple in the list.</span>
<span class="sd">        mask can be an empty tuple, in which case the mask is removed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">sample_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sample_rate&quot;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
            <span class="n">timebase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;timebase&quot;</span><span class="p">)</span>
            <span class="n">spike_pos_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">timebase</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
            <span class="p">)</span>
            <span class="n">pos_times_in_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">spike_pos_samples</span><span class="p">,</span> <span class="n">pos_times_in_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">data</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.Tetrode.apply_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply a mask to the data</p>
<p>Args:
    mask (np.ndarray): The mask to be applied. For use with
                       np.ma.MaskedArray's mask attribute</p>
<p>Returns:
    None</p>
<p>Note:
The times inside the bounds are masked ie the mask is set to True
The mask can be a list of tuples, in which case the mask is applied
for each tuple in the list.
mask can be an empty tuple, in which case the mask is removed</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a mask to the data</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (np.ndarray): The mask to be applied. For use with</span>
<span class="sd">                           np.ma.MaskedArray&#39;s mask attribute</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>

<span class="sd">    Note:</span>
<span class="sd">    The times inside the bounds are masked ie the mask is set to True</span>
<span class="sd">    The mask can be a list of tuples, in which case the mask is applied</span>
<span class="sd">    for each tuple in the list.</span>
<span class="sd">    mask can be an empty tuple, in which case the mask is removed</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
        <span class="n">sample_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sample_rate&quot;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">timebase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;timebase&quot;</span><span class="p">)</span>
        <span class="n">spike_pos_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">timebase</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>
        <span class="n">pos_times_in_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">spike_pos_samples</span><span class="p">,</span> <span class="n">pos_times_in_samples</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">data</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">data</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">data</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.Tetrode.getClustIdx" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getClustIdx</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the indices of the position samples corresponding to the cluster</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The cluster whose position indices we want</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>pos_samples</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The indices of the position samples, dtype is int</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getClustIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the indices of the position samples corresponding to the cluster</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster : int</span>
<span class="sd">        The cluster whose position indices we want</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pos_samples : ndarray</span>
<span class="sd">        The indices of the position samples, dtype is int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCut</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetrode</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getPosSamples</span><span class="p">()</span>  <span class="c1"># sets self.pos_samples</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.Tetrode.getClustSpks" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getClustSpks</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the waveforms of <code>cluster</code></p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The cluster whose waveforms we want</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>waveforms</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The waveforms on all 4 electrodes of the tgtrode so the shape of
the returned array is [nClusterSpikes, 4, 50]</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getClustSpks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the waveforms of `cluster`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster : int</span>
<span class="sd">        The cluster whose waveforms we want</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    waveforms : ndarray</span>
<span class="sd">        The waveforms on all 4 electrodes of the tgtrode so the shape of</span>
<span class="sd">        the returned array is [nClusterSpikes, 4, 50]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.Tetrode.getClustTS" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the timestamps for a cluster on the tetrode</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cluster</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The cluster whose timestamps we want</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>clustTS</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The timestamps</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Notes</summary>
  <p>If None is supplied as input then all timestamps for all clusters
is returned i.e. getSpkTS() is called</p>
</details>
            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getClustTS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the timestamps for a cluster on the tetrode</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster : int</span>
<span class="sd">        The cluster whose timestamps we want</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    clustTS : ndarray</span>
<span class="sd">        The timestamps</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If None is supplied as input then all timestamps for all clusters</span>
<span class="sd">    is returned i.e. getSpkTS() is called</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">clustTS</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">cluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clustTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSpkTS</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCut</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetrode</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clustTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]</span>
            <span class="c1"># clustTS = np.ma.compressed(self.spike_times[self.cut == cluster])</span>
    <span class="k">return</span> <span class="n">clustTS</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.Tetrode.getPosSamples" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getPosSamples</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the pos samples at which the spikes were captured</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getPosSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the pos samples at which the spikes were captured</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pos_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getSpkTS</span><span class="p">()</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timebase</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">posSampleRate</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_samples</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.Tetrode.getSpkTS" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getSpkTS</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Return all the timestamps for all the spikes on the tetrode</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getSpkTS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return all the timestamps for all the spikes on the tetrode</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.axona.axonaIO.Tetrode.getUniqueClusters" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getUniqueClusters</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the unique clusters</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/axona/axonaIO.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getUniqueClusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the unique clusters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCut</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetrode</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h2 id="conversion-code">Conversion code</h2>
<h3 id="openephys-to-axona">OpenEphys to Axona</h3>


<div class="doc doc-object doc-module">



<a id="ephysiopy.format_converters.OE_Axona"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.format_converters.OE_Axona.OE2Axona" class="doc doc-heading">
            <code>OE2Axona</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Converts openephys data into Axona files</p>
<p>Example workflow:</p>
<p>You have recorded some openephys data using the binary
format leading to a directory structure something like this:</p>
<p>M4643_2023-07-21_11-52-02
 Record Node 101
  experiment1
   recording1
       continuous
        Acquisition_Board-100.Rhythm Data
            amplitudes.npy
            channel_map.npy
            channel_positions.npy
            cluster_Amplitude.tsv
            cluster_ContamPct.tsv
            cluster_KSLabel.tsv
            continuous.dat
            params.py
            pc_feature_ind.npy
            pc_features.npy
            phy.log
            rez.mat
            similar_templates.npy
            spike_clusters.npy
            spike_templates.npy
            spike_times.npy
            template_feature_ind.npy
            template_features.npy
            templates_ind.npy
            templates.npy
            whitening_mat_inv.npy
            whitening_mat.npy
       events
        Acquisition_Board-100.Rhythm Data
         TTL
             full_words.npy
             sample_numbers.npy
             states.npy
             timestamps.npy
        MessageCenter
            sample_numbers.npy
            text.npy
            timestamps.npy
       structure.oebin
       sync_messages.txt
  settings.xml
 Record Node 104
     experiment1
      recording1
          continuous
           TrackMe-103.TrackingNode
               continuous.dat
               sample_numbers.npy
               timestamps.npy
          events
           MessageCenter
            sample_numbers.npy
            text.npy
            timestamps.npy
           TrackMe-103.TrackingNode
               TTL
                   full_words.npy
                   sample_numbers.npy
                   states.npy
                   timestamps.npy
          structure.oebin
          sync_messages.txt
     settings.xml</p>
<p>The binary data file is called "continuous.dat" in the
continuous/Acquisition_Board-100.Rhythm Data folder. There
is also a collection of files resulting from a KiloSort session
in that directory.</p>
<p>Run the conversion code like so:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from ephysiopy.format_converters.OE_Axona import OE2Axona
from pathlib import Path
nChannels = 64
apData = Path("M4643_2023-07-21_11-52-02/Record Node 101/experiment1/recording1/continuous/Acquisition_Board-100.Rhythm Data")
OE = OE2Axona(Path("M4643_2023-07-21_11-52-02"), path2APData=apData, channels=nChannels)
OE.getOEData()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The last command will attempt to load position data and also load up
something called a TemplateModel (from the package phylib) which
should grab a handle to the neural data. If that doesn't throw
out errors then try:</p>
<blockquote>
<blockquote>
<blockquote>
<p>OE.exportPos()</p>
</blockquote>
</blockquote>
</blockquote>
<p>There are a few arguments you can provide the exportPos() function - see
the docstring for it below. Basically, it calls a function called
convertPosData(xy, xyts) where xy is the xy data with shape nsamples x 2
and xyts is a vector of timestamps. So if the call to exportPos() fails, you
could try calling convertPosData() directly which returns axona formatted
position data. If the variable returned from convertPosData() is called axona_pos_data
then you can call the function:</p>
<p>writePos2AxonaFormat(pos_header, axona_pos_data)</p>
<p>Providing the pos_header to it - see the last half of the exportPos function
for how to create and modify the pos_header as that will need to have
user-specific information added to it.</p>
<blockquote>
<blockquote>
<blockquote>
<p>OE.convertTemplateDataToAxonaTetrode()</p>
</blockquote>
</blockquote>
</blockquote>
<p>This is the main function for creating the tetrode files. It has an optional
argument called max_n_waves which is used to limit the maximum number of spikes
that make up a cluster. This defaults to 2000 which means that if a cluster has
12000 spikes, it will have 2000 spikes randomly drawn from those 12000 (without
replacement), that will then be saved to a tetrode file. This is mostly a time-saving
device as if you have 250 clusters and many consist of 10,000's of spikes,
processing that data will take a long time.</p>
<blockquote>
<blockquote>
<blockquote>
<p>OE.exportLFP()</p>
</blockquote>
</blockquote>
</blockquote>
<p>This will save either a .eeg or .egf file depending on the arguments. Check the
docstring for how to change what channel is chosen for the LFP etc.</p>
<blockquote>
<blockquote>
<blockquote>
<p>OE.exportSetFile()</p>
</blockquote>
</blockquote>
</blockquote>
<p>This should save the .set file with all the metadata for the trial.</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">OE2Axona</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts openephys data into Axona files</span>

<span class="sd">    Example workflow:</span>

<span class="sd">    You have recorded some openephys data using the binary</span>
<span class="sd">    format leading to a directory structure something like this:</span>

<span class="sd">    M4643_2023-07-21_11-52-02</span>
<span class="sd">     Record Node 101</span>
<span class="sd">      experiment1</span>
<span class="sd">       recording1</span>
<span class="sd">           continuous</span>
<span class="sd">            Acquisition_Board-100.Rhythm Data</span>
<span class="sd">                amplitudes.npy</span>
<span class="sd">                channel_map.npy</span>
<span class="sd">                channel_positions.npy</span>
<span class="sd">                cluster_Amplitude.tsv</span>
<span class="sd">                cluster_ContamPct.tsv</span>
<span class="sd">                cluster_KSLabel.tsv</span>
<span class="sd">                continuous.dat</span>
<span class="sd">                params.py</span>
<span class="sd">                pc_feature_ind.npy</span>
<span class="sd">                pc_features.npy</span>
<span class="sd">                phy.log</span>
<span class="sd">                rez.mat</span>
<span class="sd">                similar_templates.npy</span>
<span class="sd">                spike_clusters.npy</span>
<span class="sd">                spike_templates.npy</span>
<span class="sd">                spike_times.npy</span>
<span class="sd">                template_feature_ind.npy</span>
<span class="sd">                template_features.npy</span>
<span class="sd">                templates_ind.npy</span>
<span class="sd">                templates.npy</span>
<span class="sd">                whitening_mat_inv.npy</span>
<span class="sd">                whitening_mat.npy</span>
<span class="sd">           events</span>
<span class="sd">            Acquisition_Board-100.Rhythm Data</span>
<span class="sd">             TTL</span>
<span class="sd">                 full_words.npy</span>
<span class="sd">                 sample_numbers.npy</span>
<span class="sd">                 states.npy</span>
<span class="sd">                 timestamps.npy</span>
<span class="sd">            MessageCenter</span>
<span class="sd">                sample_numbers.npy</span>
<span class="sd">                text.npy</span>
<span class="sd">                timestamps.npy</span>
<span class="sd">           structure.oebin</span>
<span class="sd">           sync_messages.txt</span>
<span class="sd">      settings.xml</span>
<span class="sd">     Record Node 104</span>
<span class="sd">         experiment1</span>
<span class="sd">          recording1</span>
<span class="sd">              continuous</span>
<span class="sd">               TrackMe-103.TrackingNode</span>
<span class="sd">                   continuous.dat</span>
<span class="sd">                   sample_numbers.npy</span>
<span class="sd">                   timestamps.npy</span>
<span class="sd">              events</span>
<span class="sd">               MessageCenter</span>
<span class="sd">                sample_numbers.npy</span>
<span class="sd">                text.npy</span>
<span class="sd">                timestamps.npy</span>
<span class="sd">               TrackMe-103.TrackingNode</span>
<span class="sd">                   TTL</span>
<span class="sd">                       full_words.npy</span>
<span class="sd">                       sample_numbers.npy</span>
<span class="sd">                       states.npy</span>
<span class="sd">                       timestamps.npy</span>
<span class="sd">              structure.oebin</span>
<span class="sd">              sync_messages.txt</span>
<span class="sd">         settings.xml</span>

<span class="sd">    The binary data file is called &quot;continuous.dat&quot; in the</span>
<span class="sd">    continuous/Acquisition_Board-100.Rhythm Data folder. There</span>
<span class="sd">    is also a collection of files resulting from a KiloSort session</span>
<span class="sd">    in that directory.</span>

<span class="sd">    Run the conversion code like so:</span>

<span class="sd">    &gt;&gt;&gt; from ephysiopy.format_converters.OE_Axona import OE2Axona</span>
<span class="sd">    &gt;&gt;&gt; from pathlib import Path</span>
<span class="sd">    &gt;&gt;&gt; nChannels = 64</span>
<span class="sd">    &gt;&gt;&gt; apData = Path(&quot;M4643_2023-07-21_11-52-02/Record Node 101/experiment1/recording1/continuous/Acquisition_Board-100.Rhythm Data&quot;)</span>
<span class="sd">    &gt;&gt;&gt; OE = OE2Axona(Path(&quot;M4643_2023-07-21_11-52-02&quot;), path2APData=apData, channels=nChannels)</span>
<span class="sd">    &gt;&gt;&gt; OE.getOEData()</span>

<span class="sd">    The last command will attempt to load position data and also load up</span>
<span class="sd">    something called a TemplateModel (from the package phylib) which</span>
<span class="sd">    should grab a handle to the neural data. If that doesn&#39;t throw</span>
<span class="sd">    out errors then try:</span>

<span class="sd">    &gt;&gt;&gt; OE.exportPos()</span>

<span class="sd">    There are a few arguments you can provide the exportPos() function - see</span>
<span class="sd">    the docstring for it below. Basically, it calls a function called</span>
<span class="sd">    convertPosData(xy, xyts) where xy is the xy data with shape nsamples x 2</span>
<span class="sd">    and xyts is a vector of timestamps. So if the call to exportPos() fails, you</span>
<span class="sd">    could try calling convertPosData() directly which returns axona formatted</span>
<span class="sd">    position data. If the variable returned from convertPosData() is called axona_pos_data</span>
<span class="sd">    then you can call the function:</span>

<span class="sd">    writePos2AxonaFormat(pos_header, axona_pos_data)</span>

<span class="sd">    Providing the pos_header to it - see the last half of the exportPos function</span>
<span class="sd">    for how to create and modify the pos_header as that will need to have</span>
<span class="sd">    user-specific information added to it.</span>

<span class="sd">    &gt;&gt;&gt; OE.convertTemplateDataToAxonaTetrode()</span>

<span class="sd">    This is the main function for creating the tetrode files. It has an optional</span>
<span class="sd">    argument called max_n_waves which is used to limit the maximum number of spikes</span>
<span class="sd">    that make up a cluster. This defaults to 2000 which means that if a cluster has</span>
<span class="sd">    12000 spikes, it will have 2000 spikes randomly drawn from those 12000 (without</span>
<span class="sd">    replacement), that will then be saved to a tetrode file. This is mostly a time-saving</span>
<span class="sd">    device as if you have 250 clusters and many consist of 10,000&#39;s of spikes,</span>
<span class="sd">    processing that data will take a long time.</span>

<span class="sd">    &gt;&gt;&gt; OE.exportLFP()</span>

<span class="sd">    This will save either a .eeg or .egf file depending on the arguments. Check the</span>
<span class="sd">    docstring for how to change what channel is chosen for the LFP etc.</span>

<span class="sd">    &gt;&gt;&gt; OE.exportSetFile()</span>

<span class="sd">    This should save the .set file with all the metadata for the trial.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pname</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
        <span class="n">path2APData</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pos_sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            pname (Path): The base directory of the openephys recording.</span>
<span class="sd">                e.g. &#39;/home/robin/Data/M4643_2023-07-21_11-52-02&#39;</span>
<span class="sd">            path2APData (Path, optional): Path to AP data. Defaults to None.</span>
<span class="sd">            pos_sample_rate (int, optional): Position sample rate. Defaults to 50.</span>
<span class="sd">            channels (int, optional): Number of channels. Defaults to 0.</span>
<span class="sd">            **kwargs: Variable length argument list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pname</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">pname</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">pname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">path2APData</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">pos_sample_rate</span>
        <span class="c1"># &#39;experiment_1.nwb&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">experiment_name</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pname</span> <span class="ow">or</span> <span class="n">Path</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;experiment_name&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recording_name</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will become &#39;recording1&#39; etc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># becomes instance of io.recording.OpenEphysBase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will become an instance of OESettings.Settings</span>
        <span class="c1"># Create a basename for Axona file names</span>
        <span class="c1"># e.g.&#39;/home/robin/Data/experiment_1&#39;</span>
        <span class="c1"># that we can append &#39;.pos&#39; or &#39;.eeg&#39; or whatever onto</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">experiment_name</span>
        <span class="c1"># need to instantiated now for later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span> <span class="o">=</span> <span class="n">axonaIO</span><span class="o">.</span><span class="n">IO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.pos&quot;</span><span class="p">)</span>
        <span class="c1"># THIS IS TEMPORARY AND WILL BE MORE USER-SPECIFIABLE IN THE FUTURE</span>
        <span class="c1"># it is used to scale the spikes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hp_gain</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lp_gain</span> <span class="o">=</span> <span class="mi">15000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitvolts</span> <span class="o">=</span> <span class="mf">0.195</span>
        <span class="c1"># if left as None some default values for the next 3 params are loaded</span>
        <span class="c1">#  from top-level __init__.py</span>
        <span class="c1"># these are only used in self.__filterLFP__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># if lfp_channel is set to None then the .set file will reflect that</span>
        <span class="c1">#  no EEG was recorded</span>
        <span class="c1"># this should mean that you can load data into Tint without a .eeg file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lfp_channel</span> <span class="o">=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lfp_channel&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lfp_lowcut</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lfp_highcut</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># set the tetrodes to record from</span>
        <span class="c1"># defaults to 1 through 4 - see self.makeSetData below</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tetrodes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="o">=</span> <span class="n">channels</span>

    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">src_rate</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">dst_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resamples data using FFT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">dst_rate</span><span class="p">,</span> <span class="n">src_rate</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dst_rate</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span> <span class="n">src_rate</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the settings data from the settings.xml file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="n">OESettings</span><span class="o">.</span><span class="n">Settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span>

    <span class="nd">@settings</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">getOEData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OpenEphysBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the nwb file names in filename_root and returns a dict</span>
<span class="sd">        containing some of the nwb data relevant for converting to Axona file formats.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename_root (str): Fully qualified name of the nwb file.</span>
<span class="sd">            recording_name (str): The name of the recording in the nwb file. Note that</span>
<span class="sd">                the default has changed in different versions of OE from &#39;recording0&#39;</span>
<span class="sd">                to &#39;recording1&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">OE_data</span> <span class="o">=</span> <span class="n">OpenEphysBase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">OE_data</span><span class="o">.</span><span class="n">load_pos_data</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
            <span class="c1"># It&#39;s likely that spikes have been collected after the last</span>
            <span class="c1"># position sample</span>
            <span class="c1"># due to buffering issues I can&#39;t be bothered to resolve.</span>
            <span class="c1"># Get the last pos</span>
            <span class="c1"># timestamps here and check that spikes don&#39;t go beyond</span>
            <span class="c1">#  this when writing data</span>
            <span class="c1"># out later</span>
            <span class="c1"># Also the pos and spike data timestamps almost never start at</span>
            <span class="c1">#  0 as the user</span>
            <span class="c1"># usually acquires data for a while before recording.</span>
            <span class="c1"># Grab the first timestamp</span>
            <span class="c1"># here with a view to subtracting this from everything (including</span>
            <span class="c1"># the spike data)</span>
            <span class="c1"># and figuring out what to keep later</span>
            <span class="n">first_pos_ts</span> <span class="o">=</span> <span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xyTS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last_pos_ts</span> <span class="o">=</span> <span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xyTS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span> <span class="o">=</span> <span class="n">first_pos_ts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">=</span> <span class="n">last_pos_ts</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">OE_data</span><span class="o">.</span><span class="n">load_neural_data</span><span class="p">()</span>  <span class="c1"># will create TemplateModel instance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">template_model</span><span class="o">.</span><span class="n">duration</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First pos ts: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Last pos ts: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span> <span class="o">=</span> <span class="n">OE_data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">path2APdata</span>
        <span class="c1"># extract number of channels from settings</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">record_nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;Rhythm Data&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">channel_count</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OE_data</span>

    <span class="k">def</span> <span class="nf">exportSetFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for makeSetData below</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exporting set file data...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeSetData</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done exporting set file.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exportPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppm</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">jumpmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">as_text</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># Step 1) Deal with the position data first:</span>
        <span class="c1">#</span>
        <span class="c1"># Grab the settings of the pos tracker and do some post-processing</span>
        <span class="c1"># on the position</span>
        <span class="c1"># data (discard jumpy data, do some smoothing etc)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getOEData</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">load_pos_data</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Post-processing position data...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">jumpmax</span> <span class="o">=</span> <span class="n">jumpmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">tracker_params</span><span class="p">[</span><span class="s2">&quot;AxonaBadValue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1023</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">postprocesspos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">tracker_params</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xyTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xyTS</span>  <span class="c1"># in seconds</span>
        <span class="n">xyTS</span> <span class="o">=</span> <span class="n">xyTS</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
        <span class="c1"># extract some values from PosCalcs or overrides given</span>
        <span class="c1"># when calling this method</span>
        <span class="n">ppm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">ppm</span> <span class="ow">or</span> <span class="n">ppm</span>
        <span class="n">sample_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">sample_rate</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sample_rate&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">as_text</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beginning export of position data to text format...&quot;</span><span class="p">)</span>
            <span class="n">pos_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span> <span class="o">+</span> <span class="s2">&quot;.txt&quot;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">pos_file_name</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;%1.u&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Completed export of position data&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Do the upsampling of both xy and the timestamps</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beginning export of position data to Axona format...&quot;</span><span class="p">)</span>
        <span class="n">axona_pos_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertPosData</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">xyTS</span><span class="p">)</span>
        <span class="c1"># make sure pos data length is same as duration * num_samples</span>
        <span class="n">axona_pos_data</span> <span class="o">=</span> <span class="n">axona_pos_data</span><span class="p">[</span>
            <span class="mi">0</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span>
        <span class="p">]</span>
        <span class="c1"># Create an empty header for the pos data</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.axona.file_headers</span> <span class="kn">import</span> <span class="n">PosHeader</span>

        <span class="n">pos_header</span> <span class="o">=</span> <span class="n">PosHeader</span><span class="p">()</span>
        <span class="n">tracker_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">tracker_params</span>
        <span class="n">min_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
        <span class="n">max_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
        <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;min_x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;window_min_x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">tracker_params</span><span class="p">[</span><span class="s2">&quot;LeftBorder&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;LeftBorder&quot;</span> <span class="ow">in</span> <span class="n">tracker_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">min_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;min_y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;window_min_y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">tracker_params</span><span class="p">[</span><span class="s2">&quot;TopBorder&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;TopBorder&quot;</span> <span class="ow">in</span> <span class="n">tracker_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">min_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;max_x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;window_max_x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">tracker_params</span><span class="p">[</span><span class="s2">&quot;RightBorder&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;RightBorder&quot;</span> <span class="ow">in</span> <span class="n">tracker_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;max_y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;window_max_y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">tracker_params</span><span class="p">[</span><span class="s2">&quot;BottomBorder&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;BottomBorder&quot;</span> <span class="ow">in</span> <span class="n">tracker_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">pos_header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">))</span>
        <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;pixels_per_metre&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ppm</span><span class="p">)</span>
        <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;num_pos_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axona_pos_data</span><span class="p">))</span>
        <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;pixels_per_metre&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ppm</span><span class="p">)</span>
        <span class="n">pos_header</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s2">&quot;sample_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">writePos2AxonaFormat</span><span class="p">(</span><span class="n">pos_header</span><span class="p">,</span> <span class="n">axona_pos_data</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exported position data to Axona format&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exportSpikes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beginning conversion of spiking data...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convertSpikeData</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">nwbData</span><span class="p">[</span><span class="s2">&quot;acquisition&quot;</span><span class="p">][</span>
                <span class="s2">&quot;</span><span class="se">\</span>
<span class="s2">                timeseries&quot;</span>
            <span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">recording_name</span><span class="p">][</span><span class="s2">&quot;spikes&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Completed exporting spiking data&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exportLFP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lfp_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;eeg&quot;</span><span class="p">,</span> <span class="n">gain</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exports LFP data to file.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (int): The channel number.</span>
<span class="sd">            lfp_type (str): The type of LFP data. Legal values are &#39;egf&#39; or &#39;eeg&#39;.</span>
<span class="sd">            gain (int): Multiplier for the LFP data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beginning conversion and exporting of LFP data...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.io.recording</span> <span class="kn">import</span> <span class="n">memmapBinaryFile</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">memmapBinaryFile</span><span class="p">(</span>
                <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s2">&quot;continuous.dat&quot;</span><span class="p">),</span>
                <span class="n">n_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">makeLFPData</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span> <span class="p">:],</span> <span class="n">eeg_type</span><span class="o">=</span><span class="n">lfp_type</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">gain</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Completed exporting LFP data to &quot;</span> <span class="o">+</span> <span class="n">lfp_type</span> <span class="o">+</span> <span class="s2">&quot; format&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t load raw data:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convertPosData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xy_ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the conversion of the array parts of the data.</span>

<span class="sd">        Note: As well as upsampling the data to the Axona pos sampling rate (50Hz),</span>
<span class="sd">        we have to insert some columns into the pos array as Axona format</span>
<span class="sd">        expects it like: pos_format: t,x1,y1,x2,y2,numpix1,numpix2</span>
<span class="sd">        We can make up some of the info and ignore other bits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_new_pts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">xy_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span>
        <span class="n">new_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_new_pts</span><span class="p">)</span>
        <span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">new_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">new_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">new_x</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1023</span>
        <span class="n">new_y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">new_y</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1023</span>
        <span class="c1"># Expand the pos bit of the data to make it look like Axona data</span>
        <span class="n">new_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">new_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span>
            <span class="n">new_pos</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">new_pos</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1023</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_pos</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_pos</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="n">new_pos</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># just made this value up - it&#39;s numpix i think</span>
        <span class="n">new_pos</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># same</span>
        <span class="c1"># Squeeze this data into Axona pos format array</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">axona_files</span><span class="p">[</span><span class="s2">&quot;.pos&quot;</span><span class="p">]</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_new_pts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="c1"># Timestamps in Axona are pos_samples (monotonic, linear integer)</span>
        <span class="n">new_data</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ts</span>
        <span class="n">new_data</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pos</span>
        <span class="k">return</span> <span class="n">new_data</span>

    <span class="k">def</span> <span class="nf">convertTemplateDataToAxonaTetrode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_n_waves</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the data held in a TemplateModel instance into tetrode</span>
<span class="sd">        format Axona data files.</span>

<span class="sd">        For each cluster, there&#39;ll be a channel that has a peak amplitude and this contains that peak channel.</span>
<span class="sd">        While the other channels with a large signal in might be on the same tetrode, KiloSort (or whatever) might find</span>
<span class="sd">        channels *not* within the same tetrode. For a given cluster, we can extract from the TemplateModel the 12 channels across</span>
<span class="sd">        which the signal is strongest using Model.get_cluster_channels(). If a channel from a tetrode is missing from this list then the</span>
<span class="sd">        spikes for that channel(s) will be zeroed when saved to Axona format.</span>

<span class="sd">        Example:</span>
<span class="sd">            If cluster 3 has a peak channel of 1 then get_cluster_channels() might look like:</span>
<span class="sd">            [ 1,  2,  0,  6, 10, 11,  4,  12,  7,  5,  8,  9]</span>
<span class="sd">            Here the cluster has the best signal on 1, then 2, 0 etc, but note that channel 3 isn&#39;t in the list.</span>
<span class="sd">            In this case the data for channel 3 will be zeroed when saved to Axona format.</span>

<span class="sd">        References:</span>
<span class="sd">            1) https://phy.readthedocs.io/en/latest/api/#phyappstemplatetemplatemodel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First lets get the datatype for tetrode files as this will be the</span>
        <span class="c1"># same for all tetrodes...</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">axona_files</span><span class="p">[</span><span class="s2">&quot;.1&quot;</span><span class="p">]</span>
        <span class="c1"># Load the TemplateModel</span>
        <span class="k">if</span> <span class="s2">&quot;path2APdata&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">load_neural_data</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">load_neural_data</span><span class="p">()</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">template_model</span>
        <span class="n">clusts</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cluster_ids</span>
        <span class="c1"># have to pre-process the channels / clusters to determine</span>
        <span class="c1"># which tetrodes clusters belong to - this is based on</span>
        <span class="c1"># the &#39;best&#39; channel for a given cluster</span>
        <span class="n">clusters_channels</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">clusts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusts</span><span class="p">:</span>
            <span class="n">clusters_channels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cluster_channels</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">tetrodes_clusters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)),</span> <span class="p">[])</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tetrodes_clusters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">this_tetrodes_clusters</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters_channels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">this_tetrodes_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">tetrodes_clusters</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">this_tetrodes_clusters</span>
        <span class="c1"># limit the number of spikes to max_n_waves in the</span>
        <span class="c1"># interests of speed. Randomly select spikes across</span>
        <span class="c1"># the period they fire</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_tet_item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tetrodes_clusters</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">this_tetrode</span> <span class="o">=</span> <span class="n">i_tet_item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">times_to_sort</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_clusters</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_waves</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">i_tet_item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Tetrode &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">clust_chans</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cluster_channels</span><span class="p">(</span><span class="n">clust</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">clust_chans</span> <span class="o">&gt;=</span> <span class="n">this_tetrode</span><span class="p">,</span> <span class="n">clust_chans</span> <span class="o">&lt;</span> <span class="n">this_tetrode</span> <span class="o">+</span> <span class="mi">4</span>
                <span class="p">)</span>
                <span class="c1"># clust_chans is an ordered list of the channels</span>
                <span class="c1"># the cluster was most active on. idx has True</span>
                <span class="c1"># where there is overlap between that and the</span>
                <span class="c1"># currently active tetrode channel numbers (0:4, 4:8</span>
                <span class="c1"># or whatever)</span>
                <span class="n">spike_idx</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cluster_spikes</span><span class="p">(</span><span class="n">clust</span><span class="p">)</span>
                <span class="c1"># limit the number of spikes to max_n_waves in the</span>
                <span class="c1"># interests of speed. Randomly select spikes across</span>
                <span class="c1"># the period they fire</span>
                <span class="n">total_n_waves</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_idx</span><span class="p">)</span>
                <span class="n">max_num_waves</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">max_n_waves</span> <span class="k">if</span> <span class="n">max_n_waves</span> <span class="o">&lt;</span> <span class="n">total_n_waves</span> <span class="k">else</span> <span class="n">total_n_waves</span>
                <span class="p">)</span>
                <span class="c1"># grab spike times (in seconds) so the random sampling of</span>
                <span class="c1"># spikes matches their times</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">spike_clusters</span> <span class="o">==</span> <span class="n">clust</span><span class="p">]</span>
                <span class="n">spike_idx_times_subset</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">spike_idx</span><span class="p">,</span> <span class="n">times</span><span class="p">),</span> <span class="n">max_num_waves</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="c1"># spike_idx_times_subset is unsorted as it&#39;s just been drawn</span>
                <span class="c1"># from a random distribution, so sort it now</span>
                <span class="n">spike_idx_times_subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">spike_idx_times_subset</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># split out into spikes and times</span>
                <span class="n">spike_idx_subset</span> <span class="o">=</span> <span class="n">spike_idx_times_subset</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">spike_idx_times_subset</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">waves</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_waveforms</span><span class="p">(</span><span class="n">spike_idx_subset</span><span class="p">,</span> <span class="n">clust_chans</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="c1"># Given a spike at time T, Axona takes T-200us and T+800us</span>
                <span class="c1"># from the buffer to make up a waveform. From OE</span>
                <span class="c1"># take 30 samples which corresponds to a 1ms sample</span>
                <span class="c1"># if the data is sampled at 30kHz. Interpolate this so the</span>
                <span class="c1"># length is 50 samples as with Axona</span>
                <span class="n">waves</span> <span class="o">=</span> <span class="n">waves</span><span class="p">[:,</span> <span class="mi">30</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># waves go from int16 to float as a result of the resampling</span>
                <span class="n">waves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">waves</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># multiply by bitvolts to get microvolts</span>
                <span class="n">waves</span> <span class="o">=</span> <span class="n">waves</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitvolts</span>
                <span class="c1"># scale appropriately for Axona and invert as</span>
                <span class="c1"># OE seems to be inverted wrt Axona</span>
                <span class="n">waves</span> <span class="o">=</span> <span class="n">waves</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hp_gain</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">/</span> <span class="mf">128.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># check the shape of waves to make sure it has 4</span>
                <span class="c1"># channels, if not add some to make it so and make</span>
                <span class="c1"># sure they are in the correct order for the tetrode</span>
                <span class="n">ordered_chans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">clust_chans</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
                    <span class="n">z</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ordered_chans</span><span class="p">]</span> <span class="o">=</span> <span class="n">waves</span>
                    <span class="n">waves</span> <span class="o">=</span> <span class="n">z</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">waves</span> <span class="o">=</span> <span class="n">waves</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ordered_chans</span><span class="p">]</span>
                <span class="c1"># Axona format tetrode waveforms are nSpikes x 4 x 50</span>
                <span class="n">waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">waves</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="c1"># Append clusters to a list to sort later for saving a</span>
                <span class="c1"># cluster/ cut file</span>
                <span class="n">new_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">clust</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)))</span>
                <span class="c1"># Axona times are sampled at 96KHz</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">times</span> <span class="o">*</span> <span class="mi">96000</span>
                <span class="c1"># There is a time for each spike despite the repetition</span>
                <span class="c1"># get the indices for sorting</span>
                <span class="n">times_to_sort</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
                <span class="c1"># i_clust_data = np.zeros(len(new_times), dtype=dt)</span>
                <span class="n">new_waves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">waves</span><span class="p">)</span>
            <span class="c1"># Concatenate, order and reshape some of the lists/ arrays</span>
            <span class="k">if</span> <span class="n">times_to_sort</span><span class="p">:</span>  <span class="c1"># apparently can be empty sometimes</span>
                <span class="n">_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">times_to_sort</span><span class="p">)</span>
                <span class="n">_waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_waves</span><span class="p">)</span>
                <span class="n">_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_clusters</span><span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">_times</span><span class="p">)</span>
                <span class="n">sorted_times</span> <span class="o">=</span> <span class="n">_times</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">sorted_waves</span> <span class="o">=</span> <span class="n">_waves</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">sorted_clusts</span> <span class="o">=</span> <span class="n">_clusters</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">output_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">sorted_times</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
                <span class="n">output_waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">sorted_waves</span><span class="p">,</span>
                    <span class="p">[</span>
                        <span class="n">sorted_waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sorted_waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">sorted_waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">],</span>
                <span class="p">)</span>
                <span class="n">new_tetrode_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
                <span class="n">new_tetrode_data</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_times</span>
                <span class="n">new_tetrode_data</span><span class="p">[</span><span class="s2">&quot;waveform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_waves</span>
                <span class="n">header</span> <span class="o">=</span> <span class="n">TetrodeHeader</span><span class="p">()</span>
                <span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">duration</span><span class="p">))</span>
                <span class="n">header</span><span class="o">.</span><span class="n">tetrode_entries</span><span class="p">[</span><span class="s2">&quot;num_spikes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_clusters</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">writeTetrodeData</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">header</span><span class="p">,</span> <span class="n">new_tetrode_data</span><span class="p">)</span>
                <span class="n">cut_header</span> <span class="o">=</span> <span class="n">CutHeader</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">writeCutData</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cut_header</span><span class="p">,</span> <span class="n">sorted_clusts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convertSpikeData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf5_tetrode_data</span><span class="p">:</span> <span class="n">h5py</span><span class="o">.</span><span class="n">_hl</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the spike conversion from OE Spike Sorter format to Axona format tetrode files.</span>

<span class="sd">        Args:</span>
<span class="sd">            hdf5_tetrode_data (h5py._hl.group.Group): This kind of looks like a dictionary and can,</span>
<span class="sd">                it seems, be treated as one more or less. See http://docs.h5py.org/en/stable/high/group.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First lets get the datatype for tetrode files as this will be the</span>
        <span class="c1"># same for all tetrodes...</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">axona_files</span><span class="p">[</span><span class="s2">&quot;.1&quot;</span><span class="p">]</span>
        <span class="c1"># ... and a basic header for the tetrode file that use for each</span>
        <span class="c1"># tetrode file, changing only the num_spikes value</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">TetrodeHeader</span><span class="p">()</span>
        <span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hdf5_tetrode_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">spiking_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hdf5_tetrode_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">))</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hdf5_tetrode_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;timestamps&quot;</span><span class="p">))</span>
            <span class="c1"># check if any of the spiking data is captured before/ after the</span>
            <span class="c1">#  first/ last bit of position data</span>
            <span class="c1"># if there is then discard this as we potentially have no valid</span>
            <span class="c1"># position to align the spike to :(</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                <span class="n">timestamps</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">,</span> <span class="n">timestamps</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span>
            <span class="p">)</span>
            <span class="n">spiking_data</span> <span class="o">=</span> <span class="n">spiking_data</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="n">timestamps</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">]</span>
            <span class="c1"># subtract the first pos timestamp from the spiking timestamps</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="n">timestamps</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span>
            <span class="c1"># get the number of spikes here for use below in the header</span>
            <span class="n">num_spikes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">timestamps</span><span class="p">)</span>
            <span class="c1"># repeat the timestamps in tetrode multiples ready for Axona export</span>
            <span class="n">new_timestamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">timestamps</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="n">spiking_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="c1"># Convert to microvolts...</span>
            <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="n">new_spiking_data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitvolts</span>
            <span class="c1"># And upsample the spikes...</span>
            <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">new_spiking_data</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># ... and scale appropriately for Axona and invert as</span>
            <span class="c1"># OE seems to be inverted wrt Axona</span>
            <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="n">new_spiking_data</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hp_gain</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">/</span> <span class="mf">128.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># ... scale them to the gains specified somewhere</span>
            <span class="c1">#  (not sure where / how to do this yet)</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="n">new_spiking_data</span><span class="o">.</span><span class="n">shape</span>
            <span class="c1"># then reshape them as Axona wants them a bit differently</span>
            <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_spiking_data</span><span class="p">,</span> <span class="p">[</span><span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shp</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
            <span class="c1"># Cap any values outside the range of int8</span>
            <span class="n">new_spiking_data</span><span class="p">[</span><span class="n">new_spiking_data</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span>
            <span class="n">new_spiking_data</span><span class="p">[</span><span class="n">new_spiking_data</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">]</span> <span class="o">=</span> <span class="mi">127</span>
            <span class="c1"># create the new array</span>
            <span class="n">new_tetrode_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_timestamps</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">new_tetrode_data</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_timestamps</span> <span class="o">*</span> <span class="mi">96000</span>
            <span class="n">new_tetrode_data</span><span class="p">[</span><span class="s2">&quot;waveform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_spiking_data</span>
            <span class="c1"># change the header num_spikes field</span>
            <span class="n">header</span><span class="o">.</span><span class="n">tetrode_entries</span><span class="p">[</span><span class="s2">&quot;num_spikes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_spikes</span><span class="p">)</span>
            <span class="n">i_tetnum</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;electrode&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exporting tetrode </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_tetnum</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writeTetrodeData</span><span class="p">(</span><span class="n">i_tetnum</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">new_tetrode_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">makeLFPData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">eeg_type</span><span class="o">=</span><span class="s2">&quot;eeg&quot;</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mi">5000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downsamples the data in data and saves the result as either an egf or eeg file</span>
<span class="sd">        depending on the choice of either eeg_type which can take a value of either &#39;egf&#39; or &#39;eeg&#39;.</span>
<span class="sd">        Gain is the scaling factor.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.array): The data to be downsampled. Must have dtype as np.int16.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">eeg_type</span> <span class="o">==</span> <span class="s2">&quot;eeg&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ephysiopy.axona.file_headers</span> <span class="kn">import</span> <span class="n">EEGHeader</span>

            <span class="n">header</span> <span class="o">=</span> <span class="n">EEGHeader</span><span class="p">()</span>
            <span class="n">dst_rate</span> <span class="o">=</span> <span class="mi">250</span>
        <span class="k">elif</span> <span class="n">eeg_type</span> <span class="o">==</span> <span class="s2">&quot;egf&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ephysiopy.axona.file_headers</span> <span class="kn">import</span> <span class="n">EGFHeader</span>

            <span class="n">header</span> <span class="o">=</span> <span class="n">EGFHeader</span><span class="p">()</span>
            <span class="n">dst_rate</span> <span class="o">=</span> <span class="mi">4800</span>
        <span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;header.common[duration] = </span><span class="si">{</span><span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">_lfp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="mi">30000</span><span class="p">,</span> <span class="n">dst_rate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># make sure data is same length as sample_rate * duration</span>
        <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dst_rate</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]))</span>
        <span class="c1"># lfp_data might be shorter than nsamples. If so, fill the</span>
        <span class="c1"># remaining values with zeros</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lfp_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nsamples</span><span class="p">:</span>
            <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="n">lfp_data</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lfp_data</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_lfp_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">_lfp_data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nsamples</span><span class="p">]</span>
        <span class="n">lfp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__filterLFP__</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">,</span> <span class="n">dst_rate</span><span class="p">)</span>
        <span class="c1"># convert the data format</span>
        <span class="c1"># lfp_data = lfp_data * self.bitvolts # in microvolts</span>

        <span class="k">if</span> <span class="n">eeg_type</span> <span class="o">==</span> <span class="s2">&quot;eeg&quot;</span><span class="p">:</span>
            <span class="c1"># probably BROKEN</span>
            <span class="c1"># lfp_data starts out as int16 (see Parameters above)</span>
            <span class="c1"># but gets converted into float64 as part of the</span>
            <span class="c1"># resampling/ filtering process</span>
            <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_data</span> <span class="o">/</span> <span class="mf">32768.0</span>
            <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_data</span> <span class="o">*</span> <span class="n">gain</span>
            <span class="c1"># cap the values at either end...</span>
            <span class="n">lfp_data</span><span class="p">[</span><span class="n">lfp_data</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span>
            <span class="n">lfp_data</span><span class="p">[</span><span class="n">lfp_data</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">]</span> <span class="o">=</span> <span class="mi">127</span>
            <span class="c1"># and convert to int8</span>
            <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">eeg_type</span> <span class="o">==</span> <span class="s2">&quot;egf&quot;</span><span class="p">:</span>
            <span class="c1"># probably works</span>
            <span class="c1"># lfp_data = lfp_data / 256.</span>
            <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

        <span class="n">header</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeLFP2AxonaFormat</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">lfp_data</span><span class="p">,</span> <span class="n">eeg_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">makeSetData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lfp_channel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># to get the timestamps for duration key</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getOEData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.axona.file_headers</span> <span class="kn">import</span> <span class="n">SetHeader</span>

        <span class="n">header</span> <span class="o">=</span> <span class="n">SetHeader</span><span class="p">()</span>
        <span class="c1"># set some reasonable default values</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.__about__</span> <span class="kn">import</span> <span class="n">__version__</span>

        <span class="n">header</span><span class="o">.</span><span class="n">meta_info</span><span class="p">[</span><span class="s2">&quot;sw_version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">__version__</span><span class="p">)</span>
        <span class="c1"># ADC fullscale mv is 1500 in Axona and 0.195 in OE</span>
        <span class="c1"># there is a division by 1000 that happens when processing</span>
        <span class="c1"># spike data in Axona that looks like that has already</span>
        <span class="c1"># happened in OE. So here the OE 0.195 value is multiplied</span>
        <span class="c1"># by 1000 as it will get divided by 1000 later on to get</span>
        <span class="c1"># the correct scaling of waveforms/ gains -&gt; mv values</span>
        <span class="n">header</span><span class="o">.</span><span class="n">meta_info</span><span class="p">[</span><span class="s2">&quot;ADC_fullscale_mv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;195&quot;</span>
        <span class="n">header</span><span class="o">.</span><span class="n">meta_info</span><span class="p">[</span><span class="s2">&quot;tracker_version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1.1.0&quot;</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;gain&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hp_gain</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;collectMask&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
            <span class="k">if</span> <span class="s2">&quot;EEG_ch_1&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lfp_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">lfp_channel</span><span class="p">))</span>
            <span class="k">if</span> <span class="s2">&quot;mode_ch_&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="c1"># iterate again to make sure lfp gain set correctly</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">lfp_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;gain_ch_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lfp_channel</span><span class="p">):</span>
                    <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lp_gain</span><span class="p">)</span>

        <span class="c1"># Based on the data in the electrodes dict of the OESettings</span>
        <span class="c1"># instance (self.settings - see __init__)</span>
        <span class="c1"># determine which tetrodes we can let Tint load</span>
        <span class="c1"># make sure we&#39;ve parsed the electrodes</span>
        <span class="n">tetrode_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tetrode_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="s2">&quot;collectMask_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
        <span class="c1"># if self.lfp_channel is not None:</span>
        <span class="c1">#     for chan in self.tetrodes:</span>
        <span class="c1">#         key = &quot;collectMask_&quot; + str(chan)</span>
        <span class="c1">#         header.set_entries[key] = &quot;1&quot;</span>
        <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="s2">&quot;colactive_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
        <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="s2">&quot;colactive_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="s2">&quot;colactive_3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="s2">&quot;colactive_4&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="s2">&quot;colmap_algorithm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
        <span class="n">header</span><span class="o">.</span><span class="n">set_entries</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeSetData</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__filterLFP__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">filtfilt</span><span class="p">,</span> <span class="n">firwin</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ephysiopy</span> <span class="kn">import</span> <span class="n">fs</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_lowcut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ephysiopy</span> <span class="kn">import</span> <span class="n">lfp_lowcut</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">lfp_lowcut</span> <span class="o">=</span> <span class="n">lfp_lowcut</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_highcut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ephysiopy</span> <span class="kn">import</span> <span class="n">lfp_highcut</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">lfp_highcut</span> <span class="o">=</span> <span class="n">lfp_highcut</span>
        <span class="n">nyq</span> <span class="o">=</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">lowcut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_lowcut</span> <span class="o">/</span> <span class="n">nyq</span>
        <span class="n">highcut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfp_highcut</span> <span class="o">/</span> <span class="n">nyq</span>
        <span class="k">if</span> <span class="n">highcut</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">highcut</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">if</span> <span class="n">lowcut</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">lowcut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">sample_rate</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">],</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">padtype</span><span class="o">=</span><span class="s2">&quot;odd&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">writeLFP2AxonaFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">eeg_type</span><span class="o">=</span><span class="s2">&quot;eeg&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">setHeader</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">eeg_type</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">eeg_type</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">writePos2AxonaFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">setHeader</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.pos&quot;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.pos&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">writeTetrodeData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itet</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">setHeader</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">itet</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">itet</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">writeSetData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="n">dataclass</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">setHeader</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.set&quot;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">writeCutData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itet</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">setCut</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">itet</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.cut&quot;</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">data</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.settings" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">settings</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Loads the settings data from the settings.xml file</p>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="n">path2APData</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pos_sample_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Args:
    pname (Path): The base directory of the openephys recording.
        e.g. '/home/robin/Data/M4643_2023-07-21_11-52-02'
    path2APData (Path, optional): Path to AP data. Defaults to None.
    pos_sample_rate (int, optional): Position sample rate. Defaults to 50.
    channels (int, optional): Number of channels. Defaults to 0.
    **kwargs: Variable length argument list.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">pname</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
    <span class="n">path2APData</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pos_sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="n">channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        pname (Path): The base directory of the openephys recording.</span>
<span class="sd">            e.g. &#39;/home/robin/Data/M4643_2023-07-21_11-52-02&#39;</span>
<span class="sd">        path2APData (Path, optional): Path to AP data. Defaults to None.</span>
<span class="sd">        pos_sample_rate (int, optional): Position sample rate. Defaults to 50.</span>
<span class="sd">        channels (int, optional): Number of channels. Defaults to 0.</span>
<span class="sd">        **kwargs: Variable length argument list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pname</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">pname</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">pname</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">path2APData</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">pos_sample_rate</span>
    <span class="c1"># &#39;experiment_1.nwb&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">experiment_name</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pname</span> <span class="ow">or</span> <span class="n">Path</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;experiment_name&quot;</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">recording_name</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will become &#39;recording1&#39; etc</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># becomes instance of io.recording.OpenEphysBase</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will become an instance of OESettings.Settings</span>
    <span class="c1"># Create a basename for Axona file names</span>
    <span class="c1"># e.g.&#39;/home/robin/Data/experiment_1&#39;</span>
    <span class="c1"># that we can append &#39;.pos&#39; or &#39;.eeg&#39; or whatever onto</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">experiment_name</span>
    <span class="c1"># need to instantiated now for later</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span> <span class="o">=</span> <span class="n">axonaIO</span><span class="o">.</span><span class="n">IO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axona_root_name</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.pos&quot;</span><span class="p">)</span>
    <span class="c1"># THIS IS TEMPORARY AND WILL BE MORE USER-SPECIFIABLE IN THE FUTURE</span>
    <span class="c1"># it is used to scale the spikes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hp_gain</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lp_gain</span> <span class="o">=</span> <span class="mi">15000</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bitvolts</span> <span class="o">=</span> <span class="mf">0.195</span>
    <span class="c1"># if left as None some default values for the next 3 params are loaded</span>
    <span class="c1">#  from top-level __init__.py</span>
    <span class="c1"># these are only used in self.__filterLFP__</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># if lfp_channel is set to None then the .set file will reflect that</span>
    <span class="c1">#  no EEG was recorded</span>
    <span class="c1"># this should mean that you can load data into Tint without a .eeg file</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lfp_channel</span> <span class="o">=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lfp_channel&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lfp_lowcut</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lfp_highcut</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># set the tetrodes to record from</span>
    <span class="c1"># defaults to 1 through 4 - see self.makeSetData below</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tetrodes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="o">=</span> <span class="n">channels</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.convertPosData" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">convertPosData</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">xy_ts</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Performs the conversion of the array parts of the data.</p>
<p>Note: As well as upsampling the data to the Axona pos sampling rate (50Hz),
we have to insert some columns into the pos array as Axona format
expects it like: pos_format: t,x1,y1,x2,y2,numpix1,numpix2
We can make up some of the info and ignore other bits.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">convertPosData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xy_ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs the conversion of the array parts of the data.</span>

<span class="sd">    Note: As well as upsampling the data to the Axona pos sampling rate (50Hz),</span>
<span class="sd">    we have to insert some columns into the pos array as Axona format</span>
<span class="sd">    expects it like: pos_format: t,x1,y1,x2,y2,numpix1,numpix2</span>
<span class="sd">    We can make up some of the info and ignore other bits.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_new_pts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">xy_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span>
    <span class="n">new_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_new_pts</span><span class="p">)</span>
    <span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">new_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">new_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">new_x</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1023</span>
    <span class="n">new_y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">new_y</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1023</span>
    <span class="c1"># Expand the pos bit of the data to make it look like Axona data</span>
    <span class="n">new_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">new_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span>
        <span class="n">new_pos</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">new_pos</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1023</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_pos</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_pos</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">new_pos</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># just made this value up - it&#39;s numpix i think</span>
    <span class="n">new_pos</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># same</span>
    <span class="c1"># Squeeze this data into Axona pos format array</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">axona_files</span><span class="p">[</span><span class="s2">&quot;.pos&quot;</span><span class="p">]</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_new_pts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="c1"># Timestamps in Axona are pos_samples (monotonic, linear integer)</span>
    <span class="n">new_data</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ts</span>
    <span class="n">new_data</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pos</span>
    <span class="k">return</span> <span class="n">new_data</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.convertSpikeData" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">convertSpikeData</span><span class="p">(</span><span class="n">hdf5_tetrode_data</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Does the spike conversion from OE Spike Sorter format to Axona format tetrode files.</p>
<p>Args:
    hdf5_tetrode_data (h5py._hl.group.Group): This kind of looks like a dictionary and can,
        it seems, be treated as one more or less. See http://docs.h5py.org/en/stable/high/group.html</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">convertSpikeData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf5_tetrode_data</span><span class="p">:</span> <span class="n">h5py</span><span class="o">.</span><span class="n">_hl</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Does the spike conversion from OE Spike Sorter format to Axona format tetrode files.</span>

<span class="sd">    Args:</span>
<span class="sd">        hdf5_tetrode_data (h5py._hl.group.Group): This kind of looks like a dictionary and can,</span>
<span class="sd">            it seems, be treated as one more or less. See http://docs.h5py.org/en/stable/high/group.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First lets get the datatype for tetrode files as this will be the</span>
    <span class="c1"># same for all tetrodes...</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">axona_files</span><span class="p">[</span><span class="s2">&quot;.1&quot;</span><span class="p">]</span>
    <span class="c1"># ... and a basic header for the tetrode file that use for each</span>
    <span class="c1"># tetrode file, changing only the num_spikes value</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">TetrodeHeader</span><span class="p">()</span>
    <span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hdf5_tetrode_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">spiking_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hdf5_tetrode_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">))</span>
        <span class="n">timestamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hdf5_tetrode_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;timestamps&quot;</span><span class="p">))</span>
        <span class="c1"># check if any of the spiking data is captured before/ after the</span>
        <span class="c1">#  first/ last bit of position data</span>
        <span class="c1"># if there is then discard this as we potentially have no valid</span>
        <span class="c1"># position to align the spike to :(</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">timestamps</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">,</span> <span class="n">timestamps</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span>
        <span class="p">)</span>
        <span class="n">spiking_data</span> <span class="o">=</span> <span class="n">spiking_data</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">timestamps</span> <span class="o">=</span> <span class="n">timestamps</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># subtract the first pos timestamp from the spiking timestamps</span>
        <span class="n">timestamps</span> <span class="o">=</span> <span class="n">timestamps</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span>
        <span class="c1"># get the number of spikes here for use below in the header</span>
        <span class="n">num_spikes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">timestamps</span><span class="p">)</span>
        <span class="c1"># repeat the timestamps in tetrode multiples ready for Axona export</span>
        <span class="n">new_timestamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">timestamps</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="n">spiking_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># Convert to microvolts...</span>
        <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="n">new_spiking_data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitvolts</span>
        <span class="c1"># And upsample the spikes...</span>
        <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">new_spiking_data</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ... and scale appropriately for Axona and invert as</span>
        <span class="c1"># OE seems to be inverted wrt Axona</span>
        <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="n">new_spiking_data</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hp_gain</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">/</span> <span class="mf">128.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ... scale them to the gains specified somewhere</span>
        <span class="c1">#  (not sure where / how to do this yet)</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="n">new_spiking_data</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># then reshape them as Axona wants them a bit differently</span>
        <span class="n">new_spiking_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_spiking_data</span><span class="p">,</span> <span class="p">[</span><span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shp</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="c1"># Cap any values outside the range of int8</span>
        <span class="n">new_spiking_data</span><span class="p">[</span><span class="n">new_spiking_data</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span>
        <span class="n">new_spiking_data</span><span class="p">[</span><span class="n">new_spiking_data</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">]</span> <span class="o">=</span> <span class="mi">127</span>
        <span class="c1"># create the new array</span>
        <span class="n">new_tetrode_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_timestamps</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">new_tetrode_data</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_timestamps</span> <span class="o">*</span> <span class="mi">96000</span>
        <span class="n">new_tetrode_data</span><span class="p">[</span><span class="s2">&quot;waveform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_spiking_data</span>
        <span class="c1"># change the header num_spikes field</span>
        <span class="n">header</span><span class="o">.</span><span class="n">tetrode_entries</span><span class="p">[</span><span class="s2">&quot;num_spikes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_spikes</span><span class="p">)</span>
        <span class="n">i_tetnum</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;electrode&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exporting tetrode </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_tetnum</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeTetrodeData</span><span class="p">(</span><span class="n">i_tetnum</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">new_tetrode_data</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.convertTemplateDataToAxonaTetrode" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">convertTemplateDataToAxonaTetrode</span><span class="p">(</span><span class="n">max_n_waves</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Converts the data held in a TemplateModel instance into tetrode
format Axona data files.</p>
<p>For each cluster, there'll be a channel that has a peak amplitude and this contains that peak channel.
While the other channels with a large signal in might be on the same tetrode, KiloSort (or whatever) might find
channels <em>not</em> within the same tetrode. For a given cluster, we can extract from the TemplateModel the 12 channels across
which the signal is strongest using Model.get_cluster_channels(). If a channel from a tetrode is missing from this list then the
spikes for that channel(s) will be zeroed when saved to Axona format.</p>
<p>Example:
    If cluster 3 has a peak channel of 1 then get_cluster_channels() might look like:
    [ 1,  2,  0,  6, 10, 11,  4,  12,  7,  5,  8,  9]
    Here the cluster has the best signal on 1, then 2, 0 etc, but note that channel 3 isn't in the list.
    In this case the data for channel 3 will be zeroed when saved to Axona format.</p>
<p>References:
    1) https://phy.readthedocs.io/en/latest/api/#phyappstemplatetemplatemodel</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">convertTemplateDataToAxonaTetrode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_n_waves</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the data held in a TemplateModel instance into tetrode</span>
<span class="sd">    format Axona data files.</span>

<span class="sd">    For each cluster, there&#39;ll be a channel that has a peak amplitude and this contains that peak channel.</span>
<span class="sd">    While the other channels with a large signal in might be on the same tetrode, KiloSort (or whatever) might find</span>
<span class="sd">    channels *not* within the same tetrode. For a given cluster, we can extract from the TemplateModel the 12 channels across</span>
<span class="sd">    which the signal is strongest using Model.get_cluster_channels(). If a channel from a tetrode is missing from this list then the</span>
<span class="sd">    spikes for that channel(s) will be zeroed when saved to Axona format.</span>

<span class="sd">    Example:</span>
<span class="sd">        If cluster 3 has a peak channel of 1 then get_cluster_channels() might look like:</span>
<span class="sd">        [ 1,  2,  0,  6, 10, 11,  4,  12,  7,  5,  8,  9]</span>
<span class="sd">        Here the cluster has the best signal on 1, then 2, 0 etc, but note that channel 3 isn&#39;t in the list.</span>
<span class="sd">        In this case the data for channel 3 will be zeroed when saved to Axona format.</span>

<span class="sd">    References:</span>
<span class="sd">        1) https://phy.readthedocs.io/en/latest/api/#phyappstemplatetemplatemodel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First lets get the datatype for tetrode files as this will be the</span>
    <span class="c1"># same for all tetrodes...</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AxonaData</span><span class="o">.</span><span class="n">axona_files</span><span class="p">[</span><span class="s2">&quot;.1&quot;</span><span class="p">]</span>
    <span class="c1"># Load the TemplateModel</span>
    <span class="k">if</span> <span class="s2">&quot;path2APdata&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">load_neural_data</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">load_neural_data</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">template_model</span>
    <span class="n">clusts</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cluster_ids</span>
    <span class="c1"># have to pre-process the channels / clusters to determine</span>
    <span class="c1"># which tetrodes clusters belong to - this is based on</span>
    <span class="c1"># the &#39;best&#39; channel for a given cluster</span>
    <span class="n">clusters_channels</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">clusts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusts</span><span class="p">:</span>
        <span class="n">clusters_channels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cluster_channels</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">tetrodes_clusters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)),</span> <span class="p">[])</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tetrodes_clusters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">this_tetrodes_clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters_channels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">this_tetrodes_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">tetrodes_clusters</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">this_tetrodes_clusters</span>
    <span class="c1"># limit the number of spikes to max_n_waves in the</span>
    <span class="c1"># interests of speed. Randomly select spikes across</span>
    <span class="c1"># the period they fire</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_tet_item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tetrodes_clusters</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">this_tetrode</span> <span class="o">=</span> <span class="n">i_tet_item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">times_to_sort</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_waves</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">i_tet_item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Tetrode &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">clust_chans</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cluster_channels</span><span class="p">(</span><span class="n">clust</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">clust_chans</span> <span class="o">&gt;=</span> <span class="n">this_tetrode</span><span class="p">,</span> <span class="n">clust_chans</span> <span class="o">&lt;</span> <span class="n">this_tetrode</span> <span class="o">+</span> <span class="mi">4</span>
            <span class="p">)</span>
            <span class="c1"># clust_chans is an ordered list of the channels</span>
            <span class="c1"># the cluster was most active on. idx has True</span>
            <span class="c1"># where there is overlap between that and the</span>
            <span class="c1"># currently active tetrode channel numbers (0:4, 4:8</span>
            <span class="c1"># or whatever)</span>
            <span class="n">spike_idx</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cluster_spikes</span><span class="p">(</span><span class="n">clust</span><span class="p">)</span>
            <span class="c1"># limit the number of spikes to max_n_waves in the</span>
            <span class="c1"># interests of speed. Randomly select spikes across</span>
            <span class="c1"># the period they fire</span>
            <span class="n">total_n_waves</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_idx</span><span class="p">)</span>
            <span class="n">max_num_waves</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">max_n_waves</span> <span class="k">if</span> <span class="n">max_n_waves</span> <span class="o">&lt;</span> <span class="n">total_n_waves</span> <span class="k">else</span> <span class="n">total_n_waves</span>
            <span class="p">)</span>
            <span class="c1"># grab spike times (in seconds) so the random sampling of</span>
            <span class="c1"># spikes matches their times</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">spike_clusters</span> <span class="o">==</span> <span class="n">clust</span><span class="p">]</span>
            <span class="n">spike_idx_times_subset</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                <span class="p">(</span><span class="n">spike_idx</span><span class="p">,</span> <span class="n">times</span><span class="p">),</span> <span class="n">max_num_waves</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="c1"># spike_idx_times_subset is unsorted as it&#39;s just been drawn</span>
            <span class="c1"># from a random distribution, so sort it now</span>
            <span class="n">spike_idx_times_subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">spike_idx_times_subset</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># split out into spikes and times</span>
            <span class="n">spike_idx_subset</span> <span class="o">=</span> <span class="n">spike_idx_times_subset</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">spike_idx_times_subset</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">waves</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_waveforms</span><span class="p">(</span><span class="n">spike_idx_subset</span><span class="p">,</span> <span class="n">clust_chans</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="c1"># Given a spike at time T, Axona takes T-200us and T+800us</span>
            <span class="c1"># from the buffer to make up a waveform. From OE</span>
            <span class="c1"># take 30 samples which corresponds to a 1ms sample</span>
            <span class="c1"># if the data is sampled at 30kHz. Interpolate this so the</span>
            <span class="c1"># length is 50 samples as with Axona</span>
            <span class="n">waves</span> <span class="o">=</span> <span class="n">waves</span><span class="p">[:,</span> <span class="mi">30</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># waves go from int16 to float as a result of the resampling</span>
            <span class="n">waves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">waves</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># multiply by bitvolts to get microvolts</span>
            <span class="n">waves</span> <span class="o">=</span> <span class="n">waves</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitvolts</span>
            <span class="c1"># scale appropriately for Axona and invert as</span>
            <span class="c1"># OE seems to be inverted wrt Axona</span>
            <span class="n">waves</span> <span class="o">=</span> <span class="n">waves</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hp_gain</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">/</span> <span class="mf">128.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># check the shape of waves to make sure it has 4</span>
            <span class="c1"># channels, if not add some to make it so and make</span>
            <span class="c1"># sure they are in the correct order for the tetrode</span>
            <span class="n">ordered_chans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">clust_chans</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">z</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ordered_chans</span><span class="p">]</span> <span class="o">=</span> <span class="n">waves</span>
                <span class="n">waves</span> <span class="o">=</span> <span class="n">z</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">waves</span> <span class="o">=</span> <span class="n">waves</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ordered_chans</span><span class="p">]</span>
            <span class="c1"># Axona format tetrode waveforms are nSpikes x 4 x 50</span>
            <span class="n">waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">waves</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># Append clusters to a list to sort later for saving a</span>
            <span class="c1"># cluster/ cut file</span>
            <span class="n">new_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">clust</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)))</span>
            <span class="c1"># Axona times are sampled at 96KHz</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">times</span> <span class="o">*</span> <span class="mi">96000</span>
            <span class="c1"># There is a time for each spike despite the repetition</span>
            <span class="c1"># get the indices for sorting</span>
            <span class="n">times_to_sort</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
            <span class="c1"># i_clust_data = np.zeros(len(new_times), dtype=dt)</span>
            <span class="n">new_waves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">waves</span><span class="p">)</span>
        <span class="c1"># Concatenate, order and reshape some of the lists/ arrays</span>
        <span class="k">if</span> <span class="n">times_to_sort</span><span class="p">:</span>  <span class="c1"># apparently can be empty sometimes</span>
            <span class="n">_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">times_to_sort</span><span class="p">)</span>
            <span class="n">_waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_waves</span><span class="p">)</span>
            <span class="n">_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_clusters</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">_times</span><span class="p">)</span>
            <span class="n">sorted_times</span> <span class="o">=</span> <span class="n">_times</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">sorted_waves</span> <span class="o">=</span> <span class="n">_waves</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">sorted_clusts</span> <span class="o">=</span> <span class="n">_clusters</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">output_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">sorted_times</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">output_waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">sorted_waves</span><span class="p">,</span>
                <span class="p">[</span>
                    <span class="n">sorted_waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sorted_waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">sorted_waves</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="p">],</span>
            <span class="p">)</span>
            <span class="n">new_tetrode_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">new_tetrode_data</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_times</span>
            <span class="n">new_tetrode_data</span><span class="p">[</span><span class="s2">&quot;waveform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_waves</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">TetrodeHeader</span><span class="p">()</span>
            <span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">duration</span><span class="p">))</span>
            <span class="n">header</span><span class="o">.</span><span class="n">tetrode_entries</span><span class="p">[</span><span class="s2">&quot;num_spikes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_clusters</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writeTetrodeData</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">header</span><span class="p">,</span> <span class="n">new_tetrode_data</span><span class="p">)</span>
            <span class="n">cut_header</span> <span class="o">=</span> <span class="n">CutHeader</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writeCutData</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cut_header</span><span class="p">,</span> <span class="n">sorted_clusts</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.exportLFP" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">exportLFP</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lfp_type</span><span class="o">=</span><span class="s1">&#39;eeg&#39;</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Exports LFP data to file.</p>
<p>Args:
    channel (int): The channel number.
    lfp_type (str): The type of LFP data. Legal values are 'egf' or 'eeg'.
    gain (int): Multiplier for the LFP data.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">exportLFP</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lfp_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;eeg&quot;</span><span class="p">,</span> <span class="n">gain</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exports LFP data to file.</span>

<span class="sd">    Args:</span>
<span class="sd">        channel (int): The channel number.</span>
<span class="sd">        lfp_type (str): The type of LFP data. Legal values are &#39;egf&#39; or &#39;eeg&#39;.</span>
<span class="sd">        gain (int): Multiplier for the LFP data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beginning conversion and exporting of LFP data...&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">ephysiopy.io.recording</span> <span class="kn">import</span> <span class="n">memmapBinaryFile</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">memmapBinaryFile</span><span class="p">(</span>
            <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s2">&quot;continuous.dat&quot;</span><span class="p">),</span>
            <span class="n">n_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeLFPData</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span> <span class="p">:],</span> <span class="n">eeg_type</span><span class="o">=</span><span class="n">lfp_type</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">gain</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Completed exporting LFP data to &quot;</span> <span class="o">+</span> <span class="n">lfp_type</span> <span class="o">+</span> <span class="s2">&quot; format&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t load raw data:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.exportSetFile" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">exportSetFile</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Wrapper for makeSetData below</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">exportSetFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for makeSetData below</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exporting set file data...&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">makeSetData</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done exporting set file.&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.getOEData" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getOEData</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Loads the nwb file names in filename_root and returns a dict
containing some of the nwb data relevant for converting to Axona file formats.</p>
<p>Args:
    filename_root (str): Fully qualified name of the nwb file.
    recording_name (str): The name of the recording in the nwb file. Note that
        the default has changed in different versions of OE from 'recording0'
        to 'recording1'.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getOEData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OpenEphysBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads the nwb file names in filename_root and returns a dict</span>
<span class="sd">    containing some of the nwb data relevant for converting to Axona file formats.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename_root (str): Fully qualified name of the nwb file.</span>
<span class="sd">        recording_name (str): The name of the recording in the nwb file. Note that</span>
<span class="sd">            the default has changed in different versions of OE from &#39;recording0&#39;</span>
<span class="sd">            to &#39;recording1&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">OE_data</span> <span class="o">=</span> <span class="n">OpenEphysBase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pname</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">OE_data</span><span class="o">.</span><span class="n">load_pos_data</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
        <span class="c1"># It&#39;s likely that spikes have been collected after the last</span>
        <span class="c1"># position sample</span>
        <span class="c1"># due to buffering issues I can&#39;t be bothered to resolve.</span>
        <span class="c1"># Get the last pos</span>
        <span class="c1"># timestamps here and check that spikes don&#39;t go beyond</span>
        <span class="c1">#  this when writing data</span>
        <span class="c1"># out later</span>
        <span class="c1"># Also the pos and spike data timestamps almost never start at</span>
        <span class="c1">#  0 as the user</span>
        <span class="c1"># usually acquires data for a while before recording.</span>
        <span class="c1"># Grab the first timestamp</span>
        <span class="c1"># here with a view to subtracting this from everything (including</span>
        <span class="c1"># the spike data)</span>
        <span class="c1"># and figuring out what to keep later</span>
        <span class="n">first_pos_ts</span> <span class="o">=</span> <span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xyTS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">last_pos_ts</span> <span class="o">=</span> <span class="n">OE_data</span><span class="o">.</span><span class="n">PosCalcs</span><span class="o">.</span><span class="n">xyTS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span> <span class="o">=</span> <span class="n">first_pos_ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">=</span> <span class="n">last_pos_ts</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">OE_data</span><span class="o">.</span><span class="n">load_neural_data</span><span class="p">()</span>  <span class="c1"># will create TemplateModel instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">template_model</span><span class="o">.</span><span class="n">duration</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First pos ts: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Last pos ts: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span> <span class="o">=</span> <span class="n">OE_data</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path2APdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">path2APdata</span>
    <span class="c1"># extract number of channels from settings</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">record_nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="s2">&quot;Rhythm Data&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">channel_count</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">OE_data</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.makeLFPData" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">makeLFPData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">eeg_type</span><span class="o">=</span><span class="s1">&#39;eeg&#39;</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Downsamples the data in data and saves the result as either an egf or eeg file
depending on the choice of either eeg_type which can take a value of either 'egf' or 'eeg'.
Gain is the scaling factor.</p>
<p>Args:
    data (np.array): The data to be downsampled. Must have dtype as np.int16.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">makeLFPData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">eeg_type</span><span class="o">=</span><span class="s2">&quot;eeg&quot;</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mi">5000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downsamples the data in data and saves the result as either an egf or eeg file</span>
<span class="sd">    depending on the choice of either eeg_type which can take a value of either &#39;egf&#39; or &#39;eeg&#39;.</span>
<span class="sd">    Gain is the scaling factor.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (np.array): The data to be downsampled. Must have dtype as np.int16.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">eeg_type</span> <span class="o">==</span> <span class="s2">&quot;eeg&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.axona.file_headers</span> <span class="kn">import</span> <span class="n">EEGHeader</span>

        <span class="n">header</span> <span class="o">=</span> <span class="n">EEGHeader</span><span class="p">()</span>
        <span class="n">dst_rate</span> <span class="o">=</span> <span class="mi">250</span>
    <span class="k">elif</span> <span class="n">eeg_type</span> <span class="o">==</span> <span class="s2">&quot;egf&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.axona.file_headers</span> <span class="kn">import</span> <span class="n">EGFHeader</span>

        <span class="n">header</span> <span class="o">=</span> <span class="n">EGFHeader</span><span class="p">()</span>
        <span class="n">dst_rate</span> <span class="o">=</span> <span class="mi">4800</span>
    <span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;header.common[duration] = </span><span class="si">{</span><span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">_lfp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="mi">30000</span><span class="p">,</span> <span class="n">dst_rate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># make sure data is same length as sample_rate * duration</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dst_rate</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]))</span>
    <span class="c1"># lfp_data might be shorter than nsamples. If so, fill the</span>
    <span class="c1"># remaining values with zeros</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lfp_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nsamples</span><span class="p">:</span>
        <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>
        <span class="n">lfp_data</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lfp_data</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_lfp_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">_lfp_data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nsamples</span><span class="p">]</span>
    <span class="n">lfp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__filterLFP__</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">,</span> <span class="n">dst_rate</span><span class="p">)</span>
    <span class="c1"># convert the data format</span>
    <span class="c1"># lfp_data = lfp_data * self.bitvolts # in microvolts</span>

    <span class="k">if</span> <span class="n">eeg_type</span> <span class="o">==</span> <span class="s2">&quot;eeg&quot;</span><span class="p">:</span>
        <span class="c1"># probably BROKEN</span>
        <span class="c1"># lfp_data starts out as int16 (see Parameters above)</span>
        <span class="c1"># but gets converted into float64 as part of the</span>
        <span class="c1"># resampling/ filtering process</span>
        <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_data</span> <span class="o">/</span> <span class="mf">32768.0</span>
        <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_data</span> <span class="o">*</span> <span class="n">gain</span>
        <span class="c1"># cap the values at either end...</span>
        <span class="n">lfp_data</span><span class="p">[</span><span class="n">lfp_data</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span>
        <span class="n">lfp_data</span><span class="p">[</span><span class="n">lfp_data</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">]</span> <span class="o">=</span> <span class="mi">127</span>
        <span class="c1"># and convert to int8</span>
        <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">eeg_type</span> <span class="o">==</span> <span class="s2">&quot;egf&quot;</span><span class="p">:</span>
        <span class="c1"># probably works</span>
        <span class="c1"># lfp_data = lfp_data / 256.</span>
        <span class="n">lfp_data</span> <span class="o">=</span> <span class="n">lfp_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

    <span class="n">header</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">writeLFP2AxonaFormat</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">lfp_data</span><span class="p">,</span> <span class="n">eeg_type</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_Axona.OE2Axona.resample" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">src_rate</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">dst_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Resamples data using FFT</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_Axona.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">src_rate</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">dst_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resamples data using FFT</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">dst_rate</span><span class="p">,</span> <span class="n">src_rate</span><span class="p">)</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dst_rate</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span> <span class="n">src_rate</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_data</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="openephys-to-numpy">OpenEphys to numpy</h3>


<div class="doc doc-object doc-module">



<a id="ephysiopy.format_converters.OE_numpy"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ephysiopy.format_converters.OE_numpy.OE2Numpy" class="doc doc-heading">
            <code>OE2Numpy</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>Converts openephys data recorded in the nwb format into numpy files</p>
<p>NB Only exports the LFP and TTL files at the moment</p>






              <details class="quote">
                <summary>Source code in <code>ephysiopy/format_converters/OE_numpy.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">OE2Numpy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts openephys data recorded in the nwb format into numpy files</span>

<span class="sd">    NB Only exports the LFP and TTL files at the moment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">=</span> <span class="n">filename_root</span>  <span class="c1"># /home/robin/Data/experiment_1.nwb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span>  <span class="c1"># &#39;/home/robin/Data&#39;</span>
        <span class="c1"># &#39;experiment_1.nwb&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">experiment_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recording_name</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will become &#39;recording1&#39; etc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># becomes OpenEphysBase instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will become an instance of OESettings.Settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lfp_lowcut</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lfp_highcut</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">src_rate</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">dst_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Upsamples data using FFT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">dst_rate</span><span class="p">,</span> <span class="n">src_rate</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">dst_rate</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="n">src_rate</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the settings data from the settings.xml file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="n">OESettings</span><span class="o">.</span><span class="n">Settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span>

    <span class="nd">@settings</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">getOEData</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">recording_name</span><span class="o">=</span><span class="s1">&#39;recording1&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the nwb file names in filename_root and returns a dict</span>
<span class="sd">        containing some of the nwb data relevant for converting to Axona</span>
<span class="sd">        file formats.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename_root (str): Fully qualified name of the nwb file.</span>
<span class="sd">            recording_name (str): The name of the recording in the nwb file.</span>
<span class="sd">            Note that the default has changed in different versions of OE from</span>
<span class="sd">            &#39;recording0&#39; to &#39;recording1&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename_root</span><span class="p">):</span>
            <span class="n">OE_data</span> <span class="o">=</span> <span class="n">OpenEphysNWB</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading nwb data...&quot;</span><span class="p">)</span>
            <span class="n">OE_data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">session_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">experiment_name</span><span class="p">,</span>
                <span class="n">recording_name</span><span class="o">=</span><span class="n">recording_name</span><span class="p">,</span> <span class="n">loadspikes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loadraw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded nwb data from: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename_root</span><span class="p">))</span>
            <span class="c1"># It&#39;s likely that spikes have been collected after the last</span>
            <span class="c1"># position sample</span>
            <span class="c1"># due to buffering issues I can&#39;t be bothered to resolve.</span>
            <span class="c1"># Get the last pos</span>
            <span class="c1"># timestamps here and check that spikes don&#39;t go beyond this</span>
            <span class="c1"># when writing data out later</span>
            <span class="c1"># Also the pos and spike data timestamps almost never start at</span>
            <span class="c1">#  0 as the user</span>
            <span class="c1"># usually acquires data for a while before recording.</span>
            <span class="c1"># Grab the first timestamp</span>
            <span class="c1"># here with a view to subtracting this from everything</span>
            <span class="c1"># (including the spike data)</span>
            <span class="c1"># and figuring out what to keep later</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># pos might not be present</span>
                <span class="n">first_pos_ts</span> <span class="o">=</span> <span class="n">OE_data</span><span class="o">.</span><span class="n">xyTS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">last_pos_ts</span> <span class="o">=</span> <span class="n">OE_data</span><span class="o">.</span><span class="n">xyTS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span> <span class="o">=</span> <span class="n">first_pos_ts</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">=</span> <span class="n">last_pos_ts</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No position data in nwb file&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recording_name</span> <span class="o">=</span> <span class="n">recording_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span> <span class="o">=</span> <span class="n">OE_data</span>
            <span class="k">return</span> <span class="n">OE_data</span>

    <span class="k">def</span> <span class="nf">exportLFP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">output_freq</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beginning conversion and exporting of LFP data...&quot;</span><span class="p">)</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">processors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">fpga_sample_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">parseProcessor</span><span class="p">()</span>
        <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;lfp.npy&quot;</span><span class="p">)</span>
        <span class="n">output_ts_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;lfp_timestamps.npy&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># resample data</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Resampling data from </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2"> Hz&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">fpga_sample_rate</span><span class="p">,</span> <span class="n">output_freq</span><span class="p">))</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">rawData</span><span class="p">[:,</span> <span class="n">channels</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">fpga_sample_rate</span><span class="p">,</span> <span class="n">output_freq</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Resampling data from </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2"> Hz&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">fpga_sample_rate</span><span class="p">,</span> <span class="n">output_freq</span><span class="p">))</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">rawData</span><span class="p">[:,</span> <span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">channels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">fpga_sample_rate</span><span class="p">,</span> <span class="n">output_freq</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">nsamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">new_data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nsamples</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output_ts_name</span><span class="p">,</span> <span class="n">new_ts</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished exporting LFP data&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exportTTL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exporting TTL data...&quot;</span><span class="p">)</span>
        <span class="n">ttl_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">ttl_data</span>
        <span class="n">ttl_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">ttl_timestamps</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;ttl_state.npy&quot;</span><span class="p">),</span> <span class="n">ttl_state</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;ttl_timestamps.npy&quot;</span><span class="p">),</span> <span class="n">ttl_ts</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished exporting TTL data&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exportRaw2Binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">rawData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Load the data first. See getOEData()&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">output_fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.bin&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exporting raw data to:</span><span class="se">\n</span><span class="si">{</span><span class="n">output_fname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span><span class="o">.</span><span class="n">rawData</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished exporting&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ephysiopy.format_converters.OE_numpy.OE2Numpy.settings" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">settings</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Loads the settings data from the settings.xml file</p>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_numpy.OE2Numpy.getOEData" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">getOEData</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">recording_name</span><span class="o">=</span><span class="s1">&#39;recording1&#39;</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Loads the nwb file names in filename_root and returns a dict
containing some of the nwb data relevant for converting to Axona
file formats.</p>
<p>Args:
    filename_root (str): Fully qualified name of the nwb file.
    recording_name (str): The name of the recording in the nwb file.
    Note that the default has changed in different versions of OE from
    'recording0' to 'recording1'.</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_numpy.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">getOEData</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">recording_name</span><span class="o">=</span><span class="s1">&#39;recording1&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads the nwb file names in filename_root and returns a dict</span>
<span class="sd">    containing some of the nwb data relevant for converting to Axona</span>
<span class="sd">    file formats.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename_root (str): Fully qualified name of the nwb file.</span>
<span class="sd">        recording_name (str): The name of the recording in the nwb file.</span>
<span class="sd">        Note that the default has changed in different versions of OE from</span>
<span class="sd">        &#39;recording0&#39; to &#39;recording1&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename_root</span><span class="p">):</span>
        <span class="n">OE_data</span> <span class="o">=</span> <span class="n">OpenEphysNWB</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading nwb data...&quot;</span><span class="p">)</span>
        <span class="n">OE_data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">,</span> <span class="n">session_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">experiment_name</span><span class="p">,</span>
            <span class="n">recording_name</span><span class="o">=</span><span class="n">recording_name</span><span class="p">,</span> <span class="n">loadspikes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loadraw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loaded nwb data from: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename_root</span><span class="p">))</span>
        <span class="c1"># It&#39;s likely that spikes have been collected after the last</span>
        <span class="c1"># position sample</span>
        <span class="c1"># due to buffering issues I can&#39;t be bothered to resolve.</span>
        <span class="c1"># Get the last pos</span>
        <span class="c1"># timestamps here and check that spikes don&#39;t go beyond this</span>
        <span class="c1"># when writing data out later</span>
        <span class="c1"># Also the pos and spike data timestamps almost never start at</span>
        <span class="c1">#  0 as the user</span>
        <span class="c1"># usually acquires data for a while before recording.</span>
        <span class="c1"># Grab the first timestamp</span>
        <span class="c1"># here with a view to subtracting this from everything</span>
        <span class="c1"># (including the spike data)</span>
        <span class="c1"># and figuring out what to keep later</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># pos might not be present</span>
            <span class="n">first_pos_ts</span> <span class="o">=</span> <span class="n">OE_data</span><span class="o">.</span><span class="n">xyTS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last_pos_ts</span> <span class="o">=</span> <span class="n">OE_data</span><span class="o">.</span><span class="n">xyTS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_pos_ts</span> <span class="o">=</span> <span class="n">first_pos_ts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_pos_ts</span> <span class="o">=</span> <span class="n">last_pos_ts</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No position data in nwb file&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recording_name</span> <span class="o">=</span> <span class="n">recording_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OE_data</span> <span class="o">=</span> <span class="n">OE_data</span>
        <span class="k">return</span> <span class="n">OE_data</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ephysiopy.format_converters.OE_numpy.OE2Numpy.resample" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">src_rate</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">dst_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Upsamples data using FFT</p>

            <details class="quote">
              <summary>Source code in <code>ephysiopy/format_converters/OE_numpy.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">src_rate</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">dst_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Upsamples data using FFT</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">dst_rate</span><span class="p">,</span> <span class="n">src_rate</span><span class="p">)</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">dst_rate</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="n">src_rate</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_data</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.a7c05c9e.min.js"></script>
      
    
  </body>
</html>