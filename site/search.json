{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Home","text":"<p>A set of tools for the analysis of electrophysiological data recorded using Axona or OpenEphys data, be that using tetrode or Neuropixels</p>","path":["Home"],"tags":[]},{"location":"#installation","level":2,"title":"Installation","text":"<p>ephysiopy requires python 3.13 or greater. The easiest way to install is using uv or pip.</p> <p>Install uv</p> <p>Then, to install ephysiopy, run:</p> <pre><code>uv pip install ephysiopy\n</code></pre> <p>or with pip:</p> <pre><code>python3 -m pip install ephysiopy\n</code></pre>","path":["Home"],"tags":[]},{"location":"ephysiopy_tutorial/","level":1,"title":"ephysiopy user guide","text":"<p>This guide is an overview and explains basic features; details are found in the ephysiopy reference</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#getting-started","level":2,"title":"Getting started","text":"<p>What is ephysiopy?</p> <p>Installation</p> <p>ephsyiopy quickstart</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#data-organisation","level":2,"title":"Data organisation","text":"<ol> <li>With data recorded using OpenEphys the folder structure looks something like this:</li> </ol> <p>:: <pre><code>  RHA1-00064_2023-07-07_10-47-31\n  ├── Record Node 101\n  │   ├── experiment1\n  │   │   └── recording1\n  │   │       ├── continuous\n  │   │       │   └── Acquisition_Board-100.Rhythm Data\n  │   │       │       ├── amplitudes.npy\n  │   │       │       ├── channel_map.npy\n  │   │       │       ├── channel_positions.npy\n  │   │       │       ├── cluster_Amplitude.tsv\n  │   │       │       ├── cluster_ContamPct.tsv\n  │   │       │       ├── cluster_group.tsv\n  │   │       │       ├── cluster_info.tsv\n  │   │       │       ├── cluster_KSLabel.tsv\n  │   │       │       ├── continuous.dat\n  │   │       │       ├── params.py\n  │   │       │       ├── pc_feature_ind.npy\n  │   │       │       ├── pc_features.npy\n  │   │       │       ├── phy.log\n  │   │       │       ├── rez.mat\n  │   │       │       ├── similar_templates.npy\n  │   │       │       ├── spike_clusters.npy\n  │   │       │       ├── spike_templates.npy\n  │   │       │       ├── spike_times.npy\n  │   │       │       ├── template_feature_ind.npy\n  │   │       │       ├── template_features.npy\n  │   │       │       ├── templates_ind.npy\n  │   │       │       ├── templates.npy\n  │   │       │       ├── whitening_mat_inv.npy\n  │   │       │       └── whitening_mat.npy\n  │   │       ├── events\n  │   │       │   ├── Acquisition_Board-100.Rhythm Data\n  │   │       │   │   └── TTL\n  │   │       │   │       ├── full_words.npy\n  │   │       │   │       ├── sample_numbers.npy\n  │   │       │   │       ├── states.npy\n  │   │       │   │       └── timestamps.npy\n  │   │       │   └── MessageCenter\n  │   │       │       ├── sample_numbers.npy\n  │   │       │       ├── text.npy\n  │   │       │       └── timestamps.npy\n  │   │       ├── structure.oebin\n  │   │       └── sync_messages.txt\n  │   └── settings.xml\n  └── Record Node 104\n      ├── experiment1\n      │   └── recording1\n      │       ├── continuous\n      │       │   └── TrackMe-103.TrackingNode\n      │       │       ├── continuous.dat\n      │       │       ├── sample_numbers.npy\n      │       │       └── timestamps.npy\n      │       ├── events\n      │       │   ├── MessageCenter\n      │       │   │   ├── sample_numbers.npy\n      │       │   │   ├── text.npy\n      │       │   │   └── timestamps.npy\n      │       │   └── TrackMe-103.TrackingNode\n      │       │       └── TTL\n      │       │           ├── full_words.npy\n      │       │           ├── sample_numbers.npy\n      │       │           ├── states.npy\n      │       │           └── timestamps.npy\n      │       ├── structure.oebin\n      │       └── sync_messages.txt\n      └── settings.xml\n</code></pre></p> <p>Despite looking overwhelming this is actually fairly straighforward...</p> <p>The top level (or parent) folder is called </p> <pre><code>RHA1-00064_2023-07-07_10-47-31\n</code></pre> <p>and contains everything else.</p> <p>In OpenEphys language there are two Record Nodes, \"Record Node 101\" and \"Record Node 104\"</p> <p>Record Node 101 is the one that contains the neural recording data as well as some other stuff.</p> <p>The main path through to the actual recording data is:</p> <pre><code>RHA1-00064_2023-07-07_10-47-31/Record Node 101/experiment1/recording1/continuous/Acquisition_Board-100.Rhythm Data\n</code></pre> <p>In the Acquisition_Board-100.Rhythm Data folder are a bunch of files but most of these are the results of running KiloSort on the acquired data so we'll deal with those later.</p> <p>The main recording file is continuous.dat which is a binary file usually fairly large in size (many 10's of Gbs).</p> <p>This raw binary file is something we can filter in different frequency bands to examine different parts of the activity of the brain. For high frequency spiking activity we can filter the data between about 300-500Hz and  several kHz. For lower frequency local field potential (LFP) activity we can filter the data between about 1-300Hz.</p> <p>The files in the rest of the folders for this Record Node are less relevant for now so we'll ignore them.</p> <p>Record Node 104 contains the tracking data for the animal's position in the arena. The main path to the tracking data is:</p> <pre><code>RHA1-00064_2023-07-07_10-47-31/Record Node 104/experiment1/recording1/continuous/TrackMe-103.TrackingNode\n</code></pre> <p>The main data for the tracking is again in the continuous.dat file but there is also importamnt information in the files here:</p> <pre><code>RHA1-00064_2023-07-07_10-47-31/Record Node 104/experiment1/recording1/events/TrackMe-103.TrackingNode\n</code></pre> <p>This folder contains the TTL events for the tracking data which are important for aligning the tracking data with the neural recording data.</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#loading-the-data","level":2,"title":"Loading the data","text":"","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#getting-started_1","level":3,"title":"Getting started","text":"<ul> <li>To load the data using Python start an ipython session in the terminal:</li> </ul> <pre><code>ipython\n</code></pre> <ul> <li>Then import the relevant bits of the ephysiopy package and a way to tell ephysiopy where the data is:</li> </ul> Load data<pre><code>from ephysiopy.io.recording import OpenEphysBase\nfrom pathlib import Path\n\ndata = Path(\"/path/to/data/RHA1-00064_2023-07-07_10-47-31\")\n\ntrial = OpenEphysBase(data)\n</code></pre> <p>If things are working ok you should see a message saying the settings data has been loaded. This refers to the data in the settings.xml file in the Acquisition_Board-100.Rhythm Data folder. This file contains important information about the recording such as the sampling rate, number of channels etc.</p> <p>Try to load the position data as well:</p> <pre><code>trial.load_pos_data()\n</code></pre> <p>You should see a message saying th TrackMe data has been loaded:</p> <pre><code>Loading TrackMe data...\nLoaded pos data\n</code></pre> <p>There are lots of potential plugins / ways for the position data to be acquired and I've attempted to make it fariyl modular so that it should be possible to load data from different sources. If you have a different setup and the data doesn't load then let me know and I can add support for it.</p> <p>At it's heart, position data for the type of electrophysiology we do is simply a set of x and y coordinates for the position of the animal in the arena at different time points The TrackMe plugin is one way to acquire this data but there are other ways to do it as well. The important thing is that we have a way to align the position data with the neural recording data.</p> <p>This is a critical step and if the data is misaligned you won't be able to come to any conclusions about how they brain is encoding space! Fortunately, ephysiopy takes care of this alignment for you!</p> <p>The next thing to do is load the neural data. This is actually a bit of a misnomer as, in order to be fast, the results of the KiloSort session are loaded rather than the raw data.</p> <p>If we want to plot waveforms i.e. actually index into the raw data file, then we have to load the raw data. For most purposes all we need are the timestamps that a given cluster emitted spikes.</p> <p>Similarly if we want to look at the LFP data then we need to load the raw data and filter it in the relevant frequency band(s). You can do that like so:</p> <pre><code>trial.load_lfp()\n</code></pre> <p>This will take a while as we need to load the data and filter it. For now, all you need to know is that you can call this load_lfp() methods with different frequency bands. We'll come back to this...</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#plotting-data","level":2,"title":"Plotting data","text":"<p>This is where things get a bit more interesting as we can start to see the results of our hard work with some nice pictures.</p> <p>The most straighforward thing to plot is the path of the animal and overlay on top of that the locations at which spikes were emitted.</p> <pre><code>trial.plot_spike_path()\n</code></pre> <p>This will plot the path of the animal over the course of the recording and can be a good check that we tracked the position of the animal well. Bad tracking will appear as distinct and abrupt jumps  in the tracked position, most likely looking like straight lines that go to a common source/ sink. This is often the casued by reflections of the LED(s) on the animals head against some surface.</p> <p>Calling this function with some arguments is more interesting! We need to know valid arguments to call it with though; that is we need to know which channels on our probe (or recording device) had clusters assigned to them by KiloSort. You can find that information by calling get_available_clusters_channels():</p> <pre><code>channels_clusters = trial.get_available_clusters_channels()\n</code></pre> <p>This will return a dictionary where the keys are channels and the values for each key is a list of the clusters assigned to that channel.</p> <pre><code>{7: [8],\n 8: [4, 13, 14, 122],\n 9: [3, 11],\n 10: [9, 10, 142, 143, 180, 186],\n 11: [0, 1, 2, 5, 7, 12, 19, 23, 140, 141, 147, 200],\n ...\n</code></pre> <p>I've truncated the output here but you can see that channel 7 has one cluster (8) while channel 8 has 4 (4, 13, 14, 122).</p> <p>Under the hood the phy library used to pull all this information together actually assigns a cluster to 12 potential channels I just pick out the \"best\" one for succinctness.</p> <p>You can access the underlying functions of the phy library by looking at the functions available to the TemplateModel instance that gets added to our trial object. In an ipython terminal type the following (including the period at the end) and hit Tab to see the list of available functions:</p> <pre><code>trial.template_model.\n</code></pre> <p>You also can see how to call these functions here:</p> <p>https://phy.readthedocs.io/en/latest/api/#phyappstemplatetemplatemodel</p> <p>Now that we know the channels and clusters we have available to us we can plot them out:</p> <pre><code>import matplotlib.pylab as plt\n\ntrial.plot_spike_path(8, 4)\nplt.show()\n</code></pre> <p>It's important to note that the function signature for all of the plot_* and get_* functions is (cluster, channel) which is kind of the other way they are shown to use when we called get_available_clusters_channels().</p> <p>In the plot above, depending on your screen resolution etc, the markers denoting where the cell fired may have appeared too small. To fix that add the markersize argument to the  plotting call:</p> <pre><code>ax = trial.plot_spike_path(8, 4, ms=6)\nplt.show()\n</code></pre> <p>What's happening here is that ms (markersize) is getting passed to the matplotlib plot command (or something similar) and the markers are plotted at a more appropriate size.</p> <p>You can also change the color of the squares with the color argument as well as lots of other stuff. Look at the matplotlib documentation for more details. In most cases the plotting functions return an Axes object that you can manipulate - note sometimes a plotting function may return a handle to the Figure not the Axes - this is especially true when there are multiple sub-plots in the Figure window.</p> <p>We can also plot a more processed version of the data by plotting the firing rate map of the cluster:</p> <pre><code>trial.plot_rate_map(8, 4)\nplt.show()\n</code></pre> <p>This shows where cluster emitted spikes as a heatmap where 'hot' colours are high firing rates and 'cold' colours are low rates (the colormap used is called 'jet' and is awful  for lots of reasons but it's a de facto standard). White areas in the firing rate map are areas the animal didn't / couldn't go to and so have no valid values.</p> <p>Before moving on to the other types of plots we can make it's worthwhile to understand the underlying data of the rate map as this will help you understand how the data is processed and the kinds of arguments you can add/ change in calling functions like plot_rate_map() and the impact they have.</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#the-underlying-data","level":3,"title":"The underlying data","text":"<p>All (op nearly all) of the plot_* (i.e. plot_rate_map(), plot_hd_map() etc) functions have a get_* counterpart (i.e. get_rate_map() etc). The plot functions take what is returned from the get_* functions and simply plot that data (with some bells and whistles added). The object returned from the get_* functions is almost always (CHECK THIS) a BinnedData object.</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#binneddata","level":4,"title":"BinnedData","text":"<p>This is a fairly simple dataclass that encapsulates some variable(s) that has been binned up according to some algorithm. To give a concrete example given the data we've been working with above:</p> <pre><code>data = trial.get_rate_map(8, 4)\n</code></pre> <p>data here is an instance of the BinnedData class. It has several important properties:</p> <ul> <li>cluster_id </li> <li>bin_edges</li> <li>binned_data</li> <li>map_type</li> <li> <p>variable</p> </li> <li> <p>cluster_id is a list containing a namedtuple with fields Cluster and Channel</p> </li> <li>bin_edges is a list of numpy ndarray(s) that contains the bin edges of the binned up data</li> <li>binned_data is a list of numpy masked arrays but of the actual binned up data </li> <li>map_type is an Enum called MapType telling us the type of map we have (i.e. RATE, SPK, POS etc)</li> <li>variable is an Enum called VariableToBin which tells us the variable that has been binned (X, Y, XY, TIME etc)</li> </ul> <p>In the above example we called the get_rate_map() function with only a single cluster (8) and channel (4). It's possible to call the same function but with lists of clusters and channels like so:</p> <pre><code>data = trial.get_rate_map([79, 82], [34, 34])\n</code></pre> <p>Now 'data' contains data for both clusters (79 &amp; 82). Note the map_type, variable and bin_edges values will all be the same (MapType.RATE, VariableToBin.XY and a list of length  2 containing the x and y bin edges). You can't have a situation with a BinnedData instance that has different map_type or variable properties - you need to re-calculate and re-bin the data to do that.</p> <p>There are several methods available to the BinnedData instance that hopefully make data processing a bit easier.</p> <p>When analysing data like this programmatically it's often faster and easier to do all the binning at once and access the processed data after that step. To access an individual cluster from the example above you can call the get_cluster() function:</p> <pre><code>cluster_data = data.get_cluster(ClusterID(79, 34))\n</code></pre> <p>One of the commonly performed analysis steps is to correlate rate maps together to try and get a sense of how similar two maps are to each other. To do that you can call correlate():</p> <pre><code>data.correlate()\narray([0.1179206 , 0.14373477, 0.04730432])\n</code></pre> <p>This is showing the Pearson Product Moment Correlation Coefficent between the pairs of rate maps in data i.e. map1 correlated with map2 and then map3 and map2 correlated with  map3 (so three correlation values in total). You can also get the correlation matrix which is mirror symmetric across the diagonal:</p> <pre><code>data.correlate(as_matrix=True)\narray([[1.        , 0.1179206 , 0.14373477],\n       [0.1179206 , 1.        , 0.04730432],\n       [0.14373477, 0.04730432, 1.        ]])\n</code></pre> <p>You can also correlate one BinnedData instance with another BinnedData instance:</p> <pre><code>data1 = trial.get_rate_map([109,110],[36,36])\ndata.correlate(data1, as_matrix=True)\narray([[ 0.21015777,  0.16216187],\n       [ 0.0269544 , -0.00144629],\n       [ 0.13845497, -0.01680002]])\n</code></pre> <p>The output is hopefully fairly self-explanatory given its shape...</p> <p>You can also add together two BinnedData instances to concatenate them:</p> <pre><code>data2 = data + data1\n</code></pre> <p>data2 will now contain the binned data for clusters 79 &amp; 82 on channel 34 and clusters 109 &amp; 110 on channel 36</p> <p>Now that we know what the BinnedData contains (you don't need to know the underlying implementation bu design) you can understand the different arguments you can supply to the get_* and plot_* functions and the effect they have. If we have linear track data we can bin up data according to only one of the X or Y variables (you can also bin up a PHI variable which is the cartesian distance down the track) and this will give us a 1D rate map:</p> <pre><code>ratemap = trial.get_rate_map(79, 34, var_type=VariableToBin.X)\n</code></pre> <p>Now ratemap.bin_edges will be a list of length 1 containing the x bin edges.</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"field_analysis/","level":1,"title":"Firing field analysis","text":"<p>You can extract various properties of the firing field of a cluster using the  get_field_properties method the TrialInterface class. This method returns a FieldProps object which contains various properties of the firing field of a cluster.</p> <p>The underlying objects are described here:</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.io.recording.TrialInterface.get_field_properties","level":2,"title":"<code>ephysiopy.io.recording.TrialInterface.get_field_properties(cluster: int | list, channel: int | list, **kwargs) -&gt; list[FieldProps]</code>","text":"<p>Gets the properties of a given field (area, runs through the field, etc)</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int | list</code> <p>The cluster(s) to get the field properties for</p> required <code>channel</code> <code>int | list</code> <p>The channel(s) to get the field properties for</p> required <code>**kwargs</code> <p>partition : str     How the field is separated from the background. This is passed to     the fieldproperties function and can be used to specify the partition     to use for the field properties.</p> <pre><code>Valid options are 'simple' and 'fancy'\n\nOther kwargs get passed to get_rate_map and\nfieldprops, the most important of which may be\nhow the runs are split in fieldprops (options are\n'field' and 'clump_runs') which differ depending on\nif the position data is open-field (field) or linear track\nin which case you should probably use 'clunmp_runs'\n</code></pre> <code>{}</code> <p>Returns:</p> Type Description <code>list[FieldProps]</code> <p>A list of FieldProps namedtuples containing the properties of the field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.fieldprops","level":2,"title":"<code>ephysiopy.common.fieldproperties.fieldprops(label_image, binned_data, spike_times, xy, method='field', cache=True, *, extra_properties=None, spacing=None, offset=None, **kwargs)</code>","text":"<p>Measure properties of labeled image regions.</p> <p>Parameters:</p> Name Type Description Default <code>label_image</code> <code>(M, N[, P]) ndarray</code> <p>Labeled input image. Labels with value 0 are ignored.</p> <p>.. versionchanged:: 0.14.1     Previously, <code>label_image</code> was processed by <code>numpy.squeeze</code> and     so any number of singleton dimensions was allowed. This resulted in     inconsistent handling of images with singleton dimensions. To     recover the old behaviour, use     <code>regionprops(np.squeeze(label_image), ...)</code>.</p> required <code>xy</code> <code>(2 x n_samples) np.ndarray</code> <p>The x-y coordinates for all runs through the field corresponding to a particular label</p> required <code>binned_data</code> <code>BinnedData instance from ephysiopy.common.utils</code> required <code>spike_times</code> <code>ndarray</code> <p>The spike times for the neuron being analysed</p> required <code>method</code> <p>Method used to calculate region properties:</p> <ul> <li>'field': Standard method using discrete pixel counts based     on a segmentation of the rate map into labeled regions (fields).     This method     is faster, but can be inaccurate for small regions and will not     work well for positional data that has been masked for direction of     running say (ie linear track)</li> <li>'clump_runs': Exact method which accounts for filtered data better by     looking for contiguous areas of the positional data that are NOT     masked (uses np.ma.clump_unmasked) cache : bool, optional Determine whether to cache calculated properties. The computation is much faster for cached properties, whereas the memory consumption increases.</li> </ul> <code>'field'</code> <code>extra_properties</code> <code>Iterable of callables</code> <p>Add extra property computation functions that are not included with skimage. The name of the property is derived from the function name, the dtype is inferred by calling the function on a small sample. If the name of an extra property clashes with the name of an existing property the extra property will not be visible and a UserWarning is issued. A property computation function must take a region mask as its first argument. If the property requires an intensity image, it must accept the intensity image as the second argument.</p> <code>None</code> <code>spacing</code> <p>The pixel spacing along each axis of the image.</p> <code>None</code> <code>offset</code> <code>array-like of int, shape `(label_image.ndim,)`</code> <p>Coordinates of the origin (\"top-left\" corner) of the label image. Normally this is ([0, ]0, 0), but it might be different if one wants to obtain regionprops of subvolumes within a larger volume.</p> <code>None</code> <code>**kwargs</code> <code>keyword arguments</code> <p>Additional arguments passed to the FieldProps constructor. Legal arguments are:     pos_sample_rate : int     min_run_length : int</p> <p>.. versionadded:: 0.14.1</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>properties</code> <code>list of RegionProperties</code> <p>Each item describes one labeled region, and can be accessed using the attributes listed below.</p> Notes <p>The following properties can be accessed as attributes or keys:</p> <p>area : float     Area of the region i.e. number of pixels of the region scaled     by pixel-area.</p> <p>area_bbox : float     Area of the bounding box i.e. number of pixels of bounding box scaled     by pixel-area.</p> <p>area_convex : float     Area of the convex hull image, which is the smallest convex     polygon that encloses the region.</p> <p>area_filled : float     Area of the region with all the holes filled in.</p> <p>axis_major_length : float     The length of the major axis of the ellipse that has the same     normalized second central moments as the region. axis_minor_length : float     The length of the minor axis of the ellipse that has the same     normalized second central moments as the region. bbox : tuple     Bounding box <code>(min_row, min_col, max_row, max_col)</code>.     Pixels belonging to the bounding box are in the half-open interval     <code>[min_row; max_row)</code> and <code>[min_col; max_col)</code>. centroid : array     Centroid coordinate tuple <code>(row, col)</code>. centroid_local : array     Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding     box. centroid_weighted : array     Centroid coordinate tuple <code>(row, col)</code> weighted with intensity     image. centroid_weighted_local : array     Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding     box, weighted with intensity image. coords_scaled : (K, 2) ndarray     Coordinate list <code>(row, col)</code> of the region scaled by <code>spacing</code>. coords : (K, 2) ndarray     Coordinate list <code>(row, col)</code> of the region. eccentricity : float     Eccentricity of the ellipse that has the same second-moments as the     region. The eccentricity is the ratio of the focal distance     (distance between focal points) over the major axis length.     The value is in the interval [0, 1).     When it is 0, the ellipse becomes a circle. equivalent_diameter_area : float     The diameter of a circle with the same area as the region. euler_number : int     Euler characteristic of the set of non-zero pixels.     Computed as number of connected components subtracted by number of     holes (input.ndim connectivity). In 3D, number of connected     components plus number of holes subtracted by number of tunnels. extent : float     Ratio of pixels in the region to pixels in the total bounding box.     Computed as <code>area / (rows  cols)</code> feret_diameter_max : float     Maximum Feret's diameter computed as the longest distance between     points around a region's convex hull contour as determined by     <code>find_contours</code>. [5]_ image : (H, J) ndarray     Sliced binary region image which has the same size as bounding box. image_convex : (H, J) ndarray     Binary convex hull image which has the same size as bounding box. image_filled : (H, J) ndarray     Binary region image with filled holes which has the same size as     bounding box. image_intensity : ndarray     Image inside region bounding box. inertia_tensor : ndarray     Inertia tensor of the region for the rotation around its mass. inertia_tensor_eigvals : tuple     The eigenvalues of the inertia tensor in decreasing order. intensity_max : float     Value with the greatest intensity in the region. intensity_mean : float     Value with the mean intensity in the region. intensity_min : float     Value with the least intensity in the region. intensity_std : float     Standard deviation of the intensity in the region. label : int     The label in the labeled input image. moments : (3, 3) ndarray     Spatial moments up to 3<sup>rd</sup> order::</p> <pre><code>    m_ij = sum{ array(row, col)  row^i  col^j }\n\nwhere the sum is over the `row`, `col` coordinates of the region.\n</code></pre> <p>moments_central : (3, 3) ndarray     Central moments (translation invariant) up to 3<sup>rd</sup> order::</p> <pre><code>    mu_ij = sum{ array(row, col)  (row - row_c)^i  (col - col_c)^j }\n\nwhere the sum is over the `row`, `col` coordinates of the region,\nand `row_c` and `col_c` are the coordinates of the region's centroid.\n</code></pre> <p>moments_hu : tuple     Hu moments (translation, scale and rotation invariant). moments_normalized : (3, 3) ndarray     Normalized moments (translation and scale invariant) up to 3<sup>rd</sup> order::</p> <pre><code>    nu_ij = mu_ij / m_00^[(i+j)/2 + 1]\n\nwhere `m_00` is the zeroth spatial moment.\n</code></pre> <p>moments_weighted : (3, 3) ndarray     Spatial moments of intensity image up to 3<sup>rd</sup> order::</p> <pre><code>    wm_ij = sum{ array(row, col)  row^i  col^j }\n\nwhere the sum is over the `row`, `col` coordinates of the region.\n</code></pre> <p>moments_weighted_central : (3, 3) ndarray     Central moments (translation invariant) of intensity image up to     3<sup>rd</sup> order::</p> <pre><code>    wmu_ij = sum{ array(row, col)  (row - row_c)^i  (col - col_c)^j }\n\nwhere the sum is over the `row`, `col` coordinates of the region,\nand `row_c` and `col_c` are the coordinates of the region's weighted\ncentroid.\n</code></pre> <p>moments_weighted_hu : tuple     Hu moments (translation, scale and rotation invariant) of intensity     image. moments_weighted_normalized : (3, 3) ndarray     Normalized moments (translation and scale invariant) of intensity     image up to 3<sup>rd</sup> order::</p> <pre><code>    wnu_ij = wmu_ij / wm_00^[(i+j)/2 + 1]\n\nwhere ``wm_00`` is the zeroth spatial moment (intensity-weighted area).\n</code></pre> <p>num_pixels : int     Number of foreground pixels. orientation : float     Angle between the 0<sup>th</sup> axis (rows) and the major     axis of the ellipse that has the same second moments as the region,     ranging from <code>-pi/2</code> to <code>pi/2</code> counter-clockwise. perimeter : float     Perimeter of object which approximates the contour as a line     through the centers of border pixels using a 4-connectivity. perimeter_crofton : float     Perimeter of object approximated by the Crofton formula in 4     directions. slice : tuple of slices     A slice to extract the object from the source image. solidity : float     Ratio of pixels in the region to pixels of the convex hull image.</p> <p>Each region also supports iteration, so that you can do::</p> <p>for prop in region:       print(prop, region[prop])</p> See Also <p>label</p> References <p>.. [1] Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:        Core Algorithms. Springer-Verlag, London, 2009. .. [2] B. Jähne. Digital Image Processing. Springer-Verlag,        Berlin-Heidelberg, 6. edition, 2005. .. [3] T. H. Reiss. Recognizing Planar Objects Using Invariant Image        Features, from Lecture notes in computer science, p. 676. Springer,        Berlin, 1993. .. [4] https://en.wikipedia.org/wiki/Image_moment .. [5] W. Pabst, E. Gregorová. Characterization of particles and particle        systems, pp. 27-28. ICT Prague, 2007.        https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from skimage import data, util\n&gt;&gt;&gt; from skimage.measure import label, regionprops\n&gt;&gt;&gt; img = util.img_as_ubyte(data.coins()) &gt; 110\n&gt;&gt;&gt; label_img = label(img, connectivity=img.ndim)\n&gt;&gt;&gt; props = regionprops(label_img)\n&gt;&gt;&gt; # centroid of first labeled object\n&gt;&gt;&gt; props[0].centroid\n(22.72987986048314, 81.91228523446583)\n&gt;&gt;&gt; # centroid of first labeled object\n&gt;&gt;&gt; props[0]['centroid']\n(22.72987986048314, 81.91228523446583)\n</code></pre> <p>Add custom measurements by passing functions as <code>extra_properties</code></p> <pre><code>&gt;&gt;&gt; from skimage import data, util\n&gt;&gt;&gt; from skimage.measure import label, regionprops\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; img = util.img_as_ubyte(data.coins()) &gt; 110\n&gt;&gt;&gt; label_img = label(img, connectivity=img.ndim)\n&gt;&gt;&gt; def pixelcount(regionmask):\n...     return np.sum(regionmask)\n&gt;&gt;&gt; props = regionprops(label_img, extra_properties=(pixelcount,))\n&gt;&gt;&gt; props[0].pixelcount\n7741\n&gt;&gt;&gt; props[1]['pixelcount']\n42\n</code></pre>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps","level":2,"title":"<code>ephysiopy.common.fieldproperties.FieldProps</code>","text":"<p>               Bases: <code>RegionProperties</code></p> <p>Describes various properties of a receptive field.</p> <p>Attributes:</p> Name Type Description <code>slice</code> <code>tuple of slice</code> <p>The slice of the field in the binned data (x slice, y slice)</p> <code>label</code> <code>int</code> <p>The label of the field</p> <code>image_intensity</code> <code>ndarray</code> <p>The intensity image of the field (in Hz)</p> <code>runs</code> <code>list of RunProps</code> <p>The runs through the field</p> <code>run_slices</code> <code>list of slice</code> <p>The slices of the runs through the field (slices are position indices)</p> <code>run_labels</code> <code>ndarray</code> <p>The labels of the runs</p> <code>max_index</code> <code>ndarray</code> <p>The index of the maximum intensity in the field</p> <code>num_runs</code> <code>int</code> <p>The number of runs through the field</p> <code>cumulative_time</code> <code>list of np.ndarray</code> <p>The cumulative time spent on the field for each run through the field</p> <code>cumulative_distance</code> <code>list of np.ndarray</code> <p>The cumulative time spent on the field for each run through the field</p> <code>runs_speed</code> <code>list of np.ndarray</code> <p>The speed of each run through the field</p> <code>runs_observed_spikes</code> <code>ndarray</code> <p>The observed spikes for each run through the field</p> <code>spike_index</code> <code>ndarray</code> <p>The index of the spikes in the position data</p> <code>xy_at_peak</code> <code>ndarray</code> <p>The x-y coordinate of the field max</p> <code>xy</code> <code>ndarray</code> <p>The x-y coordinates of the field for all runs</p> <code>xy_relative_to_peak</code> <code>ndarray</code> <p>The x-y coordinates of the field zeroed with respect to the peak</p> <code>xy_angle_to_peak</code> <code>ndarray</code> <p>The angle each x-y coordinate makes to the field peak</p> <code>xy_dist_to_peak</code> <code>ndarray</code> <p>The distance of each x-y coordinate to the field peak</p> <code>bw_perim</code> <code>ndarray</code> <p>The perimeter of the field as an array of bool</p> <code>perimeter_coords</code> <code>tuple</code> <p>The x-y coordinates of the field perimeter</p> <code>global_perimeter_coords</code> <code>ndarray</code> <p>The global x-y coordinates of the field perimeter</p> <code>perimeter_minus_field_max</code> <code>ndarray</code> <p>The x-y coordinates of the field perimeter minus the field max</p> <code>perimeter_angle_from_peak</code> <code>ndarray</code> <p>The angle each point on the perimeter makes to the field peak</p> <code>perimeter_dist_from_peak</code> <code>ndarray</code> <p>The distance of each point on the perimeter to the field peak</p> <code>bin_coords</code> <code>ndarray</code> <p>The x-y coordinates of the field in the binned data</p> <code>phi</code> <code>ndarray</code> <p>The angular distance between the mean direction of each run and each position samples direction to the field centre</p> <code>rho</code> <code>ndarray</code> <p>The distance of each position sample to the field max (1 is furthest)</p> <code>pos_xy</code> <code>ndarray</code> <p>The cartesian x-y coordinates of each position sample</p> <code>pos_phi</code> <code>ndarray</code> <p>The angular distance between the mean direction of each run and each position samples direction to the field centre</p> <code>pos_r</code> <code>ndarray</code> <p>The ratio of the distance from the field peak to the position sample and the distance from the field peak to the point on the perimeter that is most colinear with the position sample</p> <code>r_and_phi_to_x_and_y</code> <code>ndarray</code> <p>Converts rho and phi to x and y coordinates</p> <code>r_per_run</code> <code>ndarray</code> <p>The polar radial distance for each run</p> <code>current_direction</code> <code>ndarray</code> <p>The direction projected onto the mean run direction</p> <code>cumulative_distance</code> <code>list of np.ndarray</code> <p>The cumulative distance for each run</p> <code>projected_direction</code> <code>ndarray</code> <p>The direction projected onto the mean run direction</p> <code>intensity_max</code> <code>float</code> <p>The maximum intensity of the field (i.e. field peak rate)</p> <code>intensity_mean</code> <code>float</code> <p>The mean intensity of the field</p> <code>intensity_min</code> <code>float</code> <p>The minimum intensity of the field</p> <code>intensity_std</code> <code>float</code> <p>The standard deviation of the field intensity</p> <p>Methods:</p> Name Description <code>__str__</code> <p>Override the string representation printed to the console</p> <code>mean_spiking_var</code> <p>Get the mean value of a variable at the posiition of</p> <code>overdispersion</code> <p>Calculate the overdispersion for each run through the field</p> <code>runs_expected_spikes</code> <p>Calculate the expected number of spikes along each run given the</p> <code>smooth_runs</code> <p>Smooth in x and y in preparation for converting the smoothed cartesian</p> <code>spiking_var</code> <p>Get the value of a variable at the position of</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.compressed_phase","level":3,"title":"<code>compressed_phase: np.ndarray</code>  <code>property</code>","text":"<p>The phases of the LFP signal for all runs through this field compressed into a single array</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.n_spikes","level":3,"title":"<code>n_spikes: int</code>  <code>property</code>","text":"<p>The total number of spikes emitted on all runs through the field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.normalized_position","level":3,"title":"<code>normalized_position: list</code>  <code>property</code>","text":"<p>Only makes sense to run this on linear track data unless we want to pass the unit circle distance or something...</p> <p>Get the normalized position for each run through the field.</p> <p>Normalized position is the position of the run relative to the start of the field (0) to the end of the field (1).</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.phase","level":3,"title":"<code>phase: list</code>  <code>property</code>","text":"<p>The phases of the LFP signal for all runs through this field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.phi","level":3,"title":"<code>phi: np.ndarray</code>  <code>property</code>","text":"<p>Calculate the angular distance between the mean direction of each run and each position samples direction to the field centre</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.pos_phi","level":3,"title":"<code>pos_phi: np.ndarray</code>  <code>property</code>","text":"<p>Calculate the angular distance between the mean direction of each run and each position samples direction to the field centre</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.pos_r","level":3,"title":"<code>pos_r: np.ndarray</code>  <code>property</code>","text":"<p>Calculate the ratio of the distance from the field peak to the position sample and the distance from the field peak to the point on the perimeter that is most colinear with the position sample</p> <p>NB The values just before being returned can be &gt;= 1 so these are capped to 1</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.projected_direction","level":3,"title":"<code>projected_direction: np.ndarray</code>  <code>property</code>","text":"<p>direction projected onto the mean run direction is just the x-coord when cartesian x and y is converted to from polar rho and phi</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.__str__","level":3,"title":"<code>__str__()</code>","text":"<p>Override the string representation printed to the console</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.mean_spiking_var","level":3,"title":"<code>mean_spiking_var(var='current_direction')</code>","text":"<p>Get the mean value of a variable at the posiition of the spikes for all runs through this field when multiple spikes occur in a single theta cycle</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>the variable to get the mean value of at the position of spikes</p> <code>'current_direction'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the mean value of the variable at the position of spikes for all runs through this field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.overdispersion","level":3,"title":"<code>overdispersion(spikes: np.ndarray, fs: int = 50) -&gt; np.ndarray</code>","text":"<p>Calculate the overdispersion for each run through the field</p> <p>Parameters:</p> Name Type Description Default <code>spike_train</code> <code>ndarray</code> <p>the spike train (spikes binned up by position) for the whole trial. Same length as the trial n_samples</p> required <code>fs</code> <code>int</code> <p>the sample rate of the position data</p> <code>50</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the overdispersion for each run through the field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.runs_expected_spikes","level":3,"title":"<code>runs_expected_spikes(expected_rate: np.ndarray, sample_rate: int = 50) -&gt; np.ndarray</code>","text":"<p>Calculate the expected number of spikes along each run given the whole ratemap.</p> <p>Parameters:</p> Name Type Description Default <code>expected_rate</code> <code>ndarray</code> <p>the rate seen at each xy position of the whole trial</p> required <code>sample_rate</code> <code>int</code> <p>the sample rate of the position data</p> <code>50</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the expected rate at each xy position for each run</p> <p>Examples:</p> <p>The expected spikes should be calculated from the smoothed ratemap and the xy position data using np.digitize:</p> <pre><code>&gt;&gt;&gt; xbins = np.digitize(xy[0], binned_data.bin_edges[1][:-1]) - 1\n&gt;&gt;&gt; ybins = np.digitize(xy[1], binned_data.bin_edges[0][:-1]) - 1\n&gt;&gt;&gt; expected_rate_at_pos = binned_data.binned_data[0][ybins, xbins]\n&gt;&gt;&gt; exptd_spks = fieldprops.runs_expected_spikes(expected_rate_at_pos)\n</code></pre>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.smooth_runs","level":3,"title":"<code>smooth_runs(k: float, spatial_lp_cut: int, sample_rate: int)</code>","text":"<p>Smooth in x and y in preparation for converting the smoothed cartesian coordinates to polar ones</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>float</code> <p>smoothing constant for the instantaneous firing rate</p> required <code>spatial_lp_cut</code> <code>int</code> <p>spatial lowpass cut off</p> required <code>sample_rate</code> <code>int</code> <p>position sample rate in Hz</p> required","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.spiking_var","level":3,"title":"<code>spiking_var(var='current_direction')</code>","text":"<p>Get the value of a variable at the position of spikes for all runs through this field</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>the variable to get the value of at the position of spikes</p> <code>'current_direction'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the value of the variable at the position of spikes for all runs through this field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps","level":2,"title":"<code>ephysiopy.common.fieldproperties.RunProps</code>","text":"<p>               Bases: <code>SpikingProperty</code>, <code>object</code></p> <p>A custom class for holding information about runs through a receptive field</p> <p>Each run needs to have some information about the field to which it belongs so the constructor takes in the peak x-y coordinate of the field and its index as well as the coordinates of the perimeter of the field</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>int</code> <p>the run id</p> <code>slice</code> <code>slice</code> <p>the slice of the position data for a run</p> <code>xy</code> <code>ndarray</code> <p>the x-y coordinates for a run (global coordinates)</p> <code>speed</code> <code>ndarray</code> <p>the speed at each xy coordinate</p> <code>peak_xy</code> <code>tuple[float, float]</code> <p>the fields max rate xy location</p> <code>max_index</code> <code>int</code> <p>the index into the arrays of the field max</p> <code>perimeter_coords</code> <code>ndarray</code> <p>xy coordinates of the field perimeter</p> <code>hdir</code> <code>ndarray</code> <p>the heading direction</p> <code>min_speed</code> <code>float</code> <p>the minimum speed</p> <code>cumulative_time</code> <code>ndarray</code> <p>the cumulative time spent on a run</p> <code>duration</code> <code>float</code> <p>the total duration of a run in seconds</p> <code>n_spikes</code> <code>int</code> <p>the total number of spikes emitted on a run</p> <code>run_start</code> <code>int</code> <p>the position index of the run start</p> <code>run_stop</code> <code>int</code> <p>the position index of the run stop</p> <code>mean_direction</code> <code>float</code> <p>the mean direction of a run</p> <code>current_direction</code> <code>ndarray</code> <p>the current direction of a run</p> <code>cumulative_distance</code> <code>ndarray</code> <p>the cumulative distance covered in a run</p> <code>spike_index</code> <code>ndarray</code> <p>the index into the position data of the spikes on a run</p> <code>observed_spikes</code> <code>ndarray</code> <p>the observed spikes on a run (binned by position samples)</p> <code>xy_angle_to_peak</code> <code>ndarray</code> <p>the xy angle to the peak (radians)</p> <code>xy_dist_to_peak</code> <code>ndarray</code> <p>the distance to the field max</p> <code>xy_dist_to_peak_normed</code> <code>ndarray</code> <p>normalised distance to field max</p> <code>pos_xy</code> <code>ndarray</code> <p>cartesian xy coordinates but normalised on a unit circle</p> <code>pos_phi</code> <code>ndarray</code> <p>the angular distance between a runs main direction and the direction to the peak for each position sample</p> <code>rho</code> <code>ndarray</code> <p>the polar radial distance (1 = field edge)</p> <code>phi</code> <code>ndarray</code> <p>the polar angle (radians)</p> <code>r_and_phi_to_x_and_y</code> <code>ndarray</code> <p>converts rho and phi to x and y coordinates (range = -1 -&gt; +1)</p> <code>tortuosity</code> <code>ndarray</code> <p>the tortuosity for a run (closer to 1 = a straighter run)</p> <code>xy_is_smoothed</code> <code>bool</code> <p>whether the xy data has been smoothed</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Parameters</p> <code>expected_spikes</code> <p>Calculates the expected number of spikes along this run given the</p> <code>mean_spiking_var</code> <p>Get the mean value of a variable at the posiition of</p> <code>overdispersion</code> <p>The overdispersion map for this run</p> <code>smooth_xy</code> <p>Smooth in x and y in preparation for converting the smoothed cartesian</p> <code>spiking_var</code> <p>Get the value of a variable at the position of</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.current_direction","level":3,"title":"<code>current_direction: ma.MaskedArray</code>  <code>property</code>","text":"<p>Supposed to calculate current direction wrt to field centre?</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.ndim","level":3,"title":"<code>ndim</code>  <code>property</code>","text":"<p>Return the dimensionality of the data</p> <p>For 1 x n linear track data dimensionality = 1 for 2 x n open field (or other) data dimensionality = 2</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.normed_x","level":3,"title":"<code>normed_x: np.ndarray</code>  <code>property</code>","text":"<p>Normalise the x data to lie between -1 and 1 with respect to the field limits of the parent field and the run direction such that -1 is entry and +1 is exit</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.phi","level":3,"title":"<code>phi: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 2pi</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.pos_phi","level":3,"title":"<code>pos_phi: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 2pi</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.pos_r","level":3,"title":"<code>pos_r: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 1</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.raw_spike_times","level":3,"title":"<code>raw_spike_times</code>  <code>property</code>","text":"<p>Return the spike times that fall within the slice without masking</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.rho","level":3,"title":"<code>rho: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 1</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.spike_index","level":3,"title":"<code>spike_index: np.ndarray</code>  <code>property</code>","text":"<p>Get the index into the LFP data of the spikes for this segment</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>the index into the LFP data of the spikes for this segment</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.xy_dist_to_peak_normed","level":3,"title":"<code>xy_dist_to_peak_normed: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 1</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.__init__","level":3,"title":"<code>__init__(parent, label: int, slice: slice, spike_times: np.ndarray, mask: np.ndarray, xy_coords: np.ndarray, speed: np.ndarray, peak_xy: np.ndarray, max_index: np.ndarray, perimeter_coords: np.ndarray, sample_rate: float = 50)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>label</code> <code>int</code> <p>the field label the run belongs to</p> required <code>slice</code> <code>slice</code> <p>the slice into the position array that holds all the position data</p> required <code>spike_times</code> <code>ndarray</code> <p>the spike times for this run</p> required <code>xy_coords</code> <code>ndarray</code> <p>the xy data for this run (global coordinates)</p> required <code>hdir</code> <code>ndarray</code> <p>the heading direction for this run</p> required <code>speed</code> <code>ndarray</code> <p>the speed for this run</p> required <code>peak_xy</code> <code>ndarray</code> <p>the peak location of the field for the this run</p> required <code>max_index</code> <code>ndarray</code> <p>the index (r,c) of the maximum of the firing field</p> required <code>perimeter_coords</code> <code>ndarray</code> <p>the xy coordinates of the perimeter of the field</p> required","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.expected_spikes","level":3,"title":"<code>expected_spikes(expected_rate_at_pos: np.ndarray, sample_rate: int = 50) -&gt; np.ndarray</code>","text":"<p>Calculates the expected number of spikes along this run given the whole ratemap.</p> <p>Parameters:</p> Name Type Description Default <code>expected_rate_at_pos</code> <code>ndarray</code> <p>the rate seen at each xy position of the whole trial</p> required <p>Returns:</p> Name Type Description <code>expected_rate</code> <code>ndarray</code> <p>the expected rate at each xy position of this run</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.mean_spiking_var","level":3,"title":"<code>mean_spiking_var(var='current_direction')</code>","text":"<p>Get the mean value of a variable at the posiition of the spikes for all runs through this field when multiple spikes occur in a single theta cycle</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.overdispersion","level":3,"title":"<code>overdispersion(spike_train: np.ndarray, fs: int = 50) -&gt; float</code>","text":"<p>The overdispersion map for this run</p> <p>Parameters:</p> Name Type Description Default <code>spike_train</code> <code>mdarray</code> <p>the spike train (spikes binned up by position) for the whole trial. Same length as the trial n_samples</p> required <code>fs</code> <code>int</code> <p>the sample rate of the position data</p> <code>50</code>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.smooth_xy","level":3,"title":"<code>smooth_xy(k: float, spatial_lp: int, sample_rate: int) -&gt; None</code>","text":"<p>Smooth in x and y in preparation for converting the smoothed cartesian coordinates to polar ones</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>float</code> <p>smoothing constant for the instantaneous firing rate</p> required <code>spatial_lp_cut</code> <code>int</code> <p>spatial lowpass cut off</p> required <code>sample_rate</code> <code>int</code> <p>position sample rate in Hz</p> required","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.spiking_var","level":3,"title":"<code>spiking_var(var='current_direction')</code>","text":"<p>Get the value of a variable at the position of spikes for this run</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment","level":2,"title":"<code>ephysiopy.common.fieldproperties.LFPSegment</code>","text":"<p>               Bases: <code>SpikingProperty</code>, <code>object</code></p> <p>A custom class for dealing with segments of an LFP signal and how they relate to specific runs through a receptive field (see RunProps and FieldProps below)</p> <p>Attributes:</p> Name Type Description <code>field_label</code> <code>int</code> <p>The field id</p> <code>run_label</code> <code>int</code> <p>The run id</p> <code>slice</code> <code>slice</code> <p>slice into the LFP data for a segment</p> <code>spike_times</code> <code>ndarray</code> <p>the times in seconds spikes occurred for a segment</p> <code>spike_count</code> <code>ndarray</code> <p>spikes binned into lfp samples for a segment</p> <code>signal</code> <code>ndarray</code> <p>raw signal for a segment</p> <code>filtered_signal</code> <code>ndarray</code> <p>bandpass filtered signal for a segment</p> <code>phase</code> <code>ndarray</code> <p>phase data for a segment</p> <code>amplitude</code> <code>ndarray</code> <p>amplitude for a segment</p> <code>sample_rate</code> <code>(float, int)</code> <p>sample rate for the LFP segment</p> <code>filter_band</code> <code>tuple[int, int]</code> <p>the bandpass filter values</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Parameters</p> <code>mean_spiking_var</code> <p>Get the mean value of a variable at the posiition of</p> <code>spiking_var</code> <p>Get the value of a variable at the position of</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment.raw_spike_times","level":3,"title":"<code>raw_spike_times</code>  <code>property</code>","text":"<p>Return the spike times that fall within the slice without masking</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment.spike_index","level":3,"title":"<code>spike_index: np.ndarray</code>  <code>property</code>","text":"<p>Get the index into the LFP data of the spikes for this segment</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>the index into the LFP data of the spikes for this segment</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment.__init__","level":3,"title":"<code>__init__(parent, field_label: int, run_label: int, slice: slice, spike_times: np.ndarray, mask: np.ndarray, signal: np.ndarray, filtered_signal: np.ndarray, phase: np.ndarray, cycle_label: np.ndarray, sample_rate: float | int)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>field_label</code> <code>int</code> <p>the field id to which this LFP segment belongs</p> required <code>run_label</code> <code>int</code> <p>the run id through the field to which this LFP segment belongs</p> required <code>slice</code> <code>slice</code> <p>the slice corresponding the pos sample I think</p> required <code>spike_count</code> <code>ndarray</code> <p>spikes binned into lfp samples</p> required <code>signal</code> <code>ndarray</code> <p>the raw, filtered, and phase of the LFP for a given segment</p> required <code>filtered_signal</code> <code>ndarray</code> <p>the raw, filtered, and phase of the LFP for a given segment</p> required <code>phase</code> <code>ndarray</code> <p>the raw, filtered, and phase of the LFP for a given segment</p> required <code>sample_rate</code> <code>(int, float)</code> <p>the sample rate for the LFP signal</p> required <code>filter_band</code> <code>tuple</code> <p>the bandpass filter giving filtered_signal</p> required","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment.mean_spiking_var","level":3,"title":"<code>mean_spiking_var(var='phase')</code>","text":"<p>Get the mean value of a variable at the posiition of the spikes for all runs through this field when multiple spikes occur in a single theta cycle</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment.spiking_var","level":3,"title":"<code>spiking_var(var='phase')</code>","text":"<p>Get the value of a variable at the position of spikes for this run</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"installation/","level":1,"title":"Installation","text":"","path":["User Guide","Installation"],"tags":[]},{"location":"installation/#install-required-packages","level":2,"title":"Install required packages","text":"<ul> <li>uv</li> <li>ephysiopy</li> </ul>","path":["User Guide","Installation"],"tags":[]},{"location":"installation/#install-uv","level":3,"title":"Install uv","text":"<p>https://docs.astral.sh/uv/getting-started/installation/</p>","path":["User Guide","Installation"],"tags":[]},{"location":"installation/#install-ephysiopy","level":3,"title":"Install ephysiopy","text":"<p>This should install all the required packages to load data, plot the results etc</p> <pre><code>uv add ephysiopy\n</code></pre>","path":["User Guide","Installation"],"tags":[]},{"location":"io/","level":1,"title":"Data input/ output","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface","level":2,"title":"<code>ephysiopy.io.recording.TrialInterface</code>","text":"<p>               Bases: <code>FigureMaker</code></p> <p>Defines a minimal and required set of methods for loading electrophysiology data recorded using Axona or OpenEphys (OpenEphysNWB is there but not used)</p> <p>Parameters:</p> Name Type Description Default <code>pname</code> <code>Path</code> required <p>Attributes:</p> Name Type Description <code>pname (str)</code> <code>the absolute pathname of the top-level data directory</code> <code>settings (dict)</code> <code>contains metadata about the trial</code> <code>PosCalcs (PosCalcsGeneric)</code> <code>contains the positional data for the trial</code> <code>RateMap</code> <code>RateMap</code> <p>A class for binning data</p> <code>EEGCalcs</code> <code>EEGCalcs</code> <p>For dealing with LFP data</p> <code>clusterData</code> <code>clusterData</code> <p>contains results of a spike sorting session (i.e. KiloSort)</p> <code>recording_start_time</code> <code>float</code> <p>the start time of the recording in seconds</p> <code>sync_message_file</code> <code>Path</code> <p>the location of the sync_message_file (OpenEphys)</p> <code>ttl_data</code> <code>dict</code> <p>ttl data including timestamps, ids and states</p> <code>accelerometer_data</code> <code>ndarray</code> <p>data relating to headstage accelerometers</p> <code>path2PosData</code> <code>Path</code> <p>location of the positional data</p> <code>mask_array</code> <code>MaskedArray</code> <p>contains the mask (if applied) for positional data</p> <code>filter</code> <code>TrialFilter</code> <p>contains details of the filter applied to the positional data</p> <p>Methods:</p> Name Description <code>load_pos_data</code> <p>Load the position data</p> <code>load_neural_data</code> <p>Load the neural data</p> <code>load_ttl</code> <code>load_cluster_data</code> <p>Load the cluster data (Kilosort/ Axona cut/ whatever else</p> <code>load_settings</code> <p>Loads the format specific settings file</p> <code>apply_filter</code> <p>Apply a mask to the recorded data. This will mask all the currently</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_pos_data","level":3,"title":"<code>load_pos_data(ppm: int = 300, jumpmax: int = 100, *args, **kws)</code>  <code>abstractmethod</code>","text":"<p>Load the position data</p> <p>Parameters:</p> Name Type Description Default <code>ppm</code> <code>int</code> <p>pixels per metre</p> <code>300</code> <code>jumpmax</code> <code>int</code> <p>max jump in pixels between positions, more than this and the position is interpolated over</p> <code>100</code>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_neural_data","level":3,"title":"<code>load_neural_data(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Load the neural data</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_ttl","level":3,"title":"<code>load_ttl(*args, **kwargs) -&gt; bool</code>  <code>abstractmethod</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_cluster_data","level":3,"title":"<code>load_cluster_data(*args, **kwargs) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Load the cluster data (Kilosort/ Axona cut/ whatever else</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_settings","level":3,"title":"<code>load_settings(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Loads the format specific settings file</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.apply_filter","level":3,"title":"<code>apply_filter(*trial_filter: TrialFilter) -&gt; np.ndarray</code>","text":"<p>Apply a mask to the recorded data. This will mask all the currently loaded data (LFP, position etc)</p> <p>Parameters:</p> Name Type Description Default <code>trial_filter</code> <code>TrialFilter</code> <p>A namedtuple containing the filter name, start and end values name (str): The name of the filter start (float): The start value of the filter end (float): The end value of the filter</p> <p>Valid names are:     'dir' - the directional range to filter for         NB Following mathmatical convention, 0/360 degrees is         3 o'clock, 90 degrees is 12 o'clock, 180 degrees is         9 o'clock and 270 degrees     'speed' - min and max speed to filter for     'xrange' - min and max values to filter x pos values     'yrange' - same as xrange but for y pos     'time' - the times to keep / remove specified in ms</p> <p>Values are pairs specifying the range of values to filter for from the namedtuple TrialFilter that has fields 'start' and 'end' where 'start' and 'end' are the ranges to filter for</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of bools that is True where the mask is applied</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase","level":2,"title":"<code>ephysiopy.io.recording.OpenEphysBase</code>","text":"<p>               Bases: <code>TrialInterface</code></p> <p>Methods:</p> Name Description <code>load_pos_data</code> <code>load_neural_data</code> <code>load_ttl</code> <code>load_cluster_data</code> <code>load_settings</code> <p>Load the settings.xml file associated with the recording</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_pos_data","level":3,"title":"<code>load_pos_data(ppm: int = 300, jumpmax: int = 100, *args, **kwargs) -&gt; None</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_neural_data","level":3,"title":"<code>load_neural_data(*args, **kwargs)</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_ttl","level":3,"title":"<code>load_ttl(*args, **kwargs) -&gt; bool</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_cluster_data","level":3,"title":"<code>load_cluster_data(removeNoiseClusters=True, *args, **kwargs) -&gt; bool</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_settings","level":3,"title":"<code>load_settings(*args, **kwargs)</code>","text":"<p>Load the settings.xml file associated with the recording</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial","level":2,"title":"<code>ephysiopy.io.recording.AxonaTrial</code>","text":"<p>               Bases: <code>TrialInterface</code></p> <p>Methods:</p> Name Description <code>load_pos_data</code> <code>load_neural_data</code> <code>load_ttl</code> <code>load_cluster_data</code> <code>load_settings</code>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_pos_data","level":3,"title":"<code>load_pos_data(ppm: int = 300, jumpmax: int = 100, *args, **kwargs) -&gt; None</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_neural_data","level":3,"title":"<code>load_neural_data(*args, **kwargs)</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_ttl","level":3,"title":"<code>load_ttl(*args, **kwargs) -&gt; bool</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_cluster_data","level":3,"title":"<code>load_cluster_data(*args, **kwargs)</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_settings","level":3,"title":"<code>load_settings(*args, **kwargs)</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"lfp/","level":1,"title":"Local field potential (LFP)","text":"","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric","level":2,"title":"<code>ephysiopy.common.ephys_generic.EEGCalcsGeneric</code>","text":"<p>               Bases: <code>object</code></p> <p>Generic class for processing and analysis of EEG data</p> <p>Parameters:</p> Name Type Description Default <code>sig</code> <code>ndarray</code> <p>The signal (of the LFP data)</p> required <code>fs</code> <code>float</code> <p>The sample rate</p> required <p>Methods:</p> Name Description <code>__add__</code> <p>Adds two EEGCalcsGeneric objects together</p> <code>apply_mask</code> <p>Applies a mask to the signal</p> <code>butterFilter</code> <p>Filters self.sig with a butterworth filter with a bandpass filter</p> <code>calcEEGPowerSpectrum</code> <p>Calculates the power spectrum of self.sig</p> <code>ifftFilter</code> <p>Calculates the dft of signal and filters out the frequencies in</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.__add__","level":3,"title":"<code>__add__(other)</code>","text":"<p>Adds two EEGCalcsGeneric objects together</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>EEGCalcsGeneric</code> <p>The other EEGCalcsGeneric object to add</p> required <p>Returns:</p> Type Description <code>EEGCalcsGeneric</code> <p>A new EEGCalcsGeneric object with the combined sig and fs</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.apply_mask","level":3,"title":"<code>apply_mask(mask) -&gt; None</code>","text":"<p>Applies a mask to the signal</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>The mask to be applied. For use with np.ma.MaskedArray's mask attribute</p> required Notes <p>If mask is empty, the mask is removed The mask should be a list of tuples, each tuple containing the start and end times of the mask i.e. [(start1, end1), (start2, end2)] everything inside of these times is masked</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.butterFilter","level":3,"title":"<code>butterFilter(low: float, high: float, order: int = 5) -&gt; np.ndarray</code>","text":"<p>Filters self.sig with a butterworth filter with a bandpass filter defined by low and high</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>float</code> <p>the lower and upper bounds of the bandpass filter</p> required <code>high</code> <code>float</code> <p>the lower and upper bounds of the bandpass filter</p> required <code>order</code> <code>int</code> <p>the order of the filter</p> <code>5</code> <p>Returns:</p> Name Type Description <code>filt</code> <code>ndarray</code> <p>the filtered signal</p> Notes <p>the signal is filtered in both the forward and     reverse directions (scipy.signal.filtfilt)</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.calcEEGPowerSpectrum","level":3,"title":"<code>calcEEGPowerSpectrum(**kwargs)</code>","text":"<p>Calculates the power spectrum of self.sig</p> <p>Returns:</p> Name Type Description <code>psd</code> <code>tuple[ndarray, float, ...]</code> <code>A 5-tuple of the following and sets a bunch of member variables:</code> <code>freqs (array_like): The frequencies at which the spectrogram</code> <code>was calculated</code> <code>power (array_like): The power at the frequencies defined above</code> <code>sm_power (array_like): The smoothed power</code> <code>bandmaxpower (float): The maximum power in the theta band</code> <code>freqatbandmaxpower (float): The frequency at which the power</code> <code>is maximum</code>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.ifftFilter","level":3,"title":"<code>ifftFilter(sig, freqs, fs=250)</code>","text":"<p>Calculates the dft of signal and filters out the frequencies in freqs from the result and reconstructs the original signal using the inverse fft without those frequencies</p> <p>Parameters:</p> Name Type Description Default <code>sig</code> <code>ndarray</code> <p>the LFP signal to be filtered</p> required <code>freqs</code> <code>list</code> <p>the frequencies to be filtered out</p> required <code>fs</code> <code>int</code> <p>the sampling frequency of sig</p> <code>250</code> <p>Returns:</p> Name Type Description <code>fftRes</code> <code>ndarray</code> <p>the filtered LFP signal</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"markdown/","level":1,"title":"Markdown in 5min","text":"","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#headers","level":2,"title":"Headers","text":"<pre><code># H1 Header\n## H2 Header\n### H3 Header\n#### H4 Header\n##### H5 Header\n###### H6 Header\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#text-formatting","level":2,"title":"Text formatting","text":"<pre><code>**bold text**\n*italic text*\n***bold and italic***\n~~strikethrough~~\n`inline code`\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#links-and-images","level":2,"title":"Links and images","text":"<pre><code>[Link text](https://example.com)\n[Link with title](https://example.com \"Hover title\")\n![Alt text](image.jpg)\n![Image with title](image.jpg \"Image title\")\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#lists","level":2,"title":"Lists","text":"<pre><code>Unordered:\n- Item 1\n- Item 2\n  - Nested item\n\nOrdered:\n1. First item\n2. Second item\n3. Third item\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#blockquotes","level":2,"title":"Blockquotes","text":"<pre><code>&gt; This is a blockquote\n&gt; Multiple lines\n&gt;&gt; Nested quote\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#code-blocks","level":2,"title":"Code blocks","text":"<pre><code>```javascript\nfunction hello() {\n  console.log(\"Hello, world!\");\n}\n```\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#tables","level":2,"title":"Tables","text":"<pre><code>| Header 1 | Header 2 | Header 3 |\n|----------|----------|----------|\n| Row 1    | Data     | Data     |\n| Row 2    | Data     | Data     |\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#horizontal-rule","level":2,"title":"Horizontal rule","text":"<pre><code>---\nor\n***\nor\n___\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#task-lists","level":2,"title":"Task lists","text":"<pre><code>- [x] Completed task\n- [ ] Incomplete task\n- [ ] Another task\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#escaping-characters","level":2,"title":"Escaping characters","text":"<pre><code>Use backslash to escape: \\* \\_ \\# \\`\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"markdown/#line-breaks","level":2,"title":"Line breaks","text":"<pre><code>End a line with two spaces  \nto create a line break.\n\nOr use a blank line for a new paragraph.\n</code></pre>","path":["Markdown in 5min"],"tags":[]},{"location":"oe_settings/","level":1,"title":"OpenEphys settings","text":"<p>All of the plugins that sit in the OpenEphys signal chain are parsed out from the settings.xml file and take a similar format. They are available as the 'processors' OrderedDict of the Settings class.</p> <pre><code>trial.settings.processors.keys()\nodict_keys(['Acquisition Board 100', 'Bandpass Filter 107', 'LFP Viewer 102', 'TrackMe 103', 'Tracking Visual 105', 'StimControl 109', 'StimControl 110'])\n</code></pre> <p>The settings for each RecordNode is similarly avaialble as an OrderedDict in the 'record_nodes' attribute:</p> <pre><code>trial.settings.record_nodes.keys()\nodict_keys(['Record Node 101', 'Record Node 104'])\n</code></pre>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#record-nodes","level":2,"title":"Record nodes","text":"<p>The settings for the Record Nodes are saved as a dataclass:</p> <p>The settings for OpenEphys data are saved to a settings.xml file. This is loaded automatically when an OpenEphys trial object is created. Each OpenEphys plugin derives from the OEPlugin dataclass:</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.RecordNode","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.RecordNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the RecordNode plugin.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>str</code> <p>The file path associated with the RecordNode.</p> <code>engine</code> <code>str</code> <p>The engine used by the RecordNode.</p> <code>recordEvents</code> <code>IntConversion</code> <p>Indicates if events are recorded, converted from a string.</p> <code>recordSpikes</code> <code>IntConversion</code> <p>Indicates if spikes are recorded, converted from a string.</p> <code>isMainStream</code> <code>IntConversion</code> <p>Indicates if this is the main stream, converted from a string.</p> <code>sync_line</code> <code>IntConversion</code> <p>The sync line, converted from a string.</p> <code>source_node_id</code> <code>IntConversion</code> <p>The source node ID, converted from a string.</p> <code>recording_state</code> <code>str</code> <p>The recording state of the RecordNode.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#openephys-plugins","level":2,"title":"OpenEphys plugins","text":"<p>It should be straightforawrd to create new classes that derive from OEPlugin when new plugins become available.</p> <p>There are some helper classes for doing string to int and float conversions:</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.OEPlugin","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.OEPlugin</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Documents an OE plugin.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the plugin.</p> <code>insertionPoint</code> <code>IntConversion</code> <p>The insertion point of the plugin, converted from a string.</p> <code>pluginName</code> <code>str</code> <p>The name of the plugin.</p> <code>type</code> <code>IntConversion</code> <p>The type of the plugin, converted from a string.</p> <code>index</code> <code>IntConversion</code> <p>The index of the plugin, converted from a string.</p> <code>libraryName</code> <code>str</code> <p>The name of the library.</p> <code>libraryVersion</code> <code>str</code> <p>The version of the library.</p> <code>processorType</code> <code>IntConversion</code> <p>The type of processor, converted from a string.</p> <code>nodeId</code> <code>IntConversion</code> <p>The node ID, converted from a string.</p> <code>channel_count</code> <code>IntConversion</code> <p>The number of channels, converted from a string.</p> <code>stream</code> <code>Stream</code> <p>The data stream associated with the plugin.</p> <code>sample_rate</code> <code>FloatConversion</code> <p>The sample rate, converted from a string.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.RhythmFPGA","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.RhythmFPGA</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Rhythm FPGA plugin.</p> <p>Attributes:</p> Name Type Description <code>channel_info</code> <code>list of Channel</code> <p>A list containing information about each channel.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.NeuropixPXI","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.NeuropixPXI</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Neuropixels-PXI plugin.</p> <p>Attributes:</p> Name Type Description <code>channel_info</code> <code>list of Channel</code> <p>A list containing information about each channel.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.AcquisitionBoard","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.AcquisitionBoard</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Acquisition Board plugin</p> <p>Attributes:</p> Name Type Description <code>LowCut</code> <code>FloatConversion</code> <p>The low cut-off frequency for the acquisition board.</p> <code>HighCut</code> <code>FloatConversion</code> <p>The high cut-off frequency for the acquisition board.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.BandpassFilter","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.BandpassFilter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Bandpass Filter plugin</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the plugin.</p> <code>pluginName</code> <code>str</code> <p>The display name of the plugin.</p> <code>pluginType</code> <code>int</code> <p>The type identifier for the plugin.</p> <code>libraryName</code> <code>str</code> <p>The library name of the plugin.</p> <code>channels</code> <code>list of int</code> <p>The list of channels to which the filter is applied.</p> <code>low_cut</code> <code>FloatConversion</code> <p>The low cut-off frequency for the bandpass filter.</p> <code>high_cut</code> <code>FloatConversion</code> <p>The high cut-off frequency for the bandpass filter.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackingPort","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.TrackingPort</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Tracking Port plugin which uses Bonsai input and Tracking Visual plugin for visualisation within OE</p> <p>Methods:</p> Name Description <code>load</code> <p>Load Tracking Port data from a specified path.</p> <code>load_times</code> <p>Load timestamps from a specified path.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackingPort.load","level":3,"title":"<code>load(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load Tracking Port data from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 2D numpy array with the position data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackingPort.load_times","level":3,"title":"<code>load_times(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load timestamps from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the timestamps file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the timestamps.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.PosTracker","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.PosTracker</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the PosTracker plugin.</p> <p>Attributes:</p> Name Type Description <code>Brightness</code> <code>IntConversion</code> <p>Brightness setting for the tracker, default is 20.</p> <code>Contrast</code> <code>IntConversion</code> <p>Contrast setting for the tracker, default is 20.</p> <code>Exposure</code> <code>IntConversion</code> <p>Exposure setting for the tracker, default is 20.</p> <code>LeftBorder</code> <code>IntConversion</code> <p>Left border setting for the tracker, default is 0.</p> <code>RightBorder</code> <code>IntConversion</code> <p>Right border setting for the tracker, default is 800.</p> <code>TopBorder</code> <code>IntConversion</code> <p>Top border setting for the tracker, default is 0.</p> <code>BottomBorder</code> <code>IntConversion</code> <p>Bottom border setting for the tracker, default is 600.</p> <code>AutoExposure</code> <code>bool</code> <p>Auto exposure setting for the tracker, default is False.</p> <code>OverlayPath</code> <code>bool</code> <p>Overlay path setting for the tracker, default is False.</p> <code>sample_rate</code> <code>IntConversion</code> <p>Sample rate setting for the tracker, default is 30.</p> <p>Methods:</p> Name Description <code>load</code> <p>Load Tracking Port data from a specified path.</p> <code>load_times</code> <p>Load timestamps from a specified path.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.PosTracker.load","level":3,"title":"<code>load(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load Tracking Port data from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 2D numpy array with the position data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.PosTracker.load_times","level":3,"title":"<code>load_times(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load timestamps from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the timestamps file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the timestamps.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.TrackMe</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the TrackMe plugin.</p> <p>Methods:</p> Name Description <code>load</code> <p>Load TrackMe data from a specified path.</p> <code>load_times</code> <p>Load timestamps from a specified path.</p> <code>load_frame_count</code> <p>Load frame count data from a specified path.</p> <code>load_ttl_times</code> <p>Load TTL times from a specified path.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe.load","level":3,"title":"<code>load(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load TrackMe data from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 2D numpy array with the TrackMe data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe.load_frame_count","level":3,"title":"<code>load_frame_count(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load frame count data from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the frame count data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe.load_times","level":3,"title":"<code>load_times(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load timestamps from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the timestamps file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the timestamps.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe.load_ttl_times","level":3,"title":"<code>load_ttl_times(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load TTL times from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the timestamps and states files.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the TTL times.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.StimControl","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.StimControl</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the StimControl plugin.</p> <p>Attributes:</p> Name Type Description <code>Device</code> <code>IntConversion</code> <p>Device setting for the StimControl, default is 0.</p> <code>Duration</code> <code>IntConversion</code> <p>Duration setting for the StimControl, default is 0.</p> <code>Interval</code> <code>IntConversion</code> <p>Interval setting for the StimControl, default is 0.</p> <code>Gate</code> <code>IntConversion</code> <p>Gate setting for the StimControl, default is 0.</p> <code>Output</code> <code>IntConversion</code> <p>Output setting for the StimControl, default is 0.</p> <code>Start</code> <code>IntConversion</code> <p>Start setting for the StimControl, default is 0.</p> <code>Stop</code> <code>IntConversion</code> <p>Stop setting for the StimControl, default is 0.</p> <code>Trigger</code> <code>IntConversion</code> <p>Trigger setting for the StimControl, default is 0.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.RippleDetector","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.RippleDetector</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Ripple Detector plugin.</p> <p>Attributes:</p> Name Type Description <code>Ripple_Input</code> <code>IntConversion</code> <p>Input setting for the Ripple Detector, default is -1.</p> <code>Ripple_Out</code> <code>IntConversion</code> <p>Output setting for the Ripple Detector, default is -1.</p> <code>Ripple_save</code> <code>IntConversion</code> <p>Save setting for the Ripple Detector, default is -1.</p> <code>ripple_std</code> <code>FloatConversion</code> <p>Standard deviation setting for the Ripple Detector, default is -1.</p> <code>time_thresh</code> <code>FloatConversion</code> <p>Time threshold setting for the Ripple Detector, default is -1.</p> <code>refr_time</code> <code>FloatConversion</code> <p>Refractory time setting for the Ripple Detector, default is -1.</p> <code>rms_samples</code> <code>FloatConversion</code> <p>RMS samples setting for the Ripple Detector, default is -1.</p> <code>ttl_duration</code> <code>FloatConversion</code> <p>TTL duration setting for the Ripple Detector, default is -1.</p> <code>ttl_percent</code> <code>FloatConversion</code> <p>TTL percent setting for the Ripple Detector, default is -1.</p> <code>mov_detect</code> <code>IntConversion</code> <p>Movement detection setting for the Ripple Detector, default is -1.</p> <code>mov_input</code> <code>IntConversion</code> <p>Movement input setting for the Ripple Detector, default is -1.</p> <code>mov_out</code> <code>IntConversion</code> <p>Movement output setting for the Ripple Detector, default is -1.</p> <code>mov_std</code> <code>FloatConversion</code> <p>Movement standard deviation setting for the Ripple Detector, default is -1.</p> <code>min_time_st</code> <code>FloatConversion</code> <p>Minimum time setting for the Ripple Detector, default is -1.</p> <code>min_time_mov</code> <code>FloatConversion</code> <p>Minimum movement time setting for the Ripple Detector, default is -1.</p> <p>Methods:</p> Name Description <code>load_ttl</code> <p>Load TTL data from a specified path and trial start time.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.RippleDetector.load_ttl","level":3,"title":"<code>load_ttl(path2TTL: Path, trial_start_time: float) -&gt; dict</code>","text":"<p>Load TTL data from a specified path and trial start time.</p> <p>Parameters:</p> Name Type Description Default <code>path2TTL</code> <code>Path</code> <p>The path to the directory containing the TTL data files.</p> required <code>trial_start_time</code> <code>float</code> <p>The start time of the trial.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the TTL timestamps and other related data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.IntConversion","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.IntConversion</code>","text":"<p>Descriptor class for converting attribute values to integers.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>int</code> <p>The default value to return if the attribute is not set.</p> required <p>Methods:</p> Name Description <code>__set_name__</code> <p>Sets the internal name for the attribute.</p> <code>__get__</code> <p>Retrieves the attribute value, returning the default if not set.</p> <code>__set__</code> <p>Sets the attribute value, converting it to an integer.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.IntConversion.__get__","level":3,"title":"<code>__get__(obj, type)</code>","text":"<p>Retrieve the attribute value.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The instance of the owner class.</p> required <code>type</code> <code>type</code> <p>The owner class type.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The attribute value or the default value if not set.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.IntConversion.__init__","level":3,"title":"<code>__init__(*, default)</code>","text":"<p>Initialize the IntConversion descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>int</code> <p>The default value to return if the attribute is not set.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.IntConversion.__set__","level":3,"title":"<code>__set__(obj, value)</code>","text":"<p>Set the attribute value, converting it to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The instance of the owner class.</p> required <code>value</code> <code>any</code> <p>The value to set, which will be converted to an integer.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.IntConversion.__set_name__","level":3,"title":"<code>__set_name__(owner, name)</code>","text":"<p>Set the internal name for the attribute.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>type</code> <p>The owner class where the descriptor is defined.</p> required <code>name</code> <code>str</code> <p>The name of the attribute.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.FloatConversion","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.FloatConversion</code>","text":"<p>Descriptor class for converting attribute values to floats.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>float</code> <p>The default value to return if the attribute is not set.</p> required <p>Methods:</p> Name Description <code>__set_name__</code> <p>Sets the internal name for the attribute.</p> <code>__get__</code> <p>Retrieves the attribute value, returning the default if not set.</p> <code>__set__</code> <p>Sets the attribute value, converting it to a float.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.FloatConversion.__get__","level":3,"title":"<code>__get__(obj, type)</code>","text":"<p>Retrieve the attribute value.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The instance of the owner class.</p> required <code>type</code> <code>type</code> <p>The owner class type.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The attribute value or the default value if not set.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.FloatConversion.__init__","level":3,"title":"<code>__init__(*, default)</code>","text":"<p>Initialize the FloatConversion descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>float</code> <p>The default value to return if the attribute is not set.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.FloatConversion.__set__","level":3,"title":"<code>__set__(obj, value)</code>","text":"<p>Set the attribute value, converting it to a float.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The instance of the owner class.</p> required <code>value</code> <code>any</code> <p>The value to set, which will be converted to a float.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.FloatConversion.__set_name__","level":3,"title":"<code>__set_name__(owner, name)</code>","text":"<p>Set the internal name for the attribute.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>type</code> <p>The owner class where the descriptor is defined.</p> required <code>name</code> <code>str</code> <p>The name of the attribute.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"plotting/","level":1,"title":"Plotting functions","text":"<p>All of these plotting functions are part of a mixin class that is available to OpenEphysBase and AxonaTrial via the base class TrialInterface.</p> <ul> <li>plot_speed_v_rate         - plot_power_spectrum         - plot_theta_vs_running_speed         - plot_clusters_theta_phase         - plot_waveforms         - plotSpectrogramByDepth       show_root_heading: true</li> </ul>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker","level":2,"title":"<code>ephysiopy.visualise.plotting.FigureMaker</code>","text":"<p>               Bases: <code>object</code></p> <p>A mixin class for TrialInterface that deals solely with producing graphical output.</p> <p>Methods:</p> Name Description <code>plot_spike_path</code> <p>Plots the spikes on the path for the specified cluster(s) and channel.</p> <code>plot_rate_map</code> <p>Plots the rate map for the specified cluster(s) and channel.</p> <code>plot_hd_map</code> <p>Gets the head direction map for the specified cluster(s) and channel.</p> <code>plot_linear_rate_map</code> <p>Plots the linear rate map for the specified cluster(s) and channel.</p> <code>plot_eb_spikes</code> <p>Plots the ego-centric boundary spikes for the specified cluster(s)</p> <code>plot_eb_map</code> <p>Plots the ego-centric boundary map for the specified cluster(s) and</p> <code>plot_acorr</code> <p>Plots the autocorrelogram for the specified cluster(s) and channel.</p> <code>plot_xcorr</code> <p>Plots the temporal cross-correlogram between cluster_a and cluster_b</p> <code>plot_sac</code> <p>Plots the spatial autocorrelation for the specified cluster(s) and channel.</p> <code>plot_speed_v_hd</code> <p>Plots the speed versus head direction plot for the specified cluster(s) and channel.</p> <code>plot_raster</code> <p>Plots the raster plot for the specified cluster(s) and channel.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_spike_path","level":3,"title":"<code>plot_spike_path(cluster=None, channel=None, **kws) -&gt; plt.Axes</code>","text":"<p>Plots the spikes on the path for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int or None</code> <p>The cluster(s) to get the spike path for.</p> <code>None</code> <code>channel</code> <code>int or None</code> <p>The channel number.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> required <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the spike path plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_rate_map","level":3,"title":"<code>plot_rate_map(cluster: int | list, channel: int | list, **kwargs) -&gt; plt.Figure</code>","text":"<p>Plots the rate map for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int or list</code> <p>The cluster(s) to get the rate map for.</p> required <code>channel</code> <code>int or list</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function. ax : plt.Axes, optional     The axes to plot on. If None, new axes are created. separate_plots : bool, optional     If True, each cluster will be plotted on a separate plot.     Defaults to False.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the rate map plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_hd_map","level":3,"title":"<code>plot_hd_map(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Gets the head direction map for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the head direction map for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the head direction map plot.</p> Notes <p>NB Following mathmatical convention, 0/360 degrees is 3 o'clock, 90 degrees is 12 o'clock, 180 degrees is 9 o'clock and 270 degrees</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_linear_rate_map","level":3,"title":"<code>plot_linear_rate_map(cluster: int | list, channel: int | list, **kwargs) -&gt; plt.Figure</code>","text":"<p>Plots the linear rate map for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int or list</code> <p>The cluster(s) to get the linear rate map for.</p> required <code>channel</code> <code>int or list</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the linear rate map plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_eb_spikes","level":3,"title":"<code>plot_eb_spikes(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the ego-centric boundary spikes for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the ego-centric boundary spikes for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the ego-centric boundary spikes plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_eb_map","level":3,"title":"<code>plot_eb_map(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the ego-centric boundary map for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the ego-centric boundary map for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the ego-centric boundary map plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_acorr","level":3,"title":"<code>plot_acorr(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the autocorrelogram for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the autocorrelogram for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function, including: binsize : int, optional     The size of the bins in ms.     Gets passed to SpikeCalcsGeneric.xcorr().     Defaults to 1.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the autocorrelogram plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_xcorr","level":3,"title":"<code>plot_xcorr(cluster_a: int, channel_a: int, cluster_b: int, channel_b: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the temporal cross-correlogram between cluster_a and cluster_b</p> <p>Parameters:</p> Name Type Description Default <code>cluster_a</code> <code>int</code> <p>first cluster</p> required <code>channel_a</code> <code>int</code> <p>first channel</p> required <code>cluster_b</code> <code>int</code> <p>second cluster</p> required <code>channel_b</code> <code>int</code> <p>second channel</p> required <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the cross-correlogram plot</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_sac","level":3,"title":"<code>plot_sac(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the spatial autocorrelation for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the spatial autocorrelation for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the spatial autocorrelation plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_speed_v_hd","level":3,"title":"<code>plot_speed_v_hd(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the speed versus head direction plot for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the speed versus head direction plot for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the speed versus head direction plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_raster","level":3,"title":"<code>plot_raster(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the raster plot for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the raster plot for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function, including: dt : list     The range in seconds to plot data over either side of the TTL pulse. seconds_per_bin : float     The number of seconds per bin.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the raster plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"position/","level":1,"title":"Position data","text":"","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric","level":2,"title":"<code>ephysiopy.common.ephys_generic.PosCalcsGeneric</code>","text":"<p>               Bases: <code>object</code></p> <p>Generic class for post-processing of position data Uses numpys masked arrays for dealing with bad positions, filtering etc</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>the x and y positions</p> required <code>y</code> <code>ndarray</code> <p>the x and y positions</p> required <code>ppm</code> <code>int</code> <p>Pixels per metre</p> required <code>convert2cm</code> <code>bool</code> <p>Whether everything is converted into cms or not</p> <code>True</code> <code>jumpmax</code> <code>int</code> <p>Jumps in position (pixel coords) &gt; than this are bad</p> <code>100</code> <code>**kwargs</code> <p>a dict[str, float] called 'tracker_params' is used to limit the range of valid xy positions - 'bad' positions are masked out and interpolated over</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>orig_xy</code> <code>ndarray</code> <p>the original xy coordinates, never modified directly</p> <code>npos</code> <code>int</code> <p>the number of position samples</p> <code>xy</code> <code>ndarray</code> <p>2 x npos array</p> <code>convert2cm</code> <code>bool</code> <p>whether to convert the xy position data to cms or not</p> <code>duration</code> <code>float</code> <p>the trial duration in seconds</p> <code>xyTS</code> <code>ndarray</code> <p>the timestamps the position data was recorded at. npos long vector</p> <code>dir</code> <code>ndarray</code> <p>the directional data. In degrees</p> <code>ppm</code> <code>float</code> <p>the number of pixels per metre</p> <code>jumpmax</code> <code>float</code> <p>the minimum jump between consecutive positions before a jump is considered 'bad' and smoothed over</p> <code>speed</code> <code>ndarray</code> <p>the speed data, extracted from a difference of xy positions. npos long vector</p> <code>sample_rate</code> <code>int</code> <p>the sample rate of the position data</p> Notes <p>The positional data (x,y) is turned into a numpy masked array once this class is initialised - that mask is then modified through various functions (postprocesspos being the main one).</p> <p>Methods:</p> Name Description <code>__add__</code> <p>Adds two PosCalcsGeneric objects together</p> <code>apply_mask</code> <p>Applies a mask to the position data</p> <code>calcHeadDirection</code> <p>Calculates the head direction from the xy data</p> <code>calcPhi</code> <p>Calculates phi, distance along a linear track</p> <code>calcSpeed</code> <p>Calculates speed</p> <code>interpnans</code> <p>Interpolates over bad values in the xy data</p> <code>postprocesspos</code> <p>Post-process position data</p> <code>smoothPos</code> <p>Smooths position data</p> <code>smooth_speed</code> <p>Smooth speed data with a window a little bit bigger than the usual</p> <code>speedfilter</code> <p>Filters speed</p> <code>upsamplePos</code> <p>Upsamples position data from 30 to upsample_rate</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.__add__","level":3,"title":"<code>__add__(other)</code>","text":"<p>Adds two PosCalcsGeneric objects together</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PosCalcsGeneric</code> <p>The other PosCalcsGeneric object to add</p> required <p>Returns:</p> Type Description <code>PosCalcsGeneric</code> <p>A new PosCalcsGeneric object with the combined xy data</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.apply_mask","level":3,"title":"<code>apply_mask(mask: np.ndarray)</code>","text":"<p>Applies a mask to the position data</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>The mask to be applied.</p> required Notes <p>If mask is empty, the mask is removed The mask should be a list of tuples, each tuple containing the start and end times of the mask i.e. [(start1, end1), (start2, end2)] everything inside of these times is masked</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.calcHeadDirection","level":3,"title":"<code>calcHeadDirection(xy: np.ma.MaskedArray) -&gt; np.ma.MaskedArray</code>","text":"<p>Calculates the head direction from the xy data</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy data</p> required <p>Returns:</p> Type Description <code>MaskedArray</code> <p>The head direction data</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.calcPhi","level":3,"title":"<code>calcPhi(xy: np.ma.MaskedArray)</code>","text":"<p>Calculates phi, distance along a linear track</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy positional data</p> required","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.calcSpeed","level":3,"title":"<code>calcSpeed(xy: np.ma.MaskedArray)</code>","text":"<p>Calculates speed</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy positional data</p> required","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.interpnans","level":3,"title":"<code>interpnans(xy: np.ma.MaskedArray) -&gt; np.ma.MaskedArray</code>","text":"<p>Interpolates over bad values in the xy data</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> required <p>Returns:</p> Type Description <code>MaskedArray</code> <p>The interpolated xy data</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.postprocesspos","level":3,"title":"<code>postprocesspos(tracker_params: dict[str, float] = {})</code>","text":"<p>Post-process position data</p> <p>Parameters:</p> Name Type Description Default <code>tracker_params</code> <code>dict</code> <p>Same dict as created in OESettings.Settings.parse (from module openephys2py)</p> <code>{}</code> Notes <p>Several internal functions are called here: speedfilter, interpnans, smoothPos and calcSpeed. Some internal state/ instance variables are set as well. The mask of the positional data (an instance of numpy masked array) is modified throughout this method.</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.smoothPos","level":3,"title":"<code>smoothPos(xy: np.ma.MaskedArray, **kwargs) -&gt; np.ma.MaskedArray</code>","text":"<p>Smooths position data</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy data</p> required <code>**kwargs</code> <p>window_len : int     The length of the smoothing window</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>xy</code> <code>array_like</code> <p>The smoothed positional data</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.smooth_speed","level":3,"title":"<code>smooth_speed(speed: np.ma.MaskedArray, window_len: int = 21)</code>","text":"<p>Smooth speed data with a window a little bit bigger than the usual 400ms window used for smoothing position data</p> <p>NB Uses a box car filter as with Axona</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.speedfilter","level":3,"title":"<code>speedfilter(xy: np.ma.MaskedArray)</code>","text":"<p>Filters speed</p> <p>Args:     xy (np.ma.MaskedArray): The xy data</p> <p>Returns:     xy (np.ma.MaskedArray): The xy data with speeds &gt;     self.jumpmax masked</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.upsamplePos","level":3,"title":"<code>upsamplePos(xy: np.ma.MaskedArray, upsample_rate: int = 50)</code>","text":"<p>Upsamples position data from 30 to upsample_rate</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy positional data</p> required <code>upsample_rate</code> <code>int</code> <p>The rate to upsample to</p> <code>50</code> <p>Returns:</p> Type Description <code>MaskedArray</code> <p>The upsampled xy positional data</p> Notes <p>This is mostly to get pos data recorded using PosTracker at 30Hz into Axona format 50Hz data</p>","path":["API reference","Position data"],"tags":[]},{"location":"quickstart/","level":1,"title":"Quickstart guide","text":"<p>From an ipython terminal, you can load some Axona data as follows:</p> Load data<pre><code>from ephysiopy.io.recording import AxonaTrial\nfrom pathlib import Path\n\ndata = Path(\"/path/to/data/M851_140908t2rh.set\")\n\ntrial = AxonaTrial(data)\n</code></pre> <p>Note</p> <p>The path should point to the .set file for the recording trial files</p> <p>Similarly, to load data recorded using OpenEphys:</p> Load data<pre><code>from ephysiopy.io.recording import OpenEphysBase\nfrom pathlib import Path\n\ndata = Path(\"/path/to/data/RHA1-00064_2023-07-07_10-47-31\")\n\ntrial = OpenEphysBase(data)\n</code></pre> <p>Note</p> <p>The path should point to the top level folder containing the OpenEphys data</p> <p>In both cases, the trial object is the main interface for working with data.</p> <p>Plot the rate map for cluster 1 on channel 2:</p> Plot data<pre><code>import matplotlib.pylab as plt\n\ntrial.plot_rate_map(1, 2)\nplt.show()\n</code></pre> <p></p>","path":["User Guide","Quickstart guide"],"tags":[]},{"location":"usage/","level":1,"title":"Further usage","text":"<p>First, load some data:</p> <pre><code>from ephysiopy.io.recording import AxonaTrial\nfrom pathlib import Path\n\ndata = Path(\"/path/to/data/M851_140908t2rh.set\")\n\ntrial = AxonaTrial(data)\n</code></pre>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#trial-settings","level":2,"title":"Trial settings","text":"<p>At this point the only data that has been loaded is the settings data. For Axona data this consists of the key - value pairs in the .set file, essentially the  state machine of the recording. Because of it's simple structure this is stored as a standard python dictionary</p> <pre><code>type(trial.settings)\ndict\n</code></pre> <p>Because of the more flexible/ complex design of the OpenEphys plugin-GUI this settings data is stored as it's own class:</p> <pre><code>from ephysiopy.io.recording import OpenEphysBase\n\ndata = Path(\"/path/to/data/RHA1-00064_2023-07-07_10-47-31\")\n\ntrial = OpenEphysBase(data)\n\ntype(trial.settings)\nephysiopy.openephys2py.OESettings.Settings\n</code></pre> <p>See OEPlugins for more details</p> <p>You won't need to interact with the settings directly for most if not all analyses; the relevant bits are extracted and used in loading/ processing of other data.</p>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#position-data","level":2,"title":"Position data","text":"<p>Regardless of the data source, position data is stored in the PosCalcsGeneric class:</p> <pre><code>trial.load_pos_data()\nLoaded pos data\n\ntype(trial.PosCalcs)\nephysiopy.common.ephys_generic.PosCalcsGeneric\n</code></pre> <p>There are several arguments you can add to the load_pos_data function to control how the position data is treated. An important one is 'ppm' which stads for pixels_per_metre. It specifies how many pixels in camera units correspond to one metre. This is something you should measure experimentally and record somewhere. The number is used to convert the position data to real world units. If you don't specify it, the ppm value will take a default value of 300 (CHECK)</p> <pre><code>trial.load_pos_data(ppm=800)\nLoaded pos data\n</code></pre> <p>Other important arguments are jumpmax and cm. Jumpmax is the maximum distance that the animal can move between two frames. If the distance between two frames is greater than this value, the position data for that frame will be interpolated over. This is useful for removing artefacts in the position data caused by tracking errors. The default value is 100 pixels. 'cm' is a boolean that specifies whether the position data should be converted to centimetres. The default value is False, which means that the position data will be in metres.</p> <p>Once loaded the PosCalcs attribute has several attributes itself like 'xy' and 'dir' which are the x and y position and the head direction.</p> <p>You shouldn't need to interact with the PosCalcs class directly for most analyses, but it's there if you need it.</p> <p>The position data is used in several of the plotting functions and in the rate map calculations.</p> <pre><code>import matplotlib.pylab as plt\n\ntrial.plot_spike_path()\nplt.show()\n</code></pre> <p></p>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#spiking-data","level":2,"title":"Spiking data","text":"<p>We can get the spike times in seconds at which a cluster fired:</p> Spike times for cluster 2 on channel 3<pre><code>trial.get_spike_times(2, 3)\nmasked_array(data=[0.7710416666666666, 4.6870416666666666,\n                   4.693291666666667, ..., 2394.8471458333333,\n                   2394.8537291666667, 2394.860708333333],\n             mask=[False, False, False, ..., False, False, False],\n       fill_value=1e+20)\n</code></pre> <p>Note</p> <p>The spike times are returned as a masked numpy array. It is possible to filter a trial for various things like speed, time, position etc. Many of the arrays returned from functions like this are masked to  reflect such filtering i.e. spikes that occurred when the animal ran below a speed threshold will be masked (mask value will be True)</p> <p>You can plot the position at which spikes were emitted for a specific cluster on top of the path:</p> Cluster 2 on channel 3<pre><code>trial.plot_spike_path(2, 3)\nplt.show()\n</code></pre> <p></p> <p>And the corresponding rate map:</p> Rate map for cluster 2 on channel 3<pre><code>trial.plot_rate_map(2, 3)\nplt.show()\n</code></pre> <p></p> <p>You can access the underlying data for the rate map as well:</p> Rate map data for cluster 2 on channel 3<pre><code>trial.get_rate_map(2, 3)\n\nBinnedData(variable=&lt;VariableToBin.XY: 1&gt;, map_type=&lt;MapType.RATE: 1&gt;, binned_data=[masked_array(\n...\n</code></pre> <p>Read more about the BinnedData class in the API docs BinnedData class and a more verbose description here</p>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#local-field-potential-lfp-data","level":2,"title":"Local field potential (LFP) data","text":"<p>Load the LFP data like so:</p> <pre><code>trial.load_lfp()\n</code></pre> <p>This can take a while especially if the trial is long and recorded using OpenEphys as the raw data has to be bandpass filtered first. Once that's done the data is available as an EEGCalcs attribute of the trial object</p> <p>The default sampling rate for the LFP data is 250 Hz, but this can be changed by specifying the 'resample' argument in the load_lfp() function. For example, to resample the LFP data to 500 Hz:</p> <pre><code>trial.load_lfp(target_sample_rate=500)\n</code></pre> <p>Target sample rates should not exceed the Nyquist frequency of the original data, which is half the original sampling rate. For example, if the original sampling rate is 1000 Hz, the target sample rate should not exceed 500 Hz. </p> <p>Once the data has been loaded you can then bandpass filter it using butterFilter function:</p> Bandpass filter the LFP data between 6 and 12 Hz<pre><code>trial.LFP.butterFilter(6, 12)\n</code></pre>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#filtering-a-trial","level":2,"title":"Filtering a trial","text":"<p>There is an apply_filter() method of the trial object that takes a list of TrialFilter and applies those filters to the underlying data of the trial.</p> <p>Specify a TrialFilter like so:</p> Filter for speed<pre><code>from ephysiopy.common.utils import TrialFilter\n\nspeed_filter = TrialFilter(\"speed\", 0, 5)\ntrial.apply_filter([speed_filter])\n</code></pre> <p>This will filter out all data points where the animal's speed was below 5 cm/s. The filter is applied to all relevant data, so for example the spike times will be masked for all spikes that occurred when the animal was below the speed threshold.</p> <p>You can build up a list of filters and apply them all at once:</p> Filter for speed and time<pre><code>speed_filter = TrialFilter(\"speed\", 0, 5)\ntime_filter = TrialFilter(\"time\", 100, 200)\ntrial.apply_filter([speed_filter, time_filter])\n</code></pre> <p>The trial has now been filtered for all data points where the animal's speed was below 5 cm/s and where the time was between 100 and 200 seconds. The spike times will be masked for all spikes that occurred when the animal was below the speed threshold or outside the specified time range.</p> <p>To remove the filters just call the apply_filter() method with no arguments:</p> Remove all filters<pre><code>trial.apply_filter()\n</code></pre> <p>All of the TrialFilter objects take the same arguments: the name of the filter, the minimum value and the maximum value. The name of the filter should be one of the following:</p> <pre><code>time\ndir\nspeed\nxrange\nyrange\nphi\n</code></pre>","path":["User Guide","Further usage"],"tags":[]},{"location":"utils/","level":1,"title":"Utility classes and functions","text":"<p>Add some preamble about what's in this module...</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.BinnedData","level":2,"title":"<code>ephysiopy.common.utils.BinnedData</code>  <code>dataclass</code>","text":"<p>A dataclass to store binned data. The binned data is stored in a list of numpy arrays. The bin edges are stored in a list of numpy arrays. The variable to bin is stored as an instance of the VariableToBin enum. The map type is stored as an instance of the MapType enum. The binned data and bin edges are initialized as empty lists. bin_units is how to conver the binned data to \"real\" units e.g. for XY it might be how to convert to cms, for time to seconds etc. You multiply the binned data by that number to get the real values. Note that this might not make sense / be obvious for some binning (i.e. SPEED_DIR)</p> <p>The BinnedData class is the output of the main binning function in the ephysiopy.common.binning.RateMap class. It is used to store the binned data as a convenience mostly for easily iterating over the binned data and using the bin_edges to plot the data. As such, it is used as a convenience for plotting as the bin edges are used when calling pcolormesh in the plotting functions.</p> <p>Methods:</p> Name Description <code>get_cluster</code> <p>Returns the binned data for the specified cluster id</p> <code>correlate</code> <p>This method is used to correlate the binned data of this BinnedData</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.BinnedData.get_cluster","level":3,"title":"<code>get_cluster(id: ClusterID)</code>","text":"<p>Returns the binned data for the specified cluster id</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>ClusterID</code> <p>The cluster id to return</p> required <p>Returns:</p> Type Description <code>BinnedData</code> <p>A new BinnedData instance with the binned data for the specified cluster id</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.BinnedData.correlate","level":3,"title":"<code>correlate(other=None, as_matrix=False) -&gt; list[float] | np.ndarray</code>","text":"<p>This method is used to correlate the binned data of this BinnedData instance with the binned data of another BinnedData instance.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>BinnedData</code> <p>The other BinnedData instance to correlate with. If None, then correlations are performed between all the data held in the list self.binned_data</p> <code>None</code> <code>as_matrix</code> <code>bool</code> <p>If True will return the full correlation matrix for all of the correlations in the list of data in self.binned_data. If False, a list of the unique correlations for the comparisons in self.binned_data are returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>BinnedData</code> <p>A new BinnedData instance with the correlation of the binned data of this instance and the other instance.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.TrialFilter","level":2,"title":"<code>ephysiopy.common.utils.TrialFilter</code>  <code>dataclass</code>","text":"<p>A basic dataclass for holding filter values</p> Notes <p>Units:     time: seconds     dir: degrees     speed: cm/s     xrange/ yrange: cm</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Parameters</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.TrialFilter.__init__","level":3,"title":"<code>__init__(name: str, start: float | str, end: float | str = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the filter type</p> required <code>start</code> <code>(float, str)</code> <p>start value of filter</p> required <code>end</code> <code>(float, str)</code> <p>end value of filter</p> <code>None</code>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin","level":2,"title":"<code>ephysiopy.common.utils.VariableToBin</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Holds a human readable representation of the variable being binned</p> <p>Attributes:</p> Name Type Description <code>XY</code> <code>DIR</code> <code>SPEED</code> <code>XY_TIME</code> <code>SPEED_DIR</code> <code>EGO_BOUNDARY</code> <code>TIME</code> <code>X</code> <code>Y</code> <code>PHI</code>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.XY","level":3,"title":"<code>XY = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.DIR","level":3,"title":"<code>DIR = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.SPEED","level":3,"title":"<code>SPEED = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.XY_TIME","level":3,"title":"<code>XY_TIME = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.SPEED_DIR","level":3,"title":"<code>SPEED_DIR = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.EGO_BOUNDARY","level":3,"title":"<code>EGO_BOUNDARY = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.TIME","level":3,"title":"<code>TIME = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.X","level":3,"title":"<code>X = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.Y","level":3,"title":"<code>Y = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.PHI","level":3,"title":"<code>PHI = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType","level":2,"title":"<code>ephysiopy.common.utils.MapType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A human readable representation of the map type</p> <p>Attributes:</p> Name Type Description <code>RATE</code> <code>POS</code> <code>SPK</code> <code>ADAPTIVE</code> <code>AUTO_CORR</code> <code>CROSS_CORR</code>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.RATE","level":3,"title":"<code>RATE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.POS","level":3,"title":"<code>POS = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.SPK","level":3,"title":"<code>SPK = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.ADAPTIVE","level":3,"title":"<code>ADAPTIVE = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.AUTO_CORR","level":3,"title":"<code>AUTO_CORR = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.CROSS_CORR","level":3,"title":"<code>CROSS_CORR = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.ClusterID","level":2,"title":"<code>ephysiopy.common.utils.ClusterID = namedtuple('ClusterID', ['Cluster', 'Channel'])</code>  <code>module-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#miscellaneous-functions","level":2,"title":"Miscellaneous functions","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.get_z_score","level":2,"title":"<code>ephysiopy.common.utils.get_z_score(x: np.ndarray, mean=None, sd=None, axis: int = 0) -&gt; np.ndarray</code>","text":"<p>Calculate the z-scores for array x based on the mean and standard deviation in that sample, unless stated</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The array to z-score</p> required <code>mean</code> <code>float</code> <p>The mean of x. Calculated from x if not provided</p> <code>None</code> <code>sd</code> <code>float</code> <p>The standard deviation of x. Calculated from x if not provided</p> <code>None</code> <code>axis</code> <code>int</code> <p>The axis along which to operate</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The z-scored version of the input array x</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.filter_trial_by_time","level":2,"title":"<code>ephysiopy.common.utils.filter_trial_by_time(duration: int | float, how: str = 'in_half') -&gt; tuple[list[TrialFilter], ...]</code>","text":"<p>Filters the data in trial by time</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int | float</code> required <code>how</code> <code>str</code> <pre><code>    Legal values: \"in_half\" or \"odd_even\"\n    \"in_half\" filters for first n seconds and last n second\n    \"odd_even\" filters for odd vs even minutes\n</code></pre> <code>'in_half'</code> <p>Returns:</p> Type Description <code>tuple of TrialFilter</code> <p>A tuple of TrialFilter instances, one for each half or odd/even minutes</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.mean_norm","level":2,"title":"<code>ephysiopy.common.utils.mean_norm(x: np.ndarray, mn=None, axis: int = 0) -&gt; np.ndarray</code>","text":"<p>Mean normalise an input array</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The array t normalise</p> required <code>mn</code> <code>float</code> <p>The mean of x</p> <code>None</code> <code>axis</code> <code>int</code> <p>The axis along which to operate</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mean normalised version of the input array</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.min_max_norm","level":2,"title":"<code>ephysiopy.common.utils.min_max_norm(x: np.ndarray, min=None, max=None, axis: int = 0) -&gt; np.ndarray</code>","text":"<p>Normalise the input array x to lie between min and max</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>the array to normalise</p> required <code>min</code> <code>float</code> <p>the minimun value in the returned array</p> <code>None</code> <code>max</code> <code>float</code> <p>the maximum value in the returned array</p> <code>None</code> <code>axis</code> <code>int</code> <p>the axis along which to operate. Default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the normalised array</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.remap_to_range","level":2,"title":"<code>ephysiopy.common.utils.remap_to_range(x: np.ndarray, new_min=0, new_max=1, axis=0) -&gt; np.ndarray</code>","text":"<p>Remap the values of x to the range [new_min, new_max].</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>the array to remap</p> required <code>new_min</code> <code>float</code> <p>the minimun value in the returned array</p> <code>0</code> <code>max</code> <code>float</code> <p>the maximum value in the returned array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The remapped values</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.flatten_list","level":2,"title":"<code>ephysiopy.common.utils.flatten_list(list_to_flatten: list) -&gt; list</code>","text":"<p>Flattens a list of lists</p> <p>Parameters:</p> Name Type Description Default <code>list_to_flatten</code> <code>list</code> <p>the list to flatten</p> required <p>Returns:</p> Type Description <code>list</code> <p>The flattened list</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.smooth","level":2,"title":"<code>ephysiopy.common.utils.smooth(x, window_len=9, window='hanning')</code>","text":"<p>Smooth the data using a window with requested size.</p> <p>This method is based on the convolution of a scaled window with the signal. The signal is prepared by introducing reflected copies of the signal (with the window size) in both ends so that transient parts are minimized in the beginning and end part of the output signal.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input signal.</p> required <code>window_len</code> <code>int</code> <p>The length of the smoothing window.</p> <code>9</code> <code>window</code> <code>str</code> <p>The type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'. 'flat' window will produce a moving average smoothing.</p> <code>'hanning'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The smoothed signal.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t=linspace(-2,2,0.1)\n&gt;&gt;&gt; x=sin(t)+randn(len(t))*0.1\n&gt;&gt;&gt; y=smooth(x)\n</code></pre> See Also <p>numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve, scipy.signal.lfilter</p> Notes <p>The window parameter could be the window itself if an array instead of a string.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.blur_image","level":2,"title":"<code>ephysiopy.common.utils.blur_image(im: BinnedData, n: int, ny: int = 0, ftype: str = 'boxcar', **kwargs) -&gt; BinnedData</code>","text":"<p>Smooths all the binned_data in an instance of BinnedData by convolving with a filter.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>BinnedData</code> <p>Contains the array to smooth.</p> required <code>n</code> <code>int</code> <p>The size of the smoothing kernel.</p> required <code>ny</code> <code>int</code> <p>The size of the smoothing kernel.</p> required <code>ftype</code> <code>str</code> <p>The type of smoothing kernel. Either 'boxcar' or 'gaussian'.</p> <code>'boxcar'</code> <p>Returns:</p> Type Description <code>BinnedData</code> <p>BinnedData instance with the smoothed data.</p> Notes <p>This essentially does the smoothing in-place</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.shift_vector","level":2,"title":"<code>ephysiopy.common.utils.shift_vector(v, shift, maxlen=None)</code>","text":"<p>Shifts the elements of a vector by a given amount. A bit like numpys roll function but when the shift goes beyond some limit that limit is subtracted from the shift. The result is then sorted and returned.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array_like</code> <p>The input vector.</p> required <code>shift</code> <code>int</code> <p>The amount to shift the elements.</p> required <code>fill_value</code> <code>int</code> <p>The value to fill the empty spaces.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The shifted vector.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.count_to","level":2,"title":"<code>ephysiopy.common.utils.count_to(n: np.ndarray) -&gt; np.ndarray</code>","text":"<p>This function is equivalent to hstack((arange(n_i) for n_i in n)). It seems to be faster for some possible inputs and encapsulates a task in a function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; n = np.array([0, 0, 3, 0, 0, 2, 0, 2, 1])\n&gt;&gt;&gt; count_to(n)\narray([0, 1, 2, 0, 1, 0, 1, 0])\n</code></pre>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.window_rms","level":2,"title":"<code>ephysiopy.common.utils.window_rms(a: np.ndarray, window_size: int | float) -&gt; np.ndarray</code>","text":"<p>Calculates the root mean square of the input a over a window of size window_size</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>The input array</p> required <code>window_size</code> <code>(int, float)</code> <p>The size of the smoothing window</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The rms'd result</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.find_runs","level":2,"title":"<code>ephysiopy.common.utils.find_runs(x)</code>","text":"<p>Find runs of consecutive items in an array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>(ndarray, list)</code> <p>The array to search for runs in</p> required <p>Returns:</p> Name Type Description <code>run_values</code> <code>ndarray</code> <p>the values of each run</p> <code>run_starts</code> <code>ndarray</code> <p>the indices into x at which each run starts</p> <code>run_lengths</code> <code>ndarray</code> <p>The length of each run</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; n = np.array([0, 0, 3, 3, 0, 2, 0,0, 1])\n&gt;&gt;&gt; find_runs(n)\n(array([0, 3, 0, 2, 0, 1]),\narray([0, 2, 4, 5, 6, 8]),\narray([2, 2, 1, 1, 2, 1]))\n</code></pre> Notes <p>Taken from: https://gist.github.com/alimanfoo/c5977e87111abe8127453b21204c1065</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.repeat_ind","level":2,"title":"<code>ephysiopy.common.utils.repeat_ind(n: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Repeat a given index a specified number of times.</p> <p>The input specifies how many times to repeat the given index. It is equivalent to something like this:</p> <p>hstack((zeros(n_i,dtype=int)+i for i, n_i in enumerate(n)))</p> <p>But this version seems to be faster, and probably scales better. At any rate, it encapsulates a task in a function.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>ndarray</code> <p>A 1D array where each element specifies the number of times to repeat its index.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 1D array with indices repeated according to the input array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; n = np.array([0, 0, 3, 0, 0, 2, 0, 2, 1])\n&gt;&gt;&gt; repeat_ind(n)\narray([2, 2, 2, 5, 5, 7, 7, 8])\n</code></pre>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.rect","level":2,"title":"<code>ephysiopy.common.utils.rect(r, w, deg=False)</code>","text":"<p>Convert from polar (r, w) to rectangular (x, y) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float or ndarray</code> <p>Radial coordinate(s).</p> required <code>w</code> <code>float or ndarray</code> <p>Angular coordinate(s).</p> required <code>deg</code> <code>bool</code> <p>If True, <code>w</code> is in degrees. Default is False (radians).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing: - x : float or np.ndarray     X coordinate(s). - y : float or np.ndarray     Y coordinate(s).</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.polar","level":2,"title":"<code>ephysiopy.common.utils.polar(x, y, deg=False)</code>","text":"<p>Converts from rectangular coordinates to polar ones.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>The x coordinates.</p> required <code>y</code> <code>array_like</code> <p>The y coordinates.</p> required <code>deg</code> <code>bool</code> <p>If True, returns the angle in degrees. Default is False (radians).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>r</code> <code>array_like</code> <p>The radial coordinates.</p> <code>theta</code> <code>array_like</code> <p>The angular coordinates.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.labelledCumSum","level":2,"title":"<code>ephysiopy.common.utils.labelledCumSum(X, L)</code>","text":"<p>Compute the cumulative sum of an array with labels, resetting the sum at label changes.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Input array to compute the cumulative sum.</p> required <code>L</code> <code>ndarray</code> <p>Label array indicating where to reset the cumulative sum.</p> required <p>Returns:</p> Type Description <code>MaskedArray</code> <p>The cumulative sum array with resets at label changes, masked appropriately.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.cart2pol","level":2,"title":"<code>ephysiopy.common.utils.cart2pol(x, y)</code>","text":"<p>Convert Cartesian coordinates to polar coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> <p>X coordinate(s).</p> required <code>y</code> <code>float or ndarray</code> <p>Y coordinate(s).</p> required <p>Returns:</p> Name Type Description <code>r</code> <code>float or ndarray</code> <p>Radial coordinate(s).</p> <code>th</code> <code>float or ndarray</code> <p>Angular coordinate(s) in radians.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.pol2cart","level":2,"title":"<code>ephysiopy.common.utils.pol2cart(r, theta)</code>","text":"<p>Convert polar coordinates to Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float or ndarray</code> <p>Radial coordinate(s).</p> required <code>theta</code> <code>float or ndarray</code> <p>Angular coordinate(s) in radians.</p> required <p>Returns:</p> Name Type Description <code>x</code> <code>float or ndarray</code> <p>X coordinate(s).</p> <code>y</code> <code>float or ndarray</code> <p>Y coordinate(s).</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.applyFilter2Labels","level":2,"title":"<code>ephysiopy.common.utils.applyFilter2Labels(M, x)</code>","text":"<p>M is a logical mask specifying which label numbers to keep x is an array of positive integer labels</p> <p>This method sets the undesired labels to 0 and renumbers the remaining labels 1 to n when n is the number of trues in M</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.getLabelStarts","level":2,"title":"<code>ephysiopy.common.utils.getLabelStarts(x)</code>","text":"<p>Get the indices of the start of contiguous runs of non-zero values in a 1D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input 1D numpy array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of indices marking the start of each contiguous run of non-zero values.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.getLabelEnds","level":2,"title":"<code>ephysiopy.common.utils.getLabelEnds(x)</code>","text":"<p>Get the indices of the end of contiguous runs of non-zero values in a 1D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input 1D numpy array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of indices marking the end of each contiguous run of non-zero values.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.circ_abs","level":2,"title":"<code>ephysiopy.common.utils.circ_abs(x)</code>","text":"<p>Calculate the absolute value of an angle in radians, normalized to the range [-pi, pi].</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> <p>Angle(s) in radians.</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Absolute value of the angle(s) normalized to the range [-pi, pi].</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.labelContigNonZeroRuns","level":2,"title":"<code>ephysiopy.common.utils.labelContigNonZeroRuns(x)</code>","text":"<p>Label contiguous non-zero runs in a 1D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input 1D numpy array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array where each element is labeled with an integer representing the contiguous non-zero run it belongs to.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.fixAngle","level":2,"title":"<code>ephysiopy.common.utils.fixAngle(a)</code>","text":"<p>Ensure angles lie between -pi and pi.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float or ndarray</code> <p>Angle(s) in radians.</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Angle(s) normalized to the range [-pi, pi].</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.bwperim","level":2,"title":"<code>ephysiopy.common.utils.bwperim(bw, n=4)</code>","text":"<p>Finds the perimeter of objects in binary images.</p> <p>A pixel is part of an object perimeter if its value is one and there is at least one zero-valued pixel in its neighborhood.</p> <p>By default, the neighborhood of a pixel is 4 nearest pixels, but if <code>n</code> is set to 8, the 8 nearest pixels will be considered.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>array_like</code> <p>A black-and-white image.</p> required <code>n</code> <code>int</code> <p>Connectivity. Must be 4 or 8. Default is 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>perim</code> <code>array_like</code> <p>A boolean image.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.count_runs_and_unique_numbers","level":2,"title":"<code>ephysiopy.common.utils.count_runs_and_unique_numbers(arr: np.ndarray) -&gt; tuple</code>","text":"<p>Counts the number of continuous runs of numbers in a 1D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The input 1D numpy array of numbers.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing: - dict: A dictionary with the count of runs for each unique number. - set: The set of unique numbers in the array.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.corr_maps","level":2,"title":"<code>ephysiopy.common.utils.corr_maps(map1, map2, maptype='normal') -&gt; float</code>","text":"<p>Correlates two rate maps together, ignoring areas that have zero sampling.</p> <p>Parameters:</p> Name Type Description Default <code>map1</code> <code>ndarray</code> <p>The first rate map to correlate.</p> required <code>map2</code> <code>ndarray</code> <p>The second rate map to correlate.</p> required <code>maptype</code> <code>str</code> <p>The type of correlation to perform. Options are \"normal\" and \"grid\". Default is \"normal\".</p> <code>'normal'</code> <p>Returns:</p> Type Description <code>float</code> <p>The correlation coefficient between the two rate maps.</p> Notes <p>If the shapes of the input maps are different, the smaller map will be resized to match the shape of the larger map using reflection mode.</p> <p>The \"normal\" maptype considers non-zero and non-NaN values for correlation, while the \"grid\" maptype considers only finite values.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"what_is_ephysiopy/","level":1,"title":"What is ephysiopy?","text":"<p>ephysiopy is a Python package for the analysis of electrophysiological data collected with the Axona or openephys recording systems. It provides a unifying set of tools for the analysis of electrophysiological data recorded using tetrode or Neuropixels (LINK).</p> <p>It can load the data and so some plotting and analysis too.</p> <p>What it isn't is a way to pre-process data (drift correction etc) or to do spike sorting.</p> <p>There are some excellent tools for that already, and ephysiopy is designed to work with the output of those tools, not to replace them.</p> <p>There are many spike sorting tools available, KiloSort is popular among Neuropixels users, but there are many others (LINKS)</p> <p>Although there are some methods in ephysiopy for visualising spike waveforms, auto- and cross-correlograms and so on it is not supposed to be a replacement for tools like phy or SpikeInterface</p> <p>Iniitially, it was a collection of functions and scripts for loading and analysing data from the Axona system, but over time grew to encompass data from the OpenEphys system. That led to the development of an interface class (TrialInterface) to provide a common set of methods for loading, plotting and analysing the data regardless of the recording system used. It should therefore be possible to extend that interface for other recording systems in the future, if there is demand for that.</p>","path":["User Guide","What is ephysiopy?"],"tags":[]}]}