{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Home","text":"<p>A set of tools for the analysis of electrophysiological data recorded using Axona or OpenEphys data, be that using tetrode or Neuropixels</p>","path":["Home"],"tags":[]},{"location":"#installation","level":2,"title":"Installation","text":"<p>ephysiopy requires python 3.13 or greater. The easiest way to install is using uv or pip.</p> <p>Install uv</p> <p>Then, to install ephysiopy, run:</p> <pre><code>uv pip install ephysiopy\n</code></pre> <p>or with pip:</p> <pre><code>python3 -m pip install ephysiopy\n</code></pre>","path":["Home"],"tags":[]},{"location":"ephysiopy_tutorial/","level":1,"title":"ephysiopy user guide","text":"<p>This guide is an overview and explains basic features; details are found in the ephysiopy reference</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#getting-started","level":2,"title":"Getting started","text":"<p>What is ephysiopy?</p> <p>Installation</p> <p>ephsyiopy quickstart</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#data-organisation","level":2,"title":"Data organisation","text":"<p>With data recorded using OpenEphys the folder structure looks something like this:</p> <pre><code>  RHA1-00064_2023-07-07_10-47-31\n  ├── Record Node 101\n  │   ├── experiment1\n  │   │   └── recording1\n  │   │       ├── continuous\n  │   │       │   └── Acquisition_Board-100.Rhythm Data\n  │   │       │       ├── amplitudes.npy\n  │   │       │       ├── channel_map.npy\n  │   │       │       ├── channel_positions.npy\n  │   │       │       ├── cluster_Amplitude.tsv\n  │   │       │       ├── cluster_ContamPct.tsv\n  │   │       │       ├── cluster_group.tsv\n  │   │       │       ├── cluster_info.tsv\n  │   │       │       ├── cluster_KSLabel.tsv\n  │   │       │       ├── continuous.dat\n  │   │       │       ├── params.py\n  │   │       │       ├── pc_feature_ind.npy\n  │   │       │       ├── pc_features.npy\n  │   │       │       ├── phy.log\n  │   │       │       ├── rez.mat\n  │   │       │       ├── similar_templates.npy\n  │   │       │       ├── spike_clusters.npy\n  │   │       │       ├── spike_templates.npy\n  │   │       │       ├── spike_times.npy\n  │   │       │       ├── template_feature_ind.npy\n  │   │       │       ├── template_features.npy\n  │   │       │       ├── templates_ind.npy\n  │   │       │       ├── templates.npy\n  │   │       │       ├── whitening_mat_inv.npy\n  │   │       │       └── whitening_mat.npy\n  │   │       ├── events\n  │   │       │   ├── Acquisition_Board-100.Rhythm Data\n  │   │       │   │   └── TTL\n  │   │       │   │       ├── full_words.npy\n  │   │       │   │       ├── sample_numbers.npy\n  │   │       │   │       ├── states.npy\n  │   │       │   │       └── timestamps.npy\n  │   │       │   └── MessageCenter\n  │   │       │       ├── sample_numbers.npy\n  │   │       │       ├── text.npy\n  │   │       │       └── timestamps.npy\n  │   │       ├── structure.oebin\n  │   │       └── sync_messages.txt\n  │   └── settings.xml\n  └── Record Node 104\n      ├── experiment1\n      │   └── recording1\n      │       ├── continuous\n      │       │   └── TrackMe-103.TrackingNode\n      │       │       ├── continuous.dat\n      │       │       ├── sample_numbers.npy\n      │       │       └── timestamps.npy\n      │       ├── events\n      │       │   ├── MessageCenter\n      │       │   │   ├── sample_numbers.npy\n      │       │   │   ├── text.npy\n      │       │   │   └── timestamps.npy\n      │       │   └── TrackMe-103.TrackingNode\n      │       │       └── TTL\n      │       │           ├── full_words.npy\n      │       │           ├── sample_numbers.npy\n      │       │           ├── states.npy\n      │       │           └── timestamps.npy\n      │       ├── structure.oebin\n      │       └── sync_messages.txt\n      └── settings.xml\n</code></pre> <p>Despite looking overwhelming this is actually fairly straighforward...</p> <p>The top level (or parent) folder is called </p> <pre><code>RHA1-00064_2023-07-07_10-47-31\n</code></pre> <p>and contains everything else.</p> <p>In OpenEphys language there are two Record Nodes, \"Record Node 101\" and \"Record Node 104\"</p> <p>Record Node 101 is the one that contains the neural recording data as well as some other stuff.</p> <p>The main path through to the actual recording data is:</p> <pre><code>RHA1-00064_2023-07-07_10-47-31/Record Node 101/experiment1/recording1/continuous/Acquisition_Board-100.Rhythm Data\n</code></pre> <p>In the Acquisition_Board-100.Rhythm Data folder are a bunch of files but most of these are the results of running KiloSort on the acquired data so we'll deal with those later.</p> <p>The main recording file is continuous.dat which is a binary file usually fairly large in size (many 10's of Gbs).</p> <p>This raw binary file is something we can filter in different frequency bands to examine different parts of the activity of the brain. For high frequency spiking activity we can filter the data between about 300-500Hz and  several kHz. For lower frequency local field potential (LFP) activity we can filter the data between about 1-300Hz.</p> <p>The files in the rest of the folders for this Record Node are less relevant for now so we'll ignore them.</p> <p>Record Node 104 contains the tracking data for the animal's position in the arena. The main path to the tracking data is:</p> <pre><code>RHA1-00064_2023-07-07_10-47-31/Record Node 104/experiment1/recording1/continuous/TrackMe-103.TrackingNode\n</code></pre> <p>The main data for the tracking is again in the continuous.dat file but there is also importamnt information in the files here:</p> <pre><code>RHA1-00064_2023-07-07_10-47-31/Record Node 104/experiment1/recording1/events/TrackMe-103.TrackingNode\n</code></pre> <p>This folder contains the TTL events for the tracking data which are important for aligning the tracking data with the neural recording data.</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#loading-the-data","level":2,"title":"Loading the data","text":"","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#getting-started_1","level":3,"title":"Getting started","text":"<ul> <li>To load the data using Python start an ipython session in the terminal:</li> </ul> <pre><code>ipython\n</code></pre> <ul> <li>Then import the relevant bits of the ephysiopy package and a way to tell ephysiopy where the data is:</li> </ul> Load data<pre><code>from ephysiopy.io.recording import OpenEphysBase\nfrom pathlib import Path\n\ndata = Path(\"/path/to/data/RHA1-00064_2023-07-07_10-47-31\")\n\ntrial = OpenEphysBase(data)\n</code></pre> <p>If things are working ok you should see a message saying the settings data has been loaded. This refers to the data in the settings.xml file in the Acquisition_Board-100.Rhythm Data folder. This file contains important information about the recording such as the sampling rate, number of channels etc.</p> <p>Try to load the position data as well:</p> <pre><code>trial.load_pos_data()\n</code></pre> <p>You should see a message saying th TrackMe data has been loaded:</p> <pre><code>Loading TrackMe data...\nLoaded pos data\n</code></pre> <p>There are lots of potential plugins / ways for the position data to be acquired and I've attempted to make it fariyl modular so that it should be possible to load data from different sources. If you have a different setup and the data doesn't load then let me know and I can add support for it.</p> <p>At it's heart, position data for the type of electrophysiology we do is simply a set of x and y coordinates for the position of the animal in the arena at different time points The TrackMe plugin is one way to acquire this data but there are other ways to do it as well. The important thing is that we have a way to align the position data with the neural recording data.</p> <p>This is a critical step and if the data is misaligned you won't be able to come to any conclusions about how they brain is encoding space! Fortunately, ephysiopy takes care of this alignment for you!</p> <p>The next thing to do is load the neural data. This is actually a bit of a misnomer as, in order to be fast, the results of the KiloSort session are loaded rather than the raw data.</p> <p>If we want to plot waveforms i.e. actually index into the raw data file, then we have to load the raw data. For most purposes all we need are the timestamps that a given cluster emitted spikes.</p> <p>Similarly if we want to look at the LFP data then we need to load the raw data and filter it in the relevant frequency band(s). You can do that like so:</p> <pre><code>trial.load_lfp()\n</code></pre> <p>This will take a while as we need to load the data and filter it. For now, all you need to know is that you can call this load_lfp() methods with different frequency bands. We'll come back to this...</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#plotting-data","level":2,"title":"Plotting data","text":"<p>This is where things get a bit more interesting as we can start to see the results of our hard work with some nice pictures.</p> <p>The most straighforward thing to plot is the path of the animal and overlay on top of that the locations at which spikes were emitted.</p> <pre><code>trial.plot_spike_path()\n</code></pre> <p>This will plot the path of the animal over the course of the recording and can be a good check that we tracked the position of the animal well. Bad tracking will appear as distinct and abrupt jumps  in the tracked position, most likely looking like straight lines that go to a common source/ sink. This is often the casued by reflections of the LED(s) on the animals head against some surface.</p> <p>Calling this function with some arguments is more interesting! We need to know valid arguments to call it with though; that is we need to know which channels on our probe (or recording device) had clusters assigned to them by KiloSort. You can find that information by calling get_available_clusters_channels():</p> <pre><code>channels_clusters = trial.get_available_clusters_channels()\n</code></pre> <p>This will return a dictionary where the keys are channels and the values for each key is a list of the clusters assigned to that channel.</p> <pre><code>{7: [8],\n 8: [4, 13, 14, 122],\n 9: [3, 11],\n 10: [9, 10, 142, 143, 180, 186],\n 11: [0, 1, 2, 5, 7, 12, 19, 23, 140, 141, 147, 200],\n ...\n</code></pre> <p>I've truncated the output here but you can see that channel 7 has one cluster (8) while channel 8 has 4 (4, 13, 14, 122).</p> <p>Under the hood the phy library used to pull all this information together actually assigns a cluster to 12 potential channels I just pick out the \"best\" one for succinctness.</p> <p>You can access the underlying functions of the phy library by looking at the functions available to the TemplateModel instance that gets added to our trial object. In an ipython terminal type the following (including the period at the end) and hit Tab to see the list of available functions:</p> <pre><code>trial.template_model.\n</code></pre> <p>You also can see how to call these functions here:</p> <p>https://phy.readthedocs.io/en/latest/api/#phyappstemplatetemplatemodel</p> <p>Now that we know the channels and clusters we have available to us we can plot them out:</p> <pre><code>import matplotlib.pylab as plt\n\ntrial.plot_spike_path(8, 4)\nplt.show()\n</code></pre> <p>It's important to note that the function signature for all of the plot_* and get_* functions is (cluster, channel) which is kind of the other way they are shown to use when we called get_available_clusters_channels().</p> <p>In the plot above, depending on your screen resolution etc, the markers denoting where the cell fired may have appeared too small. To fix that add the markersize argument to the  plotting call:</p> <pre><code>ax = trial.plot_spike_path(8, 4, ms=6)\nplt.show()\n</code></pre> <p>What's happening here is that ms (markersize) is getting passed to the matplotlib plot command (or something similar) and the markers are plotted at a more appropriate size.</p> <p>You can also change the color of the squares with the color argument as well as lots of other stuff. Look at the matplotlib documentation for more details. In most cases the plotting functions return an Axes object that you can manipulate - note sometimes a plotting function may return a handle to the Figure not the Axes - this is especially true when there are multiple sub-plots in the Figure window.</p> <p>We can also plot a more processed version of the data by plotting the firing rate map of the cluster:</p> <pre><code>trial.plot_rate_map(8, 4)\nplt.show()\n</code></pre> <p>This shows where cluster emitted spikes as a heatmap where 'hot' colours are high firing rates and 'cold' colours are low rates (the colormap used is called 'jet' and is awful  for lots of reasons but it's a de facto standard). White areas in the firing rate map are areas the animal didn't / couldn't go to and so have no valid values.</p> <p>Before moving on to the other types of plots we can make it's worthwhile to understand the underlying data of the rate map as this will help you understand how the data is processed and the kinds of arguments you can add/ change in calling functions like plot_rate_map() and the impact they have.</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#binneddata","level":3,"title":"BinnedData","text":"<p>All (op nearly all) of the plot_* (i.e. plot_rate_map(), plot_hd_map() etc) functions have a get_* counterpart (i.e. get_rate_map() etc). The plot functions take what is returned from the get_* functions and simply plot that data (with some bells and whistles added). The object returned from the get_* functions is almost always (CHECK THIS) a BinnedData object.</p> <p>This is a fairly simple dataclass that encapsulates some variable(s) that has been binned up according to some algorithm. To give a concrete example given the data we've been working with above:</p> <pre><code>data = trial.get_rate_map(8, 4)\n</code></pre> <p>data here is an instance of the BinnedData class. It has several important properties:</p> <ul> <li>cluster_id </li> <li>bin_edges</li> <li>binned_data</li> <li>map_type</li> <li> <p>variable</p> </li> <li> <p>cluster_id is a list containing a namedtuple with fields Cluster and Channel</p> </li> <li>bin_edges is a list of numpy ndarray(s) that contains the bin edges of the binned up data</li> <li>binned_data is a list of numpy masked arrays but of the actual binned up data </li> <li>map_type is an Enum called MapType telling us the type of map we have (i.e. RATE, SPK, POS etc)</li> <li>variable is an Enum called VariableToBin which tells us the variable that has been binned (X, Y, XY, TIME etc)</li> </ul> <p>In the above example we called the get_rate_map() function with only a single cluster (8) and channel (4). It's possible to call the same function but with lists of clusters and channels like so:</p> <pre><code>data = trial.get_rate_map([79, 82], [34, 34])\n</code></pre> <p>Now 'data' contains data for both clusters (79 &amp; 82). Note the map_type, variable and bin_edges values will all be the same (MapType.RATE, VariableToBin.XY and a list of length  2 containing the x and y bin edges). You can't have a situation with a BinnedData instance that has different map_type or variable properties - you need to re-calculate and re-bin the data to do that.</p> <p>There are several methods available to the BinnedData instance that hopefully make data processing a bit easier.</p> <p>When analysing data like this programmatically it's often faster and easier to do all the binning at once and access the processed data after that step. To access an individual cluster from the example above you can call the get_cluster() function:</p> <pre><code>cluster_data = data.get_cluster(ClusterID(79, 34))\n</code></pre>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#correlating-maps","level":4,"title":"Correlating maps","text":"<p>One of the commonly performed analysis steps is to correlate rate maps together to try and get a sense of how similar two maps are to each other. To do that you can call correlate():</p> <pre><code>data.correlate()\narray([0.1179206 , 0.14373477, 0.04730432])\n</code></pre> <p>This is showing the Pearson Product Moment Correlation Coefficent between the pairs of rate maps in data i.e. map1 correlated with map2 and then map3 and map2 correlated with  map3 (so three correlation values in total). You can also get the correlation matrix which is mirror symmetric across the diagonal:</p> <pre><code>data.correlate(as_matrix=True)\narray([[1.        , 0.1179206 , 0.14373477],\n       [0.1179206 , 1.        , 0.04730432],\n       [0.14373477, 0.04730432, 1.        ]])\n</code></pre> <p>You can also correlate one BinnedData instance with another BinnedData instance:</p> <pre><code>data1 = trial.get_rate_map([109,110],[36,36])\ndata.correlate(data1, as_matrix=True)\narray([[ 0.21015777,  0.16216187],\n       [ 0.0269544 , -0.00144629],\n       [ 0.13845497, -0.01680002]])\n</code></pre> <p>The output is hopefully fairly self-explanatory given its shape...</p> <p>You can also add together two BinnedData instances to concatenate them:</p> <pre><code>data2 = data + data1\n</code></pre> <p>data2 will now contain the binned data for clusters 79 &amp; 82 on channel 34 and clusters 109 &amp; 110 on channel 36</p> <p>Now that we know what the BinnedData contains (you don't need to know the underlying implementation bu design) you can understand the different arguments you can supply to the get_* and plot_* functions and the effect they have. If we have linear track data we can bin up data according to only one of the X or Y variables (you can also bin up a PHI variable which is the cartesian distance down the track) and this will give us a 1D rate map:</p> <pre><code>ratemap = trial.get_rate_map(79, 34, var_type=VariableToBin.X)\n</code></pre> <p>Now ratemap.bin_edges will be a list of length 1 containing the x bin edges.</p>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"ephysiopy_tutorial/#iterating-over-binneddata","level":4,"title":"Iterating over BinnedData","text":"<p>BinnedData can also be iterated over with each iteration yielding a BinnedData instance:</p> <pre><code>channels_clusters = trial.get_available_clusters_channels()\nall_maps = trial.get_all_maps(channels_clusters)\n</code></pre> <p>all_maps is an instance of BinnedData, the VariableToBin is XY with MapType of RATE (the defaults) and we can iterate over it:</p> <pre><code>for i_map in all_maps:\n  print(f\"{i_map.cluster_id}\")\nClusterID(Cluster=8, Channel=7)\nClusterID(Cluster=4, Channel=8)\n...\n</code></pre>","path":["User Guide","ephysiopy user guide"],"tags":[]},{"location":"field_analysis/","level":1,"title":"Firing field analysis","text":"<p>You can extract various properties of the firing field of a cluster using the  get_field_properties method the TrialInterface class. This method returns a FieldProps object which contains various properties of the firing field of a cluster.</p> <p>Plot each FieldProps item to get an idea of how well the segmentation worked etc:</p> <p>The underlying objects are described here:</p> <p>These methods are available to operate on the output of fieldprops (or similarly the get_field_properties() method of the TrialInterface class).</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.io.recording.TrialInterface.get_field_properties","level":2,"title":"<code>ephysiopy.io.recording.TrialInterface.get_field_properties(cluster: int | list, channel: int | list, **kwargs) -&gt; list[FieldProps]</code>","text":"<p>Gets the properties of a given field (area, runs through the field, etc)</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int | list</code> <p>The cluster(s) to get the field properties for</p> required <code>channel</code> <code>int | list</code> <p>The channel(s) to get the field properties for</p> required <code>**kwargs</code> <p>partition : str     How the field is separated from the background. This is passed to     the fieldproperties function and can be used to specify the partition     to use for the field properties.</p> <pre><code>Valid options are 'simple' and 'fancy'\n\nOther kwargs get passed to get_rate_map and\nfieldprops, the most important of which may be\nhow the runs are split in fieldprops (options are\n'field' and 'clump_runs') which differ depending on\nif the position data is open-field (field) or linear track\nin which case you should probably use 'clunmp_runs'\n</code></pre> <code>{}</code> <p>Returns:</p> Type Description <code>list[FieldProps]</code> <p>A list of FieldProps namedtuples containing the properties of the field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.plot_field_props","level":2,"title":"<code>ephysiopy.common.fieldcalcs.plot_field_props(field_props: list[FieldProps])</code>","text":"<p>Plots the fields in the list of FieldProps</p> <p>Parameters:</p> Name Type Description Default <code>field_props</code> <code>list of FieldProps</code> <p>The field properties to plot</p> required","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.fieldprops","level":2,"title":"<code>ephysiopy.common.fieldproperties.fieldprops(label_image, binned_data, spike_times, xy, method='field', cache=True, *, extra_properties=None, spacing=None, offset=None, **kwargs)</code>","text":"<p>Measure properties of labeled image regions.</p> <p>Parameters:</p> Name Type Description Default <code>label_image</code> <code>(M, N[, P]) np.ndarray</code> <p>Labeled input image. Labels with value 0 are ignored.</p> required <code>xy</code> <code>(2 x n_samples) np.ndarray</code> <p>The x-y coordinates for all runs through the field corresponding to a particular label</p> required <code>binned_data</code> <code>BinnedData instance from ephysiopy.common.utils</code> required <code>spike_times</code> <code>ndarray</code> <p>The spike times for the neuron being analysed</p> required <code>method</code> <p>Method used to calculate region properties:</p> <ul> <li>'field': Standard method using discrete pixel counts based     on a segmentation of the rate map into labeled regions (fields).     This method     is faster, but can be inaccurate for small regions and will not     work well for positional data that has been masked for direction of     running say (ie linear track)</li> <li>'clump_runs': Exact method which accounts for filtered data better by     looking for contiguous areas of the positional data that are NOT     masked (uses np.ma.clump_unmasked) cache : bool, optional Determine whether to cache calculated properties. The computation is much faster for cached properties, whereas the memory consumption increases.</li> </ul> <code>'field'</code> <code>extra_properties</code> <code>Iterable of callables</code> <p>Add extra property computation functions that are not included with skimage. The name of the property is derived from the function name, the dtype is inferred by calling the function on a small sample. If the name of an extra property clashes with the name of an existing property the extra property will not be visible and a UserWarning is issued. A property computation function must take a region mask as its first argument. If the property requires an intensity image, it must accept the intensity image as the second argument.</p> <code>None</code> <code>spacing</code> <p>The pixel spacing along each axis of the image.</p> <code>None</code> <code>offset</code> <code>array-like of int, shape `(label_image.ndim,)`</code> <p>Coordinates of the origin (\"top-left\" corner) of the label image. Normally this is ([0, ]0, 0), but it might be different if one wants to obtain regionprops of subvolumes within a larger volume.</p> <code>None</code> <code>**kwargs</code> <code>keyword arguments</code> <p>Additional arguments passed to the FieldProps constructor. Legal arguments are:     pos_sample_rate : int     min_run_length : int</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>properties</code> <code>list of FieldProps</code> <p>Each item describes one labeled region, and can be accessed using the attributes listed below.</p> Notes <p>The following properties can be accessed as attributes or keys:</p> <p>area : float     Area of the region i.e. number of pixels of the region scaled     by pixel-area.</p> <p>area_bbox : float     Area of the bounding box i.e. number of pixels of bounding box scaled     by pixel-area.</p> <p>area_convex : float     Area of the convex hull image, which is the smallest convex     polygon that encloses the region.</p> <p>area_filled : float     Area of the region with all the holes filled in.</p> <p>axis_major_length : float     The length of the major axis of the ellipse that has the same     normalized second central moments as the region.</p> <p>axis_minor_length : float     The length of the minor axis of the ellipse that has the same     normalized second central moments as the region.</p> <p>bbox : tuple     Bounding box <code>(min_row, min_col, max_row, max_col)</code>.     Pixels belonging to the bounding box are in the half-open interval     <code>[min_row; max_row)</code> and <code>[min_col; max_col)</code>.</p> <p>centroid : array     Centroid coordinate tuple <code>(row, col)</code>.</p> <p>centroid_local : array     Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding     box.</p> <p>centroid_weighted : array     Centroid coordinate tuple <code>(row, col)</code> weighted with intensity     image.</p> <p>centroid_weighted_local : array     Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding     box, weighted with intensity image.</p> <p>coords_scaled : (K, 2) ndarray     Coordinate list <code>(row, col)</code> of the region scaled by <code>spacing</code>.</p> <p>coords : (K, 2) ndarray     Coordinate list <code>(row, col)</code> of the region.</p> <p>eccentricity : float     Eccentricity of the ellipse that has the same second-moments as the     region. The eccentricity is the ratio of the focal distance     (distance between focal points) over the major axis length.     The value is in the interval [0, 1).     When it is 0, the ellipse becomes a circle.</p> <p>equivalent_diameter_area : float     The diameter of a circle with the same area as the region.</p> <p>euler_number : int     Euler characteristic of the set of non-zero pixels.     Computed as number of connected components subtracted by number of     holes (input.ndim connectivity). In 3D, number of connected     components plus number of holes subtracted by number of tunnels.</p> <p>extent : float     Ratio of pixels in the region to pixels in the total bounding box.     Computed as <code>area / (rows  cols)</code></p> <p>feret_diameter_max : float     Maximum Feret's diameter computed as the longest distance between     points around a region's convex hull contour as determined by     <code>find_contours</code>. [5]_</p> <p>image : (H, J) ndarray     Sliced binary region image which has the same size as bounding box.</p> <p>image_convex : (H, J) ndarray     Binary convex hull image which has the same size as bounding box.</p> <p>image_filled : (H, J) ndarray     Binary region image with filled holes which has the same size as     bounding box.</p> <p>image_intensity : ndarray     Image inside region bounding box.</p> <p>inertia_tensor : ndarray     Inertia tensor of the region for the rotation around its mass.</p> <p>inertia_tensor_eigvals : tuple     The eigenvalues of the inertia tensor in decreasing order.</p> <p>intensity_max : float     Value with the greatest intensity in the region.</p> <p>intensity_mean : float     Value with the mean intensity in the region.</p> <p>intensity_min : float     Value with the least intensity in the region.</p> <p>intensity_std : float     Standard deviation of the intensity in the region.</p> <p>label : int     The label in the labeled input image.</p> <p>moments : (3, 3) ndarray     Spatial moments up to 3<sup>rd</sup> order::</p> <pre><code>    m_ij = sum{ array(row, col)  row^i  col^j }\n\nwhere the sum is over the `row`, `col` coordinates of the region.\n</code></pre> <p>moments_central : (3, 3) ndarray     Central moments (translation invariant) up to 3<sup>rd</sup> order::</p> <pre><code>    mu_ij = sum{ array(row, col)  (row - row_c)^i  (col - col_c)^j }\n\nwhere the sum is over the `row`, `col` coordinates of the region,\nand `row_c` and `col_c` are the coordinates of the region's centroid.\n</code></pre> <p>moments_hu : tuple     Hu moments (translation, scale and rotation invariant).</p> <p>moments_normalized : (3, 3) ndarray     Normalized moments (translation and scale invariant) up to 3<sup>rd</sup> order::</p> <pre><code>    nu_ij = mu_ij / m_00^[(i+j)/2 + 1]\n\nwhere `m_00` is the zeroth spatial moment.\n</code></pre> <p>moments_weighted : (3, 3) ndarray     Spatial moments of intensity image up to 3<sup>rd</sup> order::</p> <pre><code>    wm_ij = sum{ array(row, col)  row^i  col^j }\n\nwhere the sum is over the `row`, `col` coordinates of the region.\n</code></pre> <p>moments_weighted_central : (3, 3) ndarray     Central moments (translation invariant) of intensity image up to     3<sup>rd</sup> order::</p> <pre><code>    wmu_ij = sum{ array(row, col)  (row - row_c)^i  (col - col_c)^j }\n\nwhere the sum is over the `row`, `col` coordinates of the region,\nand `row_c` and `col_c` are the coordinates of the region's weighted\ncentroid.\n</code></pre> <p>moments_weighted_hu : tuple     Hu moments (translation, scale and rotation invariant) of intensity     image.</p> <p>moments_weighted_normalized : (3, 3) ndarray     Normalized moments (translation and scale invariant) of intensity     image up to 3<sup>rd</sup> order::</p> <pre><code>    wnu_ij = wmu_ij / wm_00^[(i+j)/2 + 1]\n\nwhere ``wm_00`` is the zeroth spatial moment (intensity-weighted area).\n</code></pre> <p>num_pixels : int     Number of foreground pixels.</p> <p>orientation : float     Angle between the 0<sup>th</sup> axis (rows) and the major     axis of the ellipse that has the same second moments as the region,     ranging from <code>-pi/2</code> to <code>pi/2</code> counter-clockwise.</p> <p>perimeter : float     Perimeter of object which approximates the contour as a line     through the centers of border pixels using a 4-connectivity.</p> <p>perimeter_crofton : float     Perimeter of object approximated by the Crofton formula in 4     directions.</p> <p>slice : tuple of slices     A slice to extract the object from the source image.</p> <p>solidity : float     Ratio of pixels in the region to pixels of the convex hull image.</p> <p>Each region also supports iteration, so that you can do::</p> <p>for prop in region:       print(prop, region[prop])</p> See Also <p>ephysiopy.common.utils.BinnedData</p> <p>skimage.measure.regionprops</p> References <p>.. [1] Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:        Core Algorithms. Springer-Verlag, London, 2009.</p> <p>.. [2] B. Jähne. Digital Image Processing. Springer-Verlag,        Berlin-Heidelberg, 6. edition, 2005.</p> <p>.. [3] T. H. Reiss. Recognizing Planar Objects Using Invariant Image        Features, from Lecture notes in computer science, p. 676. Springer,        Berlin, 1993.</p> <p>.. [4] https://en.wikipedia.org/wiki/Image_moment</p> <p>.. [5] W. Pabst, E. Gregorová. Characterization of particles and particle        systems, pp. 27-28. ICT Prague, 2007.        https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from skimage import data, util\n&gt;&gt;&gt; from skimage.measure import label, regionprops\n&gt;&gt;&gt; img = util.img_as_ubyte(data.coins()) &gt; 110\n&gt;&gt;&gt; label_img = label(img, connectivity=img.ndim)\n&gt;&gt;&gt; props = regionprops(label_img)\n&gt;&gt;&gt; # centroid of first labeled object\n&gt;&gt;&gt; props[0].centroid\n(22.72987986048314, 81.91228523446583)\n&gt;&gt;&gt; # centroid of first labeled object\n&gt;&gt;&gt; props[0]['centroid']\n(22.72987986048314, 81.91228523446583)\n</code></pre> <p>Add custom measurements by passing functions as <code>extra_properties</code></p> <pre><code>&gt;&gt;&gt; from skimage import data, util\n&gt;&gt;&gt; from skimage.measure import label, regionprops\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; img = util.img_as_ubyte(data.coins()) &gt; 110\n&gt;&gt;&gt; label_img = label(img, connectivity=img.ndim)\n&gt;&gt;&gt; def pixelcount(regionmask):\n...     return np.sum(regionmask)\n&gt;&gt;&gt; props = regionprops(label_img, extra_properties=(pixelcount,))\n&gt;&gt;&gt; props[0].pixelcount\n7741\n&gt;&gt;&gt; props[1]['pixelcount']\n42\n</code></pre>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps","level":2,"title":"<code>ephysiopy.common.fieldproperties.FieldProps(slice, label, label_image, binned_data, cache, *, extra_properties, spacing, offset, index=0)</code>","text":"<p>               Bases: <code>RegionProperties</code></p> <p>Describes various properties of a receptive field.</p> <p>Attributes:</p> Name Type Description <code>slice</code> <code>tuple of slice</code> <p>The slice of the field in the binned data (x slice, y slice)</p> <code>label</code> <code>int</code> <p>The label of the field</p> <code>image_intensity</code> <code>ndarray</code> <p>The intensity image of the field (in Hz)</p> <code>runs</code> <code>list of RunProps</code> <p>The runs through the field</p> <code>run_slices</code> <code>list of slice</code> <p>The slices of the runs through the field (slices are position indices)</p> <code>run_labels</code> <code>ndarray</code> <p>The labels of the runs</p> <code>max_index</code> <code>ndarray</code> <p>The index of the maximum intensity in the field</p> <code>num_runs</code> <code>int</code> <p>The number of runs through the field</p> <code>cumulative_time</code> <code>list of np.ndarray</code> <p>The cumulative time spent on the field for each run through the field</p> <code>cumulative_distance</code> <code>list of np.ndarray</code> <p>The cumulative time spent on the field for each run through the field</p> <code>runs_speed</code> <code>list of np.ndarray</code> <p>The speed of each run through the field</p> <code>runs_observed_spikes</code> <code>ndarray</code> <p>The observed spikes for each run through the field</p> <code>spike_index</code> <code>ndarray</code> <p>The index of the spikes in the position data</p> <code>xy_at_peak</code> <code>ndarray</code> <p>The x-y coordinate of the field max</p> <code>xy</code> <code>ndarray</code> <p>The x-y coordinates of the field for all runs</p> <code>xy_relative_to_peak</code> <code>ndarray</code> <p>The x-y coordinates of the field zeroed with respect to the peak</p> <code>xy_angle_to_peak</code> <code>ndarray</code> <p>The angle each x-y coordinate makes to the field peak</p> <code>xy_dist_to_peak</code> <code>ndarray</code> <p>The distance of each x-y coordinate to the field peak</p> <code>bw_perim</code> <code>ndarray</code> <p>The perimeter of the field as an array of bool</p> <code>perimeter_coords</code> <code>tuple</code> <p>The x-y coordinates of the field perimeter</p> <code>global_perimeter_coords</code> <code>ndarray</code> <p>The global x-y coordinates of the field perimeter</p> <code>perimeter_minus_field_max</code> <code>ndarray</code> <p>The x-y coordinates of the field perimeter minus the field max</p> <code>perimeter_angle_from_peak</code> <code>ndarray</code> <p>The angle each point on the perimeter makes to the field peak</p> <code>perimeter_dist_from_peak</code> <code>ndarray</code> <p>The distance of each point on the perimeter to the field peak</p> <code>bin_coords</code> <code>ndarray</code> <p>The x-y coordinates of the field in the binned data</p> <code>phi</code> <code>ndarray</code> <p>The angular distance between the mean direction of each run and each position samples direction to the field centre</p> <code>rho</code> <code>ndarray</code> <p>The distance of each position sample to the field max (1 is furthest)</p> <code>pos_xy</code> <code>ndarray</code> <p>The cartesian x-y coordinates of each position sample</p> <code>pos_phi</code> <code>ndarray</code> <p>The angular distance between the mean direction of each run and each position samples direction to the field centre</p> <code>pos_r</code> <code>ndarray</code> <p>The ratio of the distance from the field peak to the position sample and the distance from the field peak to the point on the perimeter that is most colinear with the position sample</p> <code>r_and_phi_to_x_and_y</code> <code>ndarray</code> <p>Converts rho and phi to x and y coordinates</p> <code>r_per_run</code> <code>ndarray</code> <p>The polar radial distance for each run</p> <code>current_direction</code> <code>ndarray</code> <p>The direction projected onto the mean run direction</p> <code>cumulative_distance</code> <code>list of np.ndarray</code> <p>The cumulative distance for each run</p> <code>projected_direction</code> <code>ndarray</code> <p>The direction projected onto the mean run direction</p> <code>intensity_max</code> <code>float</code> <p>The maximum intensity of the field (i.e. field peak rate)</p> <code>intensity_mean</code> <code>float</code> <p>The mean intensity of the field</p> <code>intensity_min</code> <code>float</code> <p>The minimum intensity of the field</p> <code>intensity_std</code> <code>float</code> <p>The standard deviation of the field intensity</p> <p>Methods:</p> Name Description <code>__str__</code> <p>Override the string representation printed to the console</p> <code>mean_spiking_var</code> <p>Get the mean value of a variable at the posiition of</p> <code>overdispersion</code> <p>Calculate the overdispersion for each run through the field</p> <code>runs_expected_spikes</code> <p>Calculate the expected number of spikes along each run given the</p> <code>smooth_runs</code> <p>Smooth in x and y in preparation for converting the smoothed cartesian</p> <code>spiking_var</code> <p>Get the value of a variable at the position of</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.compressed_phase","level":3,"title":"<code>compressed_phase: np.ndarray</code>  <code>property</code>","text":"<p>The phases of the LFP signal for all runs through this field compressed into a single array</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.n_spikes","level":3,"title":"<code>n_spikes: int</code>  <code>property</code>","text":"<p>The total number of spikes emitted on all runs through the field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.normalized_position","level":3,"title":"<code>normalized_position: list</code>  <code>property</code>","text":"<p>Only makes sense to run this on linear track data unless we want to pass the unit circle distance or something...</p> <p>Get the normalized position for each run through the field.</p> <p>Normalized position is the position of the run relative to the start of the field (0) to the end of the field (1).</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.phase","level":3,"title":"<code>phase: list</code>  <code>property</code>","text":"<p>The phases of the LFP signal for all runs through this field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.phi","level":3,"title":"<code>phi: np.ndarray</code>  <code>property</code>","text":"<p>Calculate the angular distance between the mean direction of each run and each position samples direction to the field centre</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.pos_phi","level":3,"title":"<code>pos_phi: np.ndarray</code>  <code>property</code>","text":"<p>Calculate the angular distance between the mean direction of each run and each position samples direction to the field centre</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.pos_r","level":3,"title":"<code>pos_r: np.ndarray</code>  <code>property</code>","text":"<p>Calculate the ratio of the distance from the field peak to the position sample and the distance from the field peak to the point on the perimeter that is most colinear with the position sample</p> <p>NB The values just before being returned can be &gt;= 1 so these are capped to 1</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.projected_direction","level":3,"title":"<code>projected_direction: np.ndarray</code>  <code>property</code>","text":"<p>direction projected onto the mean run direction is just the x-coord when cartesian x and y is converted to from polar rho and phi</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.__str__","level":3,"title":"<code>__str__()</code>","text":"<p>Override the string representation printed to the console</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.mean_spiking_var","level":3,"title":"<code>mean_spiking_var(var='current_direction')</code>","text":"<p>Get the mean value of a variable at the posiition of the spikes for all runs through this field when multiple spikes occur in a single theta cycle</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>the variable to get the mean value of at the position of spikes</p> <code>'current_direction'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the mean value of the variable at the position of spikes for all runs through this field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.overdispersion","level":3,"title":"<code>overdispersion(spikes: np.ndarray, fs: int = 50) -&gt; np.ndarray</code>","text":"<p>Calculate the overdispersion for each run through the field</p> <p>Parameters:</p> Name Type Description Default <code>spikes</code> <code>ndarray</code> <p>the spike train (spikes binned up by position) for the whole trial. Same length as the trial n_samples</p> required <code>fs</code> <code>int</code> <p>the sample rate of the position data</p> <code>50</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the overdispersion for each run through the field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.runs_expected_spikes","level":3,"title":"<code>runs_expected_spikes(expected_rate: np.ndarray, sample_rate: int = 50) -&gt; np.ndarray</code>","text":"<p>Calculate the expected number of spikes along each run given the whole ratemap.</p> <p>Parameters:</p> Name Type Description Default <code>expected_rate</code> <code>ndarray</code> <p>the rate seen at each xy position of the whole trial</p> required <code>sample_rate</code> <code>int</code> <p>the sample rate of the position data</p> <code>50</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the expected rate at each xy position for each run</p> <p>Examples:</p> <p>The expected spikes should be calculated from the smoothed ratemap and the xy position data using np.digitize:</p> <pre><code>&gt;&gt;&gt; xbins = np.digitize(xy[0], binned_data.bin_edges[1][:-1]) - 1\n&gt;&gt;&gt; ybins = np.digitize(xy[1], binned_data.bin_edges[0][:-1]) - 1\n&gt;&gt;&gt; expected_rate_at_pos = binned_data.binned_data[0][ybins, xbins]\n&gt;&gt;&gt; exptd_spks = fieldprops.runs_expected_spikes(expected_rate_at_pos)\n</code></pre>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.smooth_runs","level":3,"title":"<code>smooth_runs(k: float, spatial_lp_cut: int, sample_rate: int)</code>","text":"<p>Smooth in x and y in preparation for converting the smoothed cartesian coordinates to polar ones</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>float</code> <p>smoothing constant for the instantaneous firing rate</p> required <code>spatial_lp_cut</code> <code>int</code> <p>spatial lowpass cut off</p> required <code>sample_rate</code> <code>int</code> <p>position sample rate in Hz</p> required","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.FieldProps.spiking_var","level":3,"title":"<code>spiking_var(var='current_direction')</code>","text":"<p>Get the value of a variable at the position of spikes for all runs through this field</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>the variable to get the value of at the position of spikes</p> <code>'current_direction'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the value of the variable at the position of spikes for all runs through this field</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps","level":2,"title":"<code>ephysiopy.common.fieldproperties.RunProps(parent, label: int, slice: slice, spike_times: np.ndarray, mask: np.ndarray, xy_coords: np.ndarray, speed: np.ndarray, peak_xy: np.ndarray, max_index: np.ndarray, perimeter_coords: np.ndarray, sample_rate: float = 50)</code>","text":"<p>               Bases: <code>SpikingProperty</code>, <code>object</code></p> <p>A custom class for holding information about runs through a receptive field</p> <p>Each run needs to have some information about the field to which it belongs so the constructor takes in the peak x-y coordinate of the field and its index as well as the coordinates of the perimeter of the field</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>int</code> <p>the run id</p> <code>slice</code> <code>slice</code> <p>the slice of the position data for a run</p> <code>xy</code> <code>ndarray</code> <p>the x-y coordinates for a run (global coordinates)</p> <code>speed</code> <code>ndarray</code> <p>the speed at each xy coordinate</p> <code>peak_xy</code> <code>tuple[float, float]</code> <p>the fields max rate xy location</p> <code>max_index</code> <code>int</code> <p>the index into the arrays of the field max</p> <code>perimeter_coords</code> <code>ndarray</code> <p>xy coordinates of the field perimeter</p> <code>hdir</code> <code>ndarray</code> <p>the heading direction</p> <code>min_speed</code> <code>float</code> <p>the minimum speed</p> <code>cumulative_time</code> <code>ndarray</code> <p>the cumulative time spent on a run</p> <code>duration</code> <code>float</code> <p>the total duration of a run in seconds</p> <code>n_spikes</code> <code>int</code> <p>the total number of spikes emitted on a run</p> <code>run_start</code> <code>int</code> <p>the position index of the run start</p> <code>run_stop</code> <code>int</code> <p>the position index of the run stop</p> <code>mean_direction</code> <code>float</code> <p>the mean direction of a run</p> <code>current_direction</code> <code>ndarray</code> <p>the current direction of a run</p> <code>cumulative_distance</code> <code>ndarray</code> <p>the cumulative distance covered in a run</p> <code>spike_index</code> <code>ndarray</code> <p>the index into the position data of the spikes on a run</p> <code>observed_spikes</code> <code>ndarray</code> <p>the observed spikes on a run (binned by position samples)</p> <code>xy_angle_to_peak</code> <code>ndarray</code> <p>the xy angle to the peak (radians)</p> <code>xy_dist_to_peak</code> <code>ndarray</code> <p>the distance to the field max</p> <code>xy_dist_to_peak_normed</code> <code>ndarray</code> <p>normalised distance to field max</p> <code>pos_xy</code> <code>ndarray</code> <p>cartesian xy coordinates but normalised on a unit circle</p> <code>pos_phi</code> <code>ndarray</code> <p>the angular distance between a runs main direction and the direction to the peak for each position sample</p> <code>rho</code> <code>ndarray</code> <p>the polar radial distance (1 = field edge)</p> <code>phi</code> <code>ndarray</code> <p>the polar angle (radians)</p> <code>r_and_phi_to_x_and_y</code> <code>ndarray</code> <p>converts rho and phi to x and y coordinates (range = -1 -&gt; +1)</p> <code>tortuosity</code> <code>ndarray</code> <p>the tortuosity for a run (closer to 1 = a straighter run)</p> <code>xy_is_smoothed</code> <code>bool</code> <p>whether the xy data has been smoothed</p> <p>label : int     the field label the run belongs to slice : slice     the slice into the position array that holds all the position data spike_times: np.ndarray     the spike times for this run xy_coords : np.ndarray     the xy data for this run (global coordinates) hdir : np.ndarray     the heading direction for this run speed : np.ndarray     the speed for this run peak_xy : np.ndarray     the peak location of the field for the this run max_index : np.ndarray     the index (r,c) of the maximum of the firing field perimeter_coords : np.ndarray     the xy coordinates of the perimeter of the field</p> <p>Methods:</p> Name Description <code>expected_spikes</code> <p>Calculates the expected number of spikes along this run given the</p> <code>mean_spiking_var</code> <p>Get the mean value of a variable at the posiition of</p> <code>overdispersion</code> <p>The overdispersion map for this run</p> <code>smooth_xy</code> <p>Smooth in x and y in preparation for converting the smoothed cartesian</p> <code>spiking_var</code> <p>Get the value of a variable at the position of</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.current_direction","level":3,"title":"<code>current_direction: ma.MaskedArray</code>  <code>property</code>","text":"<p>Supposed to calculate current direction wrt to field centre?</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.ndim","level":3,"title":"<code>ndim</code>  <code>property</code>","text":"<p>Return the dimensionality of the data</p> <p>For 1 x n linear track data dimensionality = 1 for 2 x n open field (or other) data dimensionality = 2</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.normed_x","level":3,"title":"<code>normed_x: np.ndarray</code>  <code>property</code>","text":"<p>Normalise the x data to lie between -1 and 1 with respect to the field limits of the parent field and the run direction such that -1 is entry and +1 is exit</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.phi","level":3,"title":"<code>phi: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 2pi</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.pos_phi","level":3,"title":"<code>pos_phi: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 2pi</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.pos_r","level":3,"title":"<code>pos_r: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 1</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.raw_spike_times","level":3,"title":"<code>raw_spike_times</code>  <code>property</code>","text":"<p>Return the spike times that fall within the slice without masking</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.rho","level":3,"title":"<code>rho: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 1</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.spike_index","level":3,"title":"<code>spike_index: np.ndarray</code>  <code>property</code>","text":"<p>Get the index into the LFP data of the spikes for this segment</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>the index into the LFP data of the spikes for this segment</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.xy_dist_to_peak_normed","level":3,"title":"<code>xy_dist_to_peak_normed: ma.MaskedArray</code>  <code>property</code>","text":"<p>Values lie between 0 and 1</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.expected_spikes","level":3,"title":"<code>expected_spikes(expected_rate_at_pos: np.ndarray, sample_rate: int = 50) -&gt; np.ndarray</code>","text":"<p>Calculates the expected number of spikes along this run given the whole ratemap.</p> <p>Parameters:</p> Name Type Description Default <code>expected_rate_at_pos</code> <code>ndarray</code> <p>the rate seen at each xy position of the whole trial</p> required <p>Returns:</p> Name Type Description <code>expected_rate</code> <code>ndarray</code> <p>the expected rate at each xy position of this run</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.mean_spiking_var","level":3,"title":"<code>mean_spiking_var(var='current_direction')</code>","text":"<p>Get the mean value of a variable at the posiition of the spikes for all runs through this field when multiple spikes occur in a single theta cycle</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.overdispersion","level":3,"title":"<code>overdispersion(spike_train: np.ndarray, fs: int = 50) -&gt; float</code>","text":"<p>The overdispersion map for this run</p> <p>Parameters:</p> Name Type Description Default <code>spike_train</code> <code>mdarray</code> <p>the spike train (spikes binned up by position) for the whole trial. Same length as the trial n_samples</p> required <code>fs</code> <code>int</code> <p>the sample rate of the position data</p> <code>50</code>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.smooth_xy","level":3,"title":"<code>smooth_xy(k: float, spatial_lp: int, sample_rate: int) -&gt; None</code>","text":"<p>Smooth in x and y in preparation for converting the smoothed cartesian coordinates to polar ones</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>float</code> <p>smoothing constant for the instantaneous firing rate</p> required <code>spatial_lp</code> <code>int</code> <p>spatial lowpass cut off</p> required <code>sample_rate</code> <code>int</code> <p>position sample rate in Hz</p> required","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.RunProps.spiking_var","level":3,"title":"<code>spiking_var(var='current_direction')</code>","text":"<p>Get the value of a variable at the position of spikes for this run</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment","level":2,"title":"<code>ephysiopy.common.fieldproperties.LFPSegment(parent, field_label: int, run_label: int, slice: slice, spike_times: np.ndarray, mask: np.ndarray, signal: np.ndarray, filtered_signal: np.ndarray, phase: np.ndarray, cycle_label: np.ndarray, sample_rate: float | int)</code>","text":"<p>               Bases: <code>SpikingProperty</code>, <code>object</code></p> <p>A custom class for dealing with segments of an LFP signal and how they relate to specific runs through a receptive field (see RunProps and FieldProps below)</p> <p>Attributes:</p> Name Type Description <code>field_label</code> <code>int</code> <p>The field id</p> <code>run_label</code> <code>int</code> <p>The run id</p> <code>slice</code> <code>slice</code> <p>slice into the LFP data for a segment</p> <code>spike_times</code> <code>ndarray</code> <p>the times in seconds spikes occurred for a segment</p> <code>spike_count</code> <code>ndarray</code> <p>spikes binned into lfp samples for a segment</p> <code>signal</code> <code>ndarray</code> <p>raw signal for a segment</p> <code>filtered_signal</code> <code>ndarray</code> <p>bandpass filtered signal for a segment</p> <code>phase</code> <code>ndarray</code> <p>phase data for a segment</p> <code>amplitude</code> <code>ndarray</code> <p>amplitude for a segment</p> <code>sample_rate</code> <code>(float, int)</code> <p>sample rate for the LFP segment</p> <code>filter_band</code> <code>tuple[int, int]</code> <p>the bandpass filter values</p> <p>field_label : int     the field id to which this LFP segment belongs run_label : int     the run id through the field to which this LFP segment belongs slice : slice     the slice corresponding the pos sample I think spike_count : np.ndarray     spikes binned into lfp samples signal, filtered_signal, phase, : np.ndarray     the raw, filtered, and phase of the LFP for a given segment sample_rate : int, float     the sample rate for the LFP signal filter_band : tuple     the bandpass filter giving filtered_signal</p> <p>Methods:</p> Name Description <code>mean_spiking_var</code> <p>Get the mean value of a variable at the posiition of</p> <code>spiking_var</code> <p>Get the value of a variable at the position of</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment.raw_spike_times","level":3,"title":"<code>raw_spike_times</code>  <code>property</code>","text":"<p>Return the spike times that fall within the slice without masking</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment.spike_index","level":3,"title":"<code>spike_index: np.ndarray</code>  <code>property</code>","text":"<p>Get the index into the LFP data of the spikes for this segment</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>the index into the LFP data of the spikes for this segment</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment.mean_spiking_var","level":3,"title":"<code>mean_spiking_var(var='phase')</code>","text":"<p>Get the mean value of a variable at the posiition of the spikes for all runs through this field when multiple spikes occur in a single theta cycle</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldproperties.LFPSegment.spiking_var","level":3,"title":"<code>spiking_var(var='phase')</code>","text":"<p>Get the value of a variable at the position of spikes for this run</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.sort_fields_by_attr","level":2,"title":"<code>ephysiopy.common.fieldcalcs.sort_fields_by_attr(field_props: list[FieldProps], attr='area', reverse=True)</code>","text":"<p>Sorts the fields in the list by attribute</p> Notes <p>In the default case will sort by area, largest first</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_all_phase","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_all_phase(field_props: list[FieldProps]) -&gt; np.ndarray</code>","text":"<p>Get all the phases from the field properties</p> <p>Parameters:</p> Name Type Description Default <code>field_props</code> <code>list of FieldProps</code> <p>The field properties to search through</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of all the phases from all runs in all fields</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_run_times","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_run_times(field_props: list[FieldProps]) -&gt; list</code>","text":"<p>Get the run start and stop times in seconds for all runs through all fields in the field_props list</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_run","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_run(field_props: list[FieldProps], run_num: int) -&gt; RunProps</code>","text":"<p>Get a specific run from the field properties</p> <p>Parameters:</p> Name Type Description Default <code>field_props</code> <code>list of FieldProps</code> <p>The field properties to search through</p> required <code>run_num</code> <code>int</code> <p>The run number to search for</p> required <p>Returns:</p> Type Description <code>RunProps</code> <p>The run properties for the specified run number</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.filter_runs","level":2,"title":"<code>ephysiopy.common.fieldcalcs.filter_runs(field_props: list[FieldProps], attributes, ops, vals, **kwargs) -&gt; list[FieldProps]</code>","text":"<p>Filter out runs that are too short, too slow or have too few spikes</p> <p>Parameters:</p> Name Type Description Default <code>field_props</code> <code>list of FieldProps</code> required <code>attributes</code> <code>list of str</code> <p>attributes of RunProps to filter on</p> required <code>ops</code> <code>list of str</code> <p>operations to use for filtering. Supported operations are np.less and np.greater</p> required <code>vals</code> <code>list of float</code> <p>values to filter on</p> required <p>Returns:</p> Type Description <code>list of FieldProps</code> Notes <p>this modifies the input list</p> Example <p>field_props = filter_runs(field_props, ['n_spikes'], [np.greater], [5])</p> <p>field_props now only contains runs with more than 5 spikes</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.filter_for_speed","level":2,"title":"<code>ephysiopy.common.fieldcalcs.filter_for_speed(field_props: list[FieldProps], min_speed: float) -&gt; list[FieldProps]</code>","text":"<p>Mask for low speeds across the list of fields / runs</p> <p>Parameters:</p> Name Type Description Default <code>field_props</code> <code>list of FieldProps</code> <p>The field properties to filter</p> required <code>min_speed</code> <code>float</code> <p>The minimum speed to keep a run</p> required <p>Returns:</p> Type Description <code>list of FieldProps</code> <p>The filtered field properties</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.infill_ratemap","level":2,"title":"<code>ephysiopy.common.fieldcalcs.infill_ratemap(rmap: np.ndarray) -&gt; np.ndarray</code>","text":"<p>The ratemaps used in the phasePrecession2D class are a) super smoothed and b) very large i.e. the bins per cm is low. This results in firing fields that have lots of holes (nans) in them. We want to smooth over these holes so we can construct measures such as the expected rate in a given bin whilst also preserving whatever 'geometry' of the environment exists in the ratemap as a result of where position has been sampled. That is, if non-sampled positions are designated with nans, we want to smooth over those that in theory could have been sampled and keep those that never could have been.</p> <p>Parameters:</p> Name Type Description Default <code>rmap</code> <code>ndarray</code> <p>The ratemap to be filled</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The filled ratemap</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_peak_coords","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_peak_coords(rmap, labels)</code>","text":"<p>Get the peak coordinates of the firing fields in the ratemap</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.simple_partition","level":2,"title":"<code>ephysiopy.common.fieldcalcs.simple_partition(binned_data: BinnedData, rate_threshold_prc: int = 200, **kwargs) -&gt; tuple[np.ndarray]</code>","text":"<p>Simple partitioning of fields based on mean firing rate. Only returns a single field (the highest firing rate field) per binned_data instance</p> <p>The default is to limit to fields that have a mean firing rate greater than twice the mean firing rate of the entire ratemap</p> <p>Parameters:</p> Name Type Description Default <code>binned_data</code> <code>BinnedData</code> <p>an instance of ephysiopy.common.utils.BinnedData</p> required <code>rate_threshold_prc</code> <code>int</code> <p>removes pixels in a field that fall below this percent of the mean firing rate</p> <code>200</code> <p>Returns:</p> Type Description <code>tuple of np.ndarray</code> <p>peaksXY - The xy coordinates of the peak rates in the highest firing field peaksRate - The peak rates in peaksXY labels - An array of the labels corresponding to the highest firing field rmap_filled - The filled ratemap of the tetrode / cluster</p> Notes <p>This is a simple method to partition fields that only returns a single field - the one with the highest mean firing rate.</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.fancy_partition","level":2,"title":"<code>ephysiopy.common.fieldcalcs.fancy_partition(binned_data: BinnedData, field_threshold_percent: int | float = 50, area_threshold_percent: float = 10) -&gt; tuple[np.ndarray, ...]</code>","text":"<p>Another partitioning method</p> <p>Parameters:</p> Name Type Description Default <code>binned_data</code> <code>BinnedData</code> required <code>field_threshold_percent</code> <code>int | float</code> <p>pixels below this are set to zero and ignored</p> <code>50</code> <code>area_threshold_percent</code> <code>float</code> <p>the expected minimum size of a receptive field</p> <code>10</code>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_mean_resultant","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_mean_resultant(ego_boundary_map: np.ndarray) -&gt; np.complex128 | float</code>","text":"<p>Calculates the mean resultant vector of a boundary map in egocentric coordinates</p> <p>Parameters:</p> Name Type Description Default <code>ego_boundary_map</code> <code>ndarray</code> <p>The egocentric boundary map</p> required <p>Returns:</p> Type Description <code>float</code> <p>The mean resultant vector of the egocentric boundary map</p> Notes <p>See Hinman et al., 2019 for more details</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_mean_resultant_length","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_mean_resultant_length(ego_boundary_map: np.ndarray, **kwargs) -&gt; float</code>","text":"<p>Calculates the length of the mean resultant vector of a boundary map in egocentric coordinates</p> <p>Parameters:</p> Name Type Description Default <code>ego_boundary_map</code> <code>ndarray</code> <p>The egocentric boundary map</p> required <p>Returns:</p> Type Description <code>float</code> <p>The length of the mean resultant vector of the egocentric boundary map</p> Notes <p>See Hinman et al., 2019 for more details</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_mean_resultant_angle","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_mean_resultant_angle(ego_boundary_map: np.ndarray, **kwargs) -&gt; float</code>","text":"<p>Calculates the angle of the mean resultant vector of a boundary map in egocentric coordinates</p> <p>Parameters:</p> Name Type Description Default <code>ego_boundary_map</code> <code>ndarray</code> <p>The egocentric boundary map</p> required <p>Returns:</p> Type Description <code>float</code> <p>The angle mean resultant vector of the egocentric boundary map</p> Notes <p>See Hinman et al., 2019 for more details</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.border_score","level":2,"title":"<code>ephysiopy.common.fieldcalcs.border_score(A, B=None, shape='square', fieldThresh=0.3, circumPrc=0.2, binSize=3.0, minArea=200)</code>","text":"<p>Calculates a border score totally dis-similar to that calculated in Solstad et al (2008)</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>the ratemap</p> required <code>B</code> <code>ndarray</code> <p>This should be a boolean mask where True (1) is equivalent to the presence of a border and False (0) is equivalent to 'open space'. Naievely this will be the edges of the ratemap but could be used to take account of boundary insertions/ creations to check tuning to multiple environmental boundaries. Default None: when the mask is None then a mask is created that has 1's at the edges of the ratemap i.e. it is assumed that occupancy = environmental shape</p> <code>None</code> <code>shape</code> <code>str</code> <p>description of environment shape. Currently only 'square' or 'circle' accepted. Used to calculate the proportion of the environmental boundaries to examine for firing</p> <code>'square'</code> <code>fieldThresh</code> <code>float</code> <p>Between 0 and 1 this is the percentage amount of the maximum firing rate to remove from the ratemap (i.e. to remove noise)</p> <code>0.3</code> <code>circumPrc</code> <code>float</code> <p>The percentage amount of the circumference of the environment that the field needs to be to count as long enough to make it through</p> <code>0.2</code> <code>binSize</code> <code>float</code> <p>bin size in cm</p> <code>3.0</code> <code>minArea</code> <code>float</code> <p>min area for a field to be considered</p> <code>200</code> <p>Returns:</p> Type Description <code>float</code> <p>the border score</p> Notes <p>If the cell is a border cell (BVC) then we know that it should fire at a fixed distance from a given boundary (possibly more than one). In essence this algorithm estimates the amount of variance in this distance i.e. if the cell is a border cell this number should be small. This is achieved by first doing a bunch of morphological operations to isolate individual fields in the ratemap (similar to the code used in phasePrecession.py - see the fancy_partition method therein). These partitioned fields are then thinned out (using skimage's skeletonize) to a single pixel wide field which will lie more or less in the middle of the (highly smoothed) sub-field. It is the variance in distance from the nearest boundary along this pseudo-iso-line that is the boundary measure</p> <p>Other things to note are that the pixel-wide field has to have some minimum length. In the case of a circular environment this is set to 20% of the circumference; in the case of a square environment markers this is at least half the length of the longest side</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.plot_field_props","level":2,"title":"<code>ephysiopy.common.fieldcalcs.plot_field_props(field_props: list[FieldProps])</code>","text":"<p>Plots the fields in the list of FieldProps</p> <p>Parameters:</p> Name Type Description Default <code>field_props</code> <code>list of FieldProps</code> <p>The field properties to plot</p> required","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.kl_spatial_sparsity","level":2,"title":"<code>ephysiopy.common.fieldcalcs.kl_spatial_sparsity(pos_map: BinnedData) -&gt; float</code>","text":"<p>Calculates the spatial sampling of an arena by comparing the observed spatial sampling to an expected uniform one using kl divergence</p> <p>Data in pos_map should be unsmoothed (not checked) and the MapType should be POS (checked)</p> <p>Parameters:</p> Name Type Description Default <code>pos_map</code> <code>BinnedData</code> <p>The position map</p> required <p>Returns:</p> Type Description <code>float</code> <p>The spatial sparsity of the position map</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.spatial_sparsity","level":2,"title":"<code>ephysiopy.common.fieldcalcs.spatial_sparsity(rate_map: np.ndarray, pos_map: np.ndarray) -&gt; float</code>","text":"<p>Calculates the spatial sparsity of a rate map as defined by Markus et al (1994)</p> <p>For example, a sparsity score of 0.10 indicates that the cell fired on 10% of the maze surface</p> <p>Parameters:</p> Name Type Description Default <code>rate_map</code> <code>ndarray</code> <p>The rate map</p> required <code>pos_map</code> <code>ndarray</code> <p>The occupancy map</p> required <p>Returns:</p> Type Description <code>float</code> <p>The spatial sparsity of the rate map</p> References <p>Markus, E.J., Barnes, C.A., McNaughton, B.L., Gladden, V.L. &amp; Skaggs, W.E. Spatial information content and reliability of hippocampal CA1 neurons: effects of visual input. Hippocampus 4, 410–421 (1994).</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.kldiv_dir","level":2,"title":"<code>ephysiopy.common.fieldcalcs.kldiv_dir(polarPlot: np.ndarray) -&gt; float</code>","text":"<p>Returns a kl divergence for directional firing: measure of directionality. Calculates kl diveregence between a smoothed ratemap (probably should be smoothed otherwise information theoretic measures don't 'care' about position of bins relative to one another) and a pure circular distribution. The larger the divergence the more tendancy the cell has to fire when the animal faces a specific direction.</p> <p>Parameters:</p> Name Type Description Default <code>polarPlot</code> <code>ndarray</code> <p>The binned and smoothed directional ratemap</p> required <p>Returns:</p> Type Description <code>float</code> <p>The divergence from circular of the 1D-array from a uniform circular distribution</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.kldiv","level":2,"title":"<code>ephysiopy.common.fieldcalcs.kldiv(X: np.ndarray, pvect1: np.ndarray, pvect2: np.ndarray, variant: str = '') -&gt; float</code>","text":"<p>Calculates the Kullback-Leibler or Jensen-Shannon divergence between two distributions.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Vector of M variable values</p> required <code>pvect1</code> <code>ndarray</code> <p>Length-M vectors of probabilities representing distribution 1 and 2</p> required <code>pvect2</code> <code>ndarray</code> <p>Length-M vectors of probabilities representing distribution 1 and 2</p> required <code>variant</code> <code>str</code> <p>If 'sym', returns a symmetric variant of the Kullback-Leibler divergence, given by [KL(P1,P2)+KL(P2,P1)]/2 If 'js', returns the Jensen-Shannon divergence, given by [KL(P1,Q)+KL(P2,Q)]/2, where Q = (P1+P2)/2</p> <code>'sym'</code> <p>Returns:</p> Type Description <code>float</code> <p>The Kullback-Leibler divergence or Jensen-Shannon divergence</p> Notes <p>The Kullback-Leibler divergence is given by:</p> <p>.. math:: KL(P1(x),P2(x)) = sum_[P1(x).log(P1(x)/P2(x))]</p> <p>If X contains duplicate values, there will be an warning message, and these values will be treated as distinct values.  (I.e., the actual values do not enter into the computation, but the probabilities for the two duplicate values will be considered as probabilities corresponding to two unique values.). The elements of probability vectors P1 and P2 must each sum to 1 ± .00001.</p> <p>This function is taken from one on the Mathworks file exchange</p> See Also <p>Cover, T.M. and J.A. Thomas. \"Elements of Information Theory,\" Wiley, 1991.</p> <p>https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.skaggs_info","level":2,"title":"<code>ephysiopy.common.fieldcalcs.skaggs_info(ratemap: np.ndarray, dwelltimes: np.ndarray, **kwargs)</code>","text":"<p>Calculates Skaggs information measure</p> <p>Parameters:</p> Name Type Description Default <code>ratemap</code> <code>ndarray</code> <p>The binned up ratemap and dwelltimes. Must be the same size</p> required <code>dwelltimes</code> <code>ndarray</code> <p>The binned up ratemap and dwelltimes. Must be the same size</p> required <p>Returns:</p> Type Description <code>float</code> <p>Skaggs information score in bits spike</p> Notes <p>The ratemap data should have undergone adaptive binning as per the original paper. See getAdaptiveMap() in binning class</p> <p>The estimate of spatial information in bits per spike:</p> <p>.. math:: I = sum_{x} p(x).r(x).log(r(x)/r)</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.grid_field_props","level":2,"title":"<code>ephysiopy.common.fieldcalcs.grid_field_props(A: BinnedData, maxima='centroid', allProps=True, **kwargs)</code>","text":"<p>Extracts various measures from a spatial autocorrelogram</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>BinnedData</code> <p>object containing the spatial autocorrelogram (SAC) in     A.binned_data[0]</p> required <code>maxima</code> <pre><code>Legal values are 'single' and 'centroid'. Default 'centroid'\n</code></pre> <code>'centroid'</code> <code>allProps</code> <code>bool default=True</code> <p>Whether to return a dictionary that contains the attempt to fit an ellipse around the edges of the central size peaks. See below</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>Measures of the SAC. Keys include:     * gridness score     * scale     * orientation     * coordinates of the peaks (nominally 6) closest to SAC centre     * a binary mask around the extent of the 6 central fields     * values of the rotation procedure used to calculate gridness     * ellipse axes and angle (if allProps is True and the it worked)</p> Notes <p>The output from this method can be used as input to the show() method of this class. When it is the plot produced will display a lot more informative. The coordinate system internally used is centred on the image centre.</p> See Also <p>ephysiopy.common.binning.autoCorr2D()</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.gridness","level":2,"title":"<code>ephysiopy.common.fieldcalcs.gridness(image, step=30) -&gt; tuple</code>","text":"<p>Calculates the gridness score in a grid cell SAC.</p> <p>The data in <code>image</code> is rotated in <code>step</code> amounts and each rotated array is correlated with the original. The maximum of the values at 30, 90 and 150 degrees is the subtracted from the minimum of the values at 60, 120 and 180 degrees to give the grid score.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>The spatial autocorrelogram</p> required <code>step</code> <code>int</code> <p>The amount to rotate the SAC in each step of the rotational correlation procedure</p> <code>30</code> <p>Returns:</p> Type Description <code>3 - tuple</code> <p>The gridscore, the correlation values at each <code>step</code> and the rotational array</p> Notes <p>The correlation performed is a Pearsons R. Some rescaling of the values in <code>image</code> is performed following rotation.</p> See Also <p>skimage.transform.rotate : for how the rotation of <code>image</code> is done skimage.exposure.rescale_intensity : for the resscaling following rotation</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_basic_gridscore","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_basic_gridscore(A: np.ndarray, **kwargs) -&gt; float</code>","text":"<p>Calculates the grid score of a spatial autocorrelogram</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>The spatial autocorrelogram</p> required <p>Returns:</p> Type Description <code>float</code> <p>The grid score of the SAC</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_expanding_circle_gridscore","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_expanding_circle_gridscore(A: np.ndarray, **kwargs)</code>","text":"<p>Calculates the gridscore for each circular sub-region of image A where the circles are centred on the image centre and expanded to the edge of the image. The maximum of the get_basic_gridscore() for each of these circular sub-regions is returned as the gridscore</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>The SAC</p> required <p>Returns:</p> Type Description <code>float</code> <p>The maximum grid score of the circular sub regions of the SAC</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_deformed_sac_gridscore","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_deformed_sac_gridscore(A: np.ndarray) -&gt; float</code>","text":"<p>Deforms a non-circular SAC into a circular SAC (circular meaning the ellipse drawn around the edges of the 6 nearest peaks to the SAC centre) and returns get_basic_griscore() calculated on the deformed (or re-formed?!) SAC</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>The SAC</p> required <p>Returns:</p> Type Description <code>float</code> <p>The gridscore of the deformed SAC</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"field_analysis/#ephysiopy.common.fieldcalcs.get_thigmotaxis_score","level":2,"title":"<code>ephysiopy.common.fieldcalcs.get_thigmotaxis_score(xy: np.ndarray, shape: str = 'circle') -&gt; float</code>","text":"<p>Returns a score which is the ratio of the time spent in the inner portion of an environment to the time spent in the outer portion. The portions are allocated so that they have equal area.</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>ndarray</code> <p>The xy coordinates of the animal's position. 2 x nsamples</p> required <code>shape</code> <code>str</code> <p>The shape of the environment. Legal values are 'circle' and 'square'</p> <code>'circle'</code> <p>Returns:</p> Type Description <code>float</code> <p>Values closer to 1 mean more time was spent in the inner portion of the environment. Values closer to -1 mean more time in the outer portion of the environment. A value of 0 indicates the animal spent equal time in both portions of the environment.</p>","path":["API reference","Firing field analysis"],"tags":[]},{"location":"installation/","level":1,"title":"Installation","text":"","path":["User Guide","Installation"],"tags":[]},{"location":"installation/#install-required-packages","level":2,"title":"Install required packages","text":"<ul> <li>uv</li> <li>ephysiopy</li> </ul>","path":["User Guide","Installation"],"tags":[]},{"location":"installation/#install-uv","level":3,"title":"Install uv","text":"<p>https://docs.astral.sh/uv/getting-started/installation/</p>","path":["User Guide","Installation"],"tags":[]},{"location":"installation/#install-ephysiopy","level":3,"title":"Install ephysiopy","text":"<p>This should install all the required packages to load data, plot the results etc</p> <pre><code>uv add ephysiopy\n</code></pre>","path":["User Guide","Installation"],"tags":[]},{"location":"io/","level":1,"title":"Data input/ output","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface","level":2,"title":"<code>ephysiopy.io.recording.TrialInterface(pname: Path, **kwargs)</code>","text":"<p>               Bases: <code>FigureMaker</code></p> <p>Defines a minimal and required set of methods for loading electrophysiology data recorded using Axona or OpenEphys (OpenEphysNWB is there but not used)</p> <p>Parameters:</p> Name Type Description Default <code>pname</code> <code>Path</code> required <p>Attributes:</p> Name Type Description <code>pname (str)</code> <code>the absolute pathname of the top-level data directory</code> <code>settings (dict)</code> <code>contains metadata about the trial</code> <code>PosCalcs (PosCalcsGeneric)</code> <code>contains the positional data for the trial</code> <code>RateMap</code> <code>RateMap</code> <p>A class for binning data</p> <code>EEGCalcs</code> <code>EEGCalcs</code> <p>For dealing with LFP data</p> <code>clusterData</code> <code>clusterData</code> <p>contains results of a spike sorting session (i.e. KiloSort)</p> <code>recording_start_time</code> <code>float</code> <p>the start time of the recording in seconds</p> <code>sync_message_file</code> <code>Path</code> <p>the location of the sync_message_file (OpenEphys)</p> <code>ttl_data</code> <code>dict</code> <p>ttl data including timestamps, ids and states</p> <code>accelerometer_data</code> <code>ndarray</code> <p>data relating to headstage accelerometers</p> <code>path2PosData</code> <code>Path</code> <p>location of the positional data</p> <code>mask_array</code> <code>MaskedArray</code> <p>contains the mask (if applied) for positional data</p> <code>filter</code> <code>TrialFilter</code> <p>contains details of the filter applied to the positional data</p> <p>Methods:</p> Name Description <code>load_pos_data</code> <p>Load the position data</p> <code>load_neural_data</code> <p>Load the neural data</p> <code>load_ttl</code> <code>load_cluster_data</code> <p>Load the cluster data (Kilosort/ Axona cut/ whatever else</p> <code>load_settings</code> <p>Loads the format specific settings file</p> <code>apply_filter</code> <p>Apply a mask to the recorded data. This will mask all the currently</p> <code>get_field_properties</code> <p>Gets the properties of a given field (area, runs through the field,</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_pos_data","level":3,"title":"<code>load_pos_data(ppm: int = 300, jumpmax: int = 100, *args, **kws)</code>  <code>abstractmethod</code>","text":"<p>Load the position data</p> <p>Parameters:</p> Name Type Description Default <code>ppm</code> <code>int</code> <p>pixels per metre</p> <code>300</code> <code>jumpmax</code> <code>int</code> <p>max jump in pixels between positions, more than this and the position is interpolated over</p> <code>100</code>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_neural_data","level":3,"title":"<code>load_neural_data(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Load the neural data</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_ttl","level":3,"title":"<code>load_ttl(*args, **kwargs) -&gt; bool</code>  <code>abstractmethod</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_cluster_data","level":3,"title":"<code>load_cluster_data(*args, **kwargs) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Load the cluster data (Kilosort/ Axona cut/ whatever else</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.load_settings","level":3,"title":"<code>load_settings(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Loads the format specific settings file</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.apply_filter","level":3,"title":"<code>apply_filter(*trial_filter: TrialFilter) -&gt; np.ndarray</code>","text":"<p>Apply a mask to the recorded data. This will mask all the currently loaded data (LFP, position etc)</p> <p>Parameters:</p> Name Type Description Default <code>trial_filter</code> <code>TrialFilter</code> <p>A namedtuple containing the filter name, start and end values name (str): The name of the filter start (float): The start value of the filter end (float): The end value of the filter</p> <p>Valid names are:     'dir' - the directional range to filter for         NB Following mathmatical convention, 0/360 degrees is         3 o'clock, 90 degrees is 12 o'clock, 180 degrees is         9 o'clock and 270 degrees     'speed' - min and max speed to filter for     'xrange' - min and max values to filter x pos values     'yrange' - same as xrange but for y pos     'time' - the times to keep / remove specified in ms</p> <p>Values are pairs specifying the range of values to filter for from the namedtuple TrialFilter that has fields 'start' and 'end' where 'start' and 'end' are the ranges to filter for</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of bools that is True where the mask is applied</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.TrialInterface.get_field_properties","level":3,"title":"<code>get_field_properties(cluster: int | list, channel: int | list, **kwargs) -&gt; list[FieldProps]</code>","text":"<p>Gets the properties of a given field (area, runs through the field, etc)</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int | list</code> <p>The cluster(s) to get the field properties for</p> required <code>channel</code> <code>int | list</code> <p>The channel(s) to get the field properties for</p> required <code>**kwargs</code> <p>partition : str     How the field is separated from the background. This is passed to     the fieldproperties function and can be used to specify the partition     to use for the field properties.</p> <pre><code>Valid options are 'simple' and 'fancy'\n\nOther kwargs get passed to get_rate_map and\nfieldprops, the most important of which may be\nhow the runs are split in fieldprops (options are\n'field' and 'clump_runs') which differ depending on\nif the position data is open-field (field) or linear track\nin which case you should probably use 'clunmp_runs'\n</code></pre> <code>{}</code> <p>Returns:</p> Type Description <code>list[FieldProps]</code> <p>A list of FieldProps namedtuples containing the properties of the field</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase","level":2,"title":"<code>ephysiopy.io.recording.OpenEphysBase(pname: Path, **kwargs)</code>","text":"<p>               Bases: <code>TrialInterface</code></p> <p>Methods:</p> Name Description <code>load_pos_data</code> <code>load_neural_data</code> <code>load_ttl</code> <code>load_cluster_data</code> <code>load_settings</code> <p>Load the settings.xml file associated with the recording</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_pos_data","level":3,"title":"<code>load_pos_data(ppm: int = 300, jumpmax: int = 100, *args, **kwargs) -&gt; None</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_neural_data","level":3,"title":"<code>load_neural_data(*args, **kwargs)</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_ttl","level":3,"title":"<code>load_ttl(*args, **kwargs) -&gt; bool</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_cluster_data","level":3,"title":"<code>load_cluster_data(removeNoiseClusters=True, *args, **kwargs) -&gt; bool</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.OpenEphysBase.load_settings","level":3,"title":"<code>load_settings(*args, **kwargs)</code>","text":"<p>Load the settings.xml file associated with the recording</p>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial","level":2,"title":"<code>ephysiopy.io.recording.AxonaTrial(pname: Path, **kwargs)</code>","text":"<p>               Bases: <code>TrialInterface</code></p> <p>Methods:</p> Name Description <code>load_pos_data</code> <code>load_neural_data</code> <code>load_ttl</code> <code>load_cluster_data</code> <code>load_settings</code>","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_pos_data","level":3,"title":"<code>load_pos_data(ppm: int = 300, jumpmax: int = 100, *args, **kwargs) -&gt; None</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_neural_data","level":3,"title":"<code>load_neural_data(*args, **kwargs)</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_ttl","level":3,"title":"<code>load_ttl(*args, **kwargs) -&gt; bool</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_cluster_data","level":3,"title":"<code>load_cluster_data(*args, **kwargs)</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"io/#ephysiopy.io.recording.AxonaTrial.load_settings","level":3,"title":"<code>load_settings(*args, **kwargs)</code>","text":"","path":["API reference","Data input/ output"],"tags":[]},{"location":"lfp/","level":1,"title":"Local field potential (LFP)","text":"","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric","level":2,"title":"<code>ephysiopy.common.ephys_generic.EEGCalcsGeneric(sig, fs)</code>","text":"<p>               Bases: <code>object</code></p> <p>Generic class for processing and analysis of EEG data</p> <p>Parameters:</p> Name Type Description Default <code>sig</code> <code>ndarray</code> <p>The signal (of the LFP data)</p> required <code>fs</code> <code>float</code> <p>The sample rate</p> required <p>Methods:</p> Name Description <code>__add__</code> <p>Adds two EEGCalcsGeneric objects together</p> <code>apply_mask</code> <p>Applies a mask to the signal</p> <code>butterFilter</code> <p>Filters self.sig with a butterworth filter with a bandpass filter</p> <code>calcEEGPowerSpectrum</code> <p>Calculates the power spectrum of self.sig</p> <code>ifftFilter</code> <p>Calculates the dft of signal and filters out the frequencies in</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.__add__","level":3,"title":"<code>__add__(other)</code>","text":"<p>Adds two EEGCalcsGeneric objects together</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>EEGCalcsGeneric</code> <p>The other EEGCalcsGeneric object to add</p> required <p>Returns:</p> Type Description <code>EEGCalcsGeneric</code> <p>A new EEGCalcsGeneric object with the combined sig and fs</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.apply_mask","level":3,"title":"<code>apply_mask(mask) -&gt; None</code>","text":"<p>Applies a mask to the signal</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>The mask to be applied. For use with np.ma.MaskedArray's mask attribute</p> required Notes <p>If mask is empty, the mask is removed The mask should be a list of tuples, each tuple containing the start and end times of the mask i.e. [(start1, end1), (start2, end2)] everything inside of these times is masked</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.butterFilter","level":3,"title":"<code>butterFilter(low: float, high: float, order: int = 5) -&gt; np.ndarray</code>","text":"<p>Filters self.sig with a butterworth filter with a bandpass filter defined by low and high</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>float</code> <p>the lower and upper bounds of the bandpass filter</p> required <code>high</code> <code>float</code> <p>the lower and upper bounds of the bandpass filter</p> required <code>order</code> <code>int</code> <p>the order of the filter</p> <code>5</code> <p>Returns:</p> Name Type Description <code>filt</code> <code>ndarray</code> <p>the filtered signal</p> Notes <p>the signal is filtered in both the forward and     reverse directions (scipy.signal.filtfilt)</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.calcEEGPowerSpectrum","level":3,"title":"<code>calcEEGPowerSpectrum(**kwargs)</code>","text":"<p>Calculates the power spectrum of self.sig</p> <p>Returns:</p> Name Type Description <code>freqs</code> <code>ndaray</code> <p>The frequencies at which the spectrogram was calculated</p> <code>power</code> <code>ndarray</code> <p>The power at the frequencies defined above</p> <code>sm_power</code> <code>ndarray</code> <p>The smoothed power</p> <code>bandmaxpower</code> <code>float</code> <p>The maximum power in the theta band</p> <code>freqatbandmaxpower</code> <code>float</code> <p>The frequency at which the power is maximum</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"lfp/#ephysiopy.common.ephys_generic.EEGCalcsGeneric.ifftFilter","level":3,"title":"<code>ifftFilter(sig, freqs, fs=250)</code>","text":"<p>Calculates the dft of signal and filters out the frequencies in freqs from the result and reconstructs the original signal using the inverse fft without those frequencies</p> <p>Parameters:</p> Name Type Description Default <code>sig</code> <code>ndarray</code> <p>the LFP signal to be filtered</p> required <code>freqs</code> <code>list</code> <p>the frequencies to be filtered out</p> required <code>fs</code> <code>int</code> <p>the sampling frequency of sig</p> <code>250</code> <p>Returns:</p> Name Type Description <code>fftRes</code> <code>ndarray</code> <p>the filtered LFP signal</p>","path":["API reference","Local field potential (LFP)"],"tags":[]},{"location":"misc_stats/","level":1,"title":"Miscellaneous statistical functions","text":"<p>Collected here are miscellaneous statistical functions that don't really fit anywhere else...</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.circ_r","level":2,"title":"<code>ephysiopy.common.statscalcs.circ_r(alpha, w=None, d=0, axis=0)</code>","text":"<p>Computes the mean resultant vector length for circular data.</p> <p>Args:     alpha (array or list): Sample of angles in radians.     w (array or list): Counts in the case of binned data.         Must be same length as alpha.     d (array or list, optional): Spacing of bin centres for binned data; if         supplied, correction factor is used to correct for bias in         estimation of r, in radians.     axis (int, optional): The dimension along which to compute.         Default is 0.</p> <p>Returns:     r (float): The mean resultant vector length.</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.z_normalize","level":2,"title":"<code>ephysiopy.common.statscalcs.z_normalize(scores: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Z-normalize an array of scores.</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.box_cox_normalize","level":2,"title":"<code>ephysiopy.common.statscalcs.box_cox_normalize(scores: np.ndarray, lam: float) -&gt; np.ndarray</code>","text":"<p>Box-Cox normalize an array of scores.</p> <p>Args:     scores (np.ndarray): The scores to normalize.     lam (float): The lambda parameter for Box-Cox transformation.</p> <p>Returns:     np.ndarray: The normalized scores.</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.mean_resultant_vector","level":2,"title":"<code>ephysiopy.common.statscalcs.mean_resultant_vector(angles)</code>","text":"<p>Calculate the mean resultant length and direction for angles.</p> <p>Args:     angles (np.array): Sample of angles in radians.</p> <p>Returns:     r (float): The mean resultant vector length.     th (float): The mean resultant vector direction.</p> <p>Notes: Taken from Directional Statistics by Mardia &amp; Jupp, 2000</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.rayleigh_test","level":2,"title":"<code>ephysiopy.common.statscalcs.rayleigh_test(angles: np.ndarray) -&gt; float</code>","text":"<p>Perform the Rayleigh test for uniformity of circular data.</p> <p>Args:     angles (array_like): Vector of angular values in radians.</p> <p>Returns:     Z (float): The Rayleigh test statistic.     p_value (float): The p-value for the test.</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.V_test","level":2,"title":"<code>ephysiopy.common.statscalcs.V_test(angles, test_direction)</code>","text":"<p>The Watson U2 tests whether the observed angles have a tendency to cluster around a given angle indicating a lack of randomness in the distribution. Also known as the modified Rayleigh test.</p> <p>Args:     angles (array_like): Vector of angular values in degrees.     test_direction (int): A single angular value in degrees.</p> <p>Notes:     For grouped data the length of the mean vector must be adjusted,     and for axial data all angles must be doubled.</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.duplicates_as_complex","level":2,"title":"<code>ephysiopy.common.statscalcs.duplicates_as_complex(x, already_sorted=False)</code>","text":"<p>Finds duplicates in x</p> <p>Args:     x (array_like): The list to find duplicates in.     already_sorted (bool, optional): Whether x is already sorted.         Default False.</p> <p>Returns:     x (array_like): A complex array where the complex part is the count of         the number of duplicates of the real value.</p> <p>Examples:     &gt;&gt;&gt;     x = [9.9, 9.9, 12.3, 15.2, 15.2, 15.2]     &gt;&gt;&gt; ret = duplicates_as_complex(x)     &gt;&gt;&gt;     print(ret)     [9.9+0j, 9.9+1j,  12.3+0j, 15.2+0j, 15.2+1j, 15.2+2j]</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.watsonsU2","level":2,"title":"<code>ephysiopy.common.statscalcs.watsonsU2(a, b)</code>","text":"<p>Tests whether two samples from circular observations differ significantly from each other with regard to mean direction or angular variance.</p> <p>Args:     a, b (array_like): The two samples to be tested</p> <p>Returns:     U2 (float): The test statistic</p> <p>Notes:     Both samples must come from a continuous distribution. In the case of     grouping the class interval should not exceed 5.     Taken from '100 Statistical Tests' G.J.Kanji, 2006 Sage Publications</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.watsonsU2n","level":2,"title":"<code>ephysiopy.common.statscalcs.watsonsU2n(angles)</code>","text":"<p>Tests whether the given distribution fits a random sample of angular values.</p> <p>Args:     angles (array_like): The angular samples.</p> <p>Returns:     U2n (float): The test statistic.</p> <p>Notes:     This test is suitable for both unimodal and the multimodal cases.     It can be used as a test for randomness.     Taken from '100 Statistical Tests' G.J.Kanji, 2006 Sage Publications.</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.watsonWilliams","level":2,"title":"<code>ephysiopy.common.statscalcs.watsonWilliams(a, b)</code>","text":"<p>The Watson-Williams F test tests whether a set of mean directions are equal given that the concentrations are unknown, but equal, given that the groups each follow a von Mises distribution.</p> <p>Args:     a, b (array_like): The directional samples</p> <p>Returns:     F_stat (float): The F-statistic</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.CircStatsResults","level":2,"title":"<code>ephysiopy.common.statscalcs.CircStatsResults(rho: float = np.nan, p: float = np.nan, rho_boot: float = np.nan, p_shuffled: float = np.nan, ci: float = np.nan)</code>  <code>dataclass</code>","text":"<p>Dataclass to hold results from circular statistics</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.RegressionResults","level":2,"title":"<code>ephysiopy.common.statscalcs.RegressionResults(name: str, phase: np.ndarray, regressor: np.ndarray, stats: CircStatsResults)</code>  <code>dataclass</code>","text":"","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.ccc","level":2,"title":"<code>ephysiopy.common.statscalcs.ccc(t, p)</code>","text":"<p>Calculates correlation between two random circular variables</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>The first variable</p> required <code>p</code> <code>ndarray</code> <p>The second variable</p> required <p>Returns:</p> Type Description <code>float</code> <p>The correlation between the two variables</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.ccc_jack","level":2,"title":"<code>ephysiopy.common.statscalcs.ccc_jack(t, p)</code>","text":"<p>Function used to calculate jackknife estimates of correlation between two circular random variables</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>The first variable</p> required <code>p</code> <code>ndarray</code> <p>The second variable</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The jackknife estimates of the correlation between the two variables</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.circCircCorrTLinear","level":2,"title":"<code>ephysiopy.common.statscalcs.circCircCorrTLinear(theta, phi, regressor=1000, alpha=0.05, hyp=0, conf=True)</code>","text":"<p>An almost direct copy from AJs Matlab fcn to perform correlation between 2 circular random variables.</p> <p>Returns the correlation value (rho), p-value, bootstrapped correlation values, shuffled p values and correlation values.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>ndarray</code> <p>The two circular variables to correlate (in radians)</p> required <code>phi</code> <code>ndarray</code> <p>The two circular variables to correlate (in radians)</p> required <code>regressor</code> <code>int</code> <p>number of permutations to use to calculate p-value from randomisation and bootstrap estimation of confidence intervals. Leave empty to calculate p-value analytically (NB confidence intervals will not be calculated).</p> <code>1000</code> <code>alpha</code> <code>float</code> <p>hypothesis test level e.g. 0.05, 0.01 etc.</p> <code>0.05</code> <code>hyp</code> <code>int</code> <p>hypothesis to test; -1/ 0 / 1 (-ve correlated / correlated in either direction / positively correlated).</p> <code>0</code> <code>conf</code> <code>bool</code> <p>True or False to calculate confidence intervals via jackknife or bootstrap.</p> <code>True</code> References <p>Fisher (1993), Statistical Analysis of Circular Data,     Cambridge University Press, ISBN: 0 521 56890 0</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.shuffledPVal","level":2,"title":"<code>ephysiopy.common.statscalcs.shuffledPVal(theta, phi, rho, regressor, hyp)</code>","text":"<p>Calculates shuffled p-values for correlation</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>ndarray</code> <p>The two circular variables to correlate (in radians)</p> required <code>phi</code> <code>ndarray</code> <p>The two circular variables to correlate (in radians)</p> required <p>Returns:</p> Type Description <code>float</code> <p>The shuffled p-value for the correlation between the two variables</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"misc_stats/#ephysiopy.common.statscalcs.circRegress","level":2,"title":"<code>ephysiopy.common.statscalcs.circRegress(x, t)</code>","text":"<p>Finds approximation to circular-linear regression for phase precession.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The linear variable and the phase variable (in radians)</p> required <code>t</code> <code>ndarray</code> <p>The linear variable and the phase variable (in radians)</p> required Notes <p>Neither x nor t can contain NaNs, must be paired (of equal length).</p>","path":["API reference","Miscellaneous statistical functions"],"tags":[]},{"location":"oe_settings/","level":1,"title":"OpenEphys settings","text":"<p>All of the plugins that sit in the OpenEphys signal chain are parsed out from the settings.xml file and take a similar format. They are available as the 'processors' OrderedDict of the Settings class.</p> <pre><code>trial.settings.processors.keys()\nodict_keys(['Acquisition Board 100', 'Bandpass Filter 107', 'LFP Viewer 102', 'TrackMe 103', 'Tracking Visual 105', 'StimControl 109', 'StimControl 110'])\n</code></pre> <p>The settings for each RecordNode is similarly avaialble as an OrderedDict in the 'record_nodes' attribute:</p> <pre><code>trial.settings.record_nodes.keys()\nodict_keys(['Record Node 101', 'Record Node 104'])\n</code></pre>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#record-nodes","level":2,"title":"Record nodes","text":"<p>The settings for the Record Nodes are saved as a dataclass:</p> <p>The settings for OpenEphys data are saved to a settings.xml file. This is loaded automatically when an OpenEphys trial object is created. Each OpenEphys plugin derives from the OEPlugin dataclass:</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.RecordNode","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.RecordNode(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0), path: str = str(), engine: str = str(), recordEvents: IntConversion = IntConversion(default=0), recordSpikes: IntConversion = IntConversion(default=0), isMainStream: IntConversion = IntConversion(default=0), sync_line: IntConversion = IntConversion(default=0), source_node_id: IntConversion = IntConversion(default=0), recording_state: str = str())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the RecordNode plugin.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>str</code> <p>The file path associated with the RecordNode.</p> <code>engine</code> <code>str</code> <p>The engine used by the RecordNode.</p> <code>recordEvents</code> <code>IntConversion</code> <p>Indicates if events are recorded, converted from a string.</p> <code>recordSpikes</code> <code>IntConversion</code> <p>Indicates if spikes are recorded, converted from a string.</p> <code>isMainStream</code> <code>IntConversion</code> <p>Indicates if this is the main stream, converted from a string.</p> <code>sync_line</code> <code>IntConversion</code> <p>The sync line, converted from a string.</p> <code>source_node_id</code> <code>IntConversion</code> <p>The source node ID, converted from a string.</p> <code>recording_state</code> <code>str</code> <p>The recording state of the RecordNode.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#openephys-plugins","level":2,"title":"OpenEphys plugins","text":"<p>It should be straightforawrd to create new classes that derive from OEPlugin when new plugins become available.</p> <p>There are some helper classes for doing string to int and float conversions:</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.OEPlugin","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.OEPlugin(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0))</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Documents an OE plugin.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the plugin.</p> <code>insertionPoint</code> <code>IntConversion</code> <p>The insertion point of the plugin, converted from a string.</p> <code>pluginName</code> <code>str</code> <p>The name of the plugin.</p> <code>type</code> <code>IntConversion</code> <p>The type of the plugin, converted from a string.</p> <code>index</code> <code>IntConversion</code> <p>The index of the plugin, converted from a string.</p> <code>libraryName</code> <code>str</code> <p>The name of the library.</p> <code>libraryVersion</code> <code>str</code> <p>The version of the library.</p> <code>processorType</code> <code>IntConversion</code> <p>The type of processor, converted from a string.</p> <code>nodeId</code> <code>IntConversion</code> <p>The node ID, converted from a string.</p> <code>channel_count</code> <code>IntConversion</code> <p>The number of channels, converted from a string.</p> <code>stream</code> <code>Stream</code> <p>The data stream associated with the plugin.</p> <code>sample_rate</code> <code>FloatConversion</code> <p>The sample rate, converted from a string.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.RhythmFPGA","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.RhythmFPGA(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0), channel_info: list[Channel] = list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Rhythm FPGA plugin.</p> <p>Attributes:</p> Name Type Description <code>channel_info</code> <code>list of Channel</code> <p>A list containing information about each channel.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.NeuropixPXI","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.NeuropixPXI(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0), channel_info: list[Channel] = list())</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Neuropixels-PXI plugin.</p> <p>Attributes:</p> Name Type Description <code>channel_info</code> <code>list of Channel</code> <p>A list containing information about each channel.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.AcquisitionBoard","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.AcquisitionBoard(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0), LowCut: FloatConversion = FloatConversion(default=0), HighCut: FloatConversion = FloatConversion(default=0))</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Acquisition Board plugin</p> <p>Attributes:</p> Name Type Description <code>LowCut</code> <code>FloatConversion</code> <p>The low cut-off frequency for the acquisition board.</p> <code>HighCut</code> <code>FloatConversion</code> <p>The high cut-off frequency for the acquisition board.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.BandpassFilter","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.BandpassFilter(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0), channels: list[int] = list(), low_cut: FloatConversion = FloatConversion(default=0), high_cut: FloatConversion = FloatConversion(default=0))</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Bandpass Filter plugin</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the plugin.</p> <code>pluginName</code> <code>str</code> <p>The display name of the plugin.</p> <code>pluginType</code> <code>int</code> <p>The type identifier for the plugin.</p> <code>libraryName</code> <code>str</code> <p>The library name of the plugin.</p> <code>channels</code> <code>list of int</code> <p>The list of channels to which the filter is applied.</p> <code>low_cut</code> <code>FloatConversion</code> <p>The low cut-off frequency for the bandpass filter.</p> <code>high_cut</code> <code>FloatConversion</code> <p>The high cut-off frequency for the bandpass filter.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackingPort","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.TrackingPort(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0))</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Tracking Port plugin which uses Bonsai input and Tracking Visual plugin for visualisation within OE</p> <p>Methods:</p> Name Description <code>load</code> <p>Load Tracking Port data from a specified path.</p> <code>load_times</code> <p>Load timestamps from a specified path.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackingPort.load","level":3,"title":"<code>load(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load Tracking Port data from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 2D numpy array with the position data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackingPort.load_times","level":3,"title":"<code>load_times(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load timestamps from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the timestamps file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the timestamps.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.PosTracker","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.PosTracker(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: IntConversion = IntConversion(default=30), Brightness: IntConversion = IntConversion(default=20), Contrast: IntConversion = IntConversion(default=20), Exposure: IntConversion = IntConversion(default=20), LeftBorder: IntConversion = IntConversion(default=0), RightBorder: IntConversion = IntConversion(default=800), TopBorder: IntConversion = IntConversion(default=0), BottomBorder: IntConversion = IntConversion(default=600), AutoExposure: bool = False, OverlayPath: bool = False)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the PosTracker plugin.</p> <p>Attributes:</p> Name Type Description <code>Brightness</code> <code>IntConversion</code> <p>Brightness setting for the tracker, default is 20.</p> <code>Contrast</code> <code>IntConversion</code> <p>Contrast setting for the tracker, default is 20.</p> <code>Exposure</code> <code>IntConversion</code> <p>Exposure setting for the tracker, default is 20.</p> <code>LeftBorder</code> <code>IntConversion</code> <p>Left border setting for the tracker, default is 0.</p> <code>RightBorder</code> <code>IntConversion</code> <p>Right border setting for the tracker, default is 800.</p> <code>TopBorder</code> <code>IntConversion</code> <p>Top border setting for the tracker, default is 0.</p> <code>BottomBorder</code> <code>IntConversion</code> <p>Bottom border setting for the tracker, default is 600.</p> <code>AutoExposure</code> <code>bool</code> <p>Auto exposure setting for the tracker, default is False.</p> <code>OverlayPath</code> <code>bool</code> <p>Overlay path setting for the tracker, default is False.</p> <code>sample_rate</code> <code>IntConversion</code> <p>Sample rate setting for the tracker, default is 30.</p> <p>Methods:</p> Name Description <code>load</code> <p>Load Tracking Port data from a specified path.</p> <code>load_times</code> <p>Load timestamps from a specified path.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.PosTracker.load","level":3,"title":"<code>load(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load Tracking Port data from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 2D numpy array with the position data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.PosTracker.load_times","level":3,"title":"<code>load_times(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load timestamps from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the timestamps file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the timestamps.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.TrackMe(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0))</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the TrackMe plugin.</p> <p>Methods:</p> Name Description <code>load</code> <p>Load TrackMe data from a specified path.</p> <code>load_times</code> <p>Load timestamps from a specified path.</p> <code>load_frame_count</code> <p>Load frame count data from a specified path.</p> <code>load_ttl_times</code> <p>Load TTL times from a specified path.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe.load","level":3,"title":"<code>load(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load TrackMe data from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 2D numpy array with the TrackMe data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe.load_frame_count","level":3,"title":"<code>load_frame_count(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load frame count data from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the data file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the frame count data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe.load_times","level":3,"title":"<code>load_times(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load timestamps from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the timestamps file.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the timestamps.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.TrackMe.load_ttl_times","level":3,"title":"<code>load_ttl_times(path2data: Path) -&gt; np.ndarray</code>","text":"<p>Load TTL times from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path2data</code> <code>Path</code> <p>The path to the directory containing the timestamps and states files.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the TTL times.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.StimControl","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.StimControl(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0), Device: IntConversion = IntConversion(default=0), Duration: IntConversion = IntConversion(default=0), Interval: IntConversion = IntConversion(default=0), Gate: IntConversion = IntConversion(default=0), Output: IntConversion = IntConversion(default=0), Start: IntConversion = IntConversion(default=0), Stop: IntConversion = IntConversion(default=0), Trigger: IntConversion = IntConversion(default=0))</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the StimControl plugin.</p> <p>Attributes:</p> Name Type Description <code>Device</code> <code>IntConversion</code> <p>Device setting for the StimControl, default is 0.</p> <code>Duration</code> <code>IntConversion</code> <p>Duration setting for the StimControl, default is 0.</p> <code>Interval</code> <code>IntConversion</code> <p>Interval setting for the StimControl, default is 0.</p> <code>Gate</code> <code>IntConversion</code> <p>Gate setting for the StimControl, default is 0.</p> <code>Output</code> <code>IntConversion</code> <p>Output setting for the StimControl, default is 0.</p> <code>Start</code> <code>IntConversion</code> <p>Start setting for the StimControl, default is 0.</p> <code>Stop</code> <code>IntConversion</code> <p>Stop setting for the StimControl, default is 0.</p> <code>Trigger</code> <code>IntConversion</code> <p>Trigger setting for the StimControl, default is 0.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.RippleDetector","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.RippleDetector(name: str = str(), insertionPoint: IntConversion = IntConversion(default=0), pluginName: str = str(), type: IntConversion = IntConversion(default=0), index: IntConversion = IntConversion(default=0), libraryName: str = str(), libraryVersion: str = str(), processorType: IntConversion = IntConversion(default=0), nodeId: IntConversion = IntConversion(default=0), channel_count: IntConversion = IntConversion(default=0), stream: Stream = Stream(), sample_rate: FloatConversion = FloatConversion(default=0), Ripple_Input: IntConversion = IntConversion(default=(-1)), Ripple_Out: IntConversion = IntConversion(default=(-1)), Ripple_save: IntConversion = IntConversion(default=(-1)), ripple_std: FloatConversion = FloatConversion(default=(-1)), time_thresh: FloatConversion = FloatConversion(default=(-1)), refr_time: FloatConversion = FloatConversion(default=(-1)), rms_samples: FloatConversion = FloatConversion(default=(-1)), ttl_duration: FloatConversion = FloatConversion(default=(-1)), ttl_percent: FloatConversion = FloatConversion(default=(-1)), mov_detect: IntConversion = IntConversion(default=(-1)), mov_input: IntConversion = IntConversion(default=(-1)), mov_out: IntConversion = IntConversion(default=(-1)), mov_std: FloatConversion = FloatConversion(default=(-1)), min_time_st: FloatConversion = FloatConversion(default=(-1)), min_time_mov: FloatConversion = FloatConversion(default=(-1)))</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OEPlugin</code></p> <p>Documents the Ripple Detector plugin.</p> <p>Attributes:</p> Name Type Description <code>Ripple_Input</code> <code>IntConversion</code> <p>Input setting for the Ripple Detector, default is -1.</p> <code>Ripple_Out</code> <code>IntConversion</code> <p>Output setting for the Ripple Detector, default is -1.</p> <code>Ripple_save</code> <code>IntConversion</code> <p>Save setting for the Ripple Detector, default is -1.</p> <code>ripple_std</code> <code>FloatConversion</code> <p>Standard deviation setting for the Ripple Detector, default is -1.</p> <code>time_thresh</code> <code>FloatConversion</code> <p>Time threshold setting for the Ripple Detector, default is -1.</p> <code>refr_time</code> <code>FloatConversion</code> <p>Refractory time setting for the Ripple Detector, default is -1.</p> <code>rms_samples</code> <code>FloatConversion</code> <p>RMS samples setting for the Ripple Detector, default is -1.</p> <code>ttl_duration</code> <code>FloatConversion</code> <p>TTL duration setting for the Ripple Detector, default is -1.</p> <code>ttl_percent</code> <code>FloatConversion</code> <p>TTL percent setting for the Ripple Detector, default is -1.</p> <code>mov_detect</code> <code>IntConversion</code> <p>Movement detection setting for the Ripple Detector, default is -1.</p> <code>mov_input</code> <code>IntConversion</code> <p>Movement input setting for the Ripple Detector, default is -1.</p> <code>mov_out</code> <code>IntConversion</code> <p>Movement output setting for the Ripple Detector, default is -1.</p> <code>mov_std</code> <code>FloatConversion</code> <p>Movement standard deviation setting for the Ripple Detector, default is -1.</p> <code>min_time_st</code> <code>FloatConversion</code> <p>Minimum time setting for the Ripple Detector, default is -1.</p> <code>min_time_mov</code> <code>FloatConversion</code> <p>Minimum movement time setting for the Ripple Detector, default is -1.</p> <p>Methods:</p> Name Description <code>load_ttl</code> <p>Load TTL data from a specified path and trial start time.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.RippleDetector.load_ttl","level":3,"title":"<code>load_ttl(path2TTL: Path, trial_start_time: float) -&gt; dict</code>","text":"<p>Load TTL data from a specified path and trial start time.</p> <p>Parameters:</p> Name Type Description Default <code>path2TTL</code> <code>Path</code> <p>The path to the directory containing the TTL data files.</p> required <code>trial_start_time</code> <code>float</code> <p>The start time of the trial.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the TTL timestamps and other related data.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.IntConversion","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.IntConversion(*, default)</code>","text":"<p>Descriptor class for converting attribute values to integers.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>int</code> <p>The default value to return if the attribute is not set.</p> required <p>Methods:</p> Name Description <code>__set_name__</code> <p>Sets the internal name for the attribute.</p> <code>__get__</code> <p>Retrieves the attribute value, returning the default if not set.</p> <code>__set__</code> <p>Sets the attribute value, converting it to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>int</code> <p>The default value to return if the attribute is not set.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.IntConversion.__get__","level":3,"title":"<code>__get__(obj, type)</code>","text":"<p>Retrieve the attribute value.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The instance of the owner class.</p> required <code>type</code> <code>type</code> <p>The owner class type.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The attribute value or the default value if not set.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.IntConversion.__set__","level":3,"title":"<code>__set__(obj, value)</code>","text":"<p>Set the attribute value, converting it to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The instance of the owner class.</p> required <code>value</code> <code>any</code> <p>The value to set, which will be converted to an integer.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.IntConversion.__set_name__","level":3,"title":"<code>__set_name__(owner, name)</code>","text":"<p>Set the internal name for the attribute.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>type</code> <p>The owner class where the descriptor is defined.</p> required <code>name</code> <code>str</code> <p>The name of the attribute.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.FloatConversion","level":2,"title":"<code>ephysiopy.openephys2py.OESettings.FloatConversion(*, default)</code>","text":"<p>Descriptor class for converting attribute values to floats.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>float</code> <p>The default value to return if the attribute is not set.</p> required <p>Methods:</p> Name Description <code>__set_name__</code> <p>Sets the internal name for the attribute.</p> <code>__get__</code> <p>Retrieves the attribute value, returning the default if not set.</p> <code>__set__</code> <p>Sets the attribute value, converting it to a float.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>float</code> <p>The default value to return if the attribute is not set.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.FloatConversion.__get__","level":3,"title":"<code>__get__(obj, type)</code>","text":"<p>Retrieve the attribute value.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The instance of the owner class.</p> required <code>type</code> <code>type</code> <p>The owner class type.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The attribute value or the default value if not set.</p>","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.FloatConversion.__set__","level":3,"title":"<code>__set__(obj, value)</code>","text":"<p>Set the attribute value, converting it to a float.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The instance of the owner class.</p> required <code>value</code> <code>any</code> <p>The value to set, which will be converted to a float.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"oe_settings/#ephysiopy.openephys2py.OESettings.FloatConversion.__set_name__","level":3,"title":"<code>__set_name__(owner, name)</code>","text":"<p>Set the internal name for the attribute.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>type</code> <p>The owner class where the descriptor is defined.</p> required <code>name</code> <code>str</code> <p>The name of the attribute.</p> required","path":["API reference","OpenEphys settings"],"tags":[]},{"location":"phase_precession/","level":1,"title":"Phase precession","text":"<p>There are basically two different types of phase precession analysis currently possible but I've attempted to capture both in one class, phasePrecessionND.</p> <p>This design decision is reflected in the way that data is extracted from firing rate maps and the runs through them in the fieldprops function and the FieldProps and RunProps classes that function creates</p> <p>However, it still makes sense to separate out 1D and 2D phase precession analysis to some degree as they are quite different. That is why there is a separate module for dealing with linear track data; the functions in the plotting sub-module of the phase_precession module are concerned with plotting linear track data not open-field 2D data.</p> <p>The 2D phase precession analysis is heavily indebted to the following paper:</p> <p>Jeewajee A, Barry C, Douchamps V, Manson D, Lever C, Burgess N.     Theta phase precession of grid and place cell firing in open     environments.     Philos Trans R Soc Lond B Biol Sci. 2013 Dec 23;369(1635):20120532.     doi: 10.1098/rstb.2012.0532.</p> <p>As with the analysis of replay data, phase precession analyses are heavily contingent on how things like firing rate maps are extracted, what the window sizes are for binning up spike trains, what your inclusion/ exclusion criteria are for things like good runs/ good firing fields etc. Whilst not infintely flexible, there are many options available when you run these analyses. Look at the documentation but also the source code and raise an issue(s) on github if any mistakes are found/ improvements can be made (they definitely can!)</p> <p>Many of the settings used in the analysis can be changed by altering the values in the following dictionaries that are used as input to the phase precession classes:</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.config.phase_precession_config","level":2,"title":"<code>ephysiopy.phase_precession.config.phase_precession_config = {'pos_sample_rate': 50, 'lfp_sample_rate': 250, 'cms_per_bin': 1, 'ppm': 445, 'field_smoothing_kernel_len': 7, 'field_smoothing_kernel_sigma': 5, 'field_threshold': 0.5, 'field_threshold_percent': 20, 'area_threshold': 0.01, 'bins_per_cm': 1, 'convert_xy_2_cm': True, 'allowed_min_spike_phase': np.pi, 'min_power_percent_threshold': 0, 'min_theta': 6, 'max_theta': 12, 'speed_smoothing_window_len': 15, 'minimum_allowed_run_speed': 0.5, 'minimum_allowed_run_duration': 1, 'min_spikes': 1, 'ifr_smoothing_constant': 1.0 / 3, 'spatial_lowpass_cutoff': 3, 'ifr_kernel_len': 1, 'ifr_kernel_sigma': 0.5, 'bins_per_second': 50}</code>  <code>module-attribute</code>","text":"<p>A list of the regressors that can be used in the phase precession analysis</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.config.all_regressors","level":2,"title":"<code>ephysiopy.phase_precession.config.all_regressors = ['spk_numWithinRun', 'pos_exptdRate_cum', 'pos_instFR', 'pos_timeInRun', 'pos_d_cum', 'pos_d_meanDir', 'pos_d_currentdir', 'spk_thetaBatchLabelInRun']</code>  <code>module-attribute</code>","text":"","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.phase_precession.phasePrecessionND","level":2,"title":"<code>ephysiopy.phase_precession.phase_precession.phasePrecessionND(T: AxonaTrial, cluster: int, channel: int, pp_config: dict = phase_precession_config, regressors=None, **kwargs)</code>","text":"<p>               Bases: <code>object</code></p> <p>Performs phase precession analysis for single unit data</p> <p>Mostly a rip-off of code written by Ali Jeewajee for his paper on 2D phase precession in place and grid cells [1]_</p> <p>.. [1] Jeewajee A, Barry C, Douchamps V, Manson D, Lever C, Burgess N.     Theta phase precession of grid and place cell firing in open     environments.     Philos Trans R Soc Lond B Biol Sci. 2013 Dec 23;369(1635):20120532.     doi: 10.1098/rstb.2012.0532.</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>AxonaTrial (or OpenEphysBase eventually)</code> <p>The trial object holding position, LFP, spiking and ratemap stuff</p> required <code>cluster</code> <code>int</code> <p>the cluster to examine</p> required <code>channel</code> <code>int</code> <p>The channel the cluster was recorded on</p> required <code>pp_config</code> <code>dict</code> <p>Contains parameters for running the analysis. See phase_precession_config dict in ephysiopy.common.eegcalcs</p> <code>phase_precession_config</code> <code>regressors</code> <code>list</code> <p>A list of the regressors to use in the analysis</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>orig_xy</code> <code>ndarray</code> <p>The original position data</p> <code>spike_ts</code> <code>ndarray</code> <p>The spike timestamps</p> <code>regressors</code> <code>dict</code> <p>A dictionary containing the regressors and their values</p> <code>alpha</code> <code>float</code> <p>The alpha value for hypothesis testing</p> <code>hyp</code> <code>int</code> <p>The hypothesis to test</p> <code>conf</code> <code>bool</code> <p>Whether to calculate confidence intervals</p> <code>eeg</code> <code>ndarray</code> <p>The EEG signal</p> <code>min_theta</code> <code>int</code> <p>The minimum theta frequency</p> <code>max_theta</code> <code>int</code> <p>The maximum theta frequency</p> <code>filteredEEG</code> <code>ndarray</code> <p>The filtered EEG signal</p> <code>phase</code> <code>ndarray</code> <p>The phase of the EEG signal</p> <code>phaseAdj</code> <code>MaskedArray</code> <p>The adjusted phase of the EEG signal as a masked array</p> <code>spike_times_in_pos_samples</code> <code>ndarray</code> <p>The spike times in position samples (vector with length = npos)</p> <code>spk_weights</code> <code>ndarray</code> <p>The spike weights (vector with length = npos)</p> <p>Methods:</p> Name Description <code>do_correlation</code> <p>Do the regression(s) for each regressor in the phase_regressors dict,</p> <code>do_regression</code> <p>Wrapper function for doing the actual regression which has multiple</p> <code>get_phase_reg_per_field</code> <p>Extracts the phase and all regressors for all runs through each</p> <code>get_pos_props</code> <p>Uses the output of fancy_partition and returns vectors the same</p> <code>get_theta_props</code> <p>Processes the LFP data and inserts into each run within each field</p> <code>plot_regressor</code> <p>Plot the regressor against the phase</p> <code>update_config</code> <p>Update the relevant pp_config values</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.phase_precession.phasePrecessionND.do_correlation","level":3,"title":"<code>do_correlation(phase_regressors: dict, **kwargs) -&gt; list[RegressionResults]</code>","text":"<p>Do the regression(s) for each regressor in the phase_regressors dict, optionally plotting the results of the regression</p> <p>Parameters:</p> Name Type Description Default <code>phase_regressors</code> <code>dict</code> <p>Dictionary with keys as field label (1,2 etc), each key contains a dictionary with keys 'phase' and optional nummbers of regressors</p> required Notes <p>This collapses across fields and does the regression for all phase and regressor values</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.phase_precession.phasePrecessionND.do_regression","level":3,"title":"<code>do_regression(**kwargs)</code>","text":"<p>Wrapper function for doing the actual regression which has multiple stages.</p> <p>Specifically here we partition fields into sub-fields, get a bunch of information about the position, spiking and theta data and then do the actual regression.</p> <p>**kwargs     do_plot : bool         whether to plot the results of the regression(s)     ax : matplotlib.mat         The axes to plot into</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.phase_precession.phasePrecessionND.get_phase_reg_per_field","level":3,"title":"<code>get_phase_reg_per_field(fp: list[FieldProps], **kwargs) -&gt; dict</code>","text":"<p>Extracts the phase and all regressors for all runs through each field separately</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>list</code> <p>A list of FieldProps instances</p> required <p>Returns:</p> Type Description <code>dict</code> <p>two-level dictionary holding regression results per field first level keys are field number second level are the regressors (current_dir etc) items in the second dict are the regression results</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.phase_precession.phasePrecessionND.get_pos_props","level":3,"title":"<code>get_pos_props(binned_data: BinnedData = None, var_type: VariableToBin = VariableToBin.XY, **kwargs) -&gt; list</code>","text":"<p>Uses the output of fancy_partition and returns vectors the same length as pos.</p> <p>Parameters:</p> Name Type Description Default <code>binned_data</code> <code>BinnedData</code> <p>optional BinnedData instance. Will be calculated here if not given</p> <code>None</code> <code>var_type</code> <code>VariableToBin</code> <p>defines if we are dealing with 1- or 2D data essentially</p> <code>XY</code> <code>**kwargs</code> <p>valid kwargs:     field_threshold - see fancy_partition()     field_threshold_percent - see fancy_partition()     area_threshold - see fancy_partition()</p> <code>{}</code> <p>Returns:</p> Type Description <code>list of FieldProps</code> <p>A list of FieldProps instances (see ephysiopy.common.fieldcalcs.FieldProps)</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.phase_precession.phasePrecessionND.get_theta_props","level":3,"title":"<code>get_theta_props(field_props: list[FieldProps])</code>","text":"<p>Processes the LFP data and inserts into each run within each field a segment of LFP data that has had its phase and amplitude extracted as well as some other data</p> <p>Parameters:</p> Name Type Description Default <code>field_props</code> <code>list[FieldProps]</code> <p>A list of FieldProps instances</p> required <p>Returns:</p> Type Description <code>list of FieldProps</code> <p>The amended list with LFP data added to each run for each field</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.phase_precession.phasePrecessionND.plot_regressor","level":3,"title":"<code>plot_regressor(regressor: str, vals: np.ndarray, pha: np.ndarray, result: CircStatsResults, ax=None)</code>","text":"<p>Plot the regressor against the phase</p> <p>Parameters:</p> Name Type Description Default <code>regressor</code> <code>str</code> <p>The regressor to plot</p> required <code>ax</code> <code>Axes</code> <p>The axes to plot on</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>Axes</code> <p>The axes with the plot</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.phase_precession.phasePrecessionND.update_config","level":3,"title":"<code>update_config(pp_config)</code>","text":"<p>Update the relevant pp_config values</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#linear-track-phase-precession","level":2,"title":"Linear track phase precession","text":"","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.linear_track.run_phase_analysis","level":2,"title":"<code>ephysiopy.phase_precession.linear_track.run_phase_analysis(trial: AxonaTrial, cluster: int, channel: int, **kwargs) -&gt; list[RegressionResults]</code>","text":"<p>Run the phase analysis on a linear track trial.</p> <p>Parameters:</p> Name Type Description Default <code>trial</code> <code>AxonaTrial</code> required <code>cluster</code> <code>int</code> required <code>channel</code> <code>int</code> required <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>list[RegressionResults] - list of RegressionResults</code> <p>ordered by the field id and the regression results for that field</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.linear_track.fieldprops_phase_precession","level":2,"title":"<code>ephysiopy.phase_precession.linear_track.fieldprops_phase_precession(P: phasePrecessionND, **kwargs)</code>","text":"<p>Run the phase analysis on a linear track trial.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>phasePrecessionND</code> <pre><code>                trial, cluster and channel information\n</code></pre> required <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>tuple - (phase_pos, f_props, run_direction, n_fields, P) where:</code> <code>phase_pos (np.ndarray) - the position of each spike in the phase precession</code> <p>analysis, normalised to the field limits and the run direction (east or west)</p> <code>f_props (list[FieldProps]) - the field properties for each field in the linear</code> <p>track trial, with the LFPSegment instance attached</p> <code>run_direction (str) - the run direction (east or west) for the linear track trial</code> <code>n_fields (int) - the number of fields in the linear track trial</code> <code>P (phasePrecessionND) - the phasePrecessionND instance containing the</code> <p>trial, cluster and channel information, with the field properties and phase positions attached</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.linear_track.get_field_props_for_linear_track","level":2,"title":"<code>ephysiopy.phase_precession.linear_track.get_field_props_for_linear_track(P: phasePrecessionND, var_type=VariableToBin.X, **kwargs) -&gt; list[FieldProps]</code>","text":"<p>Get the field properties for a linear track trial.</p> <p>Filters the linear track data based on speed, direction (east or west; larger ranges than the usual 90degs are used), and position (masks the start and end 12cm of the track)</p> Paraemters <p>trial (AxonaTrial) - the trial cluster (int) - the cluster id channel (int) - the channel id</p> <p>kwargs (dict) - additional parameters to pass to the                 get_rate_map() function and additionally apply                 filtering to the result of that (a BinnedData                 instance). Rationale is that sometimes we might                 want to limit the field extent according to                 different criteria, e.g. field size in bins,                 field rate threshold (mean, peak, etc.), etc.</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.linear_track.apply_linear_track_filter","level":2,"title":"<code>ephysiopy.phase_precession.linear_track.apply_linear_track_filter(T: AxonaTrial, run_direction=None, var_type=VariableToBin.X, track_end_size=6)</code>","text":"","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.linear_track.get_run_direction","level":2,"title":"<code>ephysiopy.phase_precession.linear_track.get_run_direction(run: RunProps)</code>","text":"","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.linear_track.add_normalised_run_position","level":2,"title":"<code>ephysiopy.phase_precession.linear_track.add_normalised_run_position(f_props: list[FieldProps]) -&gt; list[FieldProps]</code>","text":"<p>Adds the normalised run position to each run through a field in field_props where the run x position is normalised with respect to the field x position limits and the run direction (east or west)</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.linear_track.plot_linear_runs","level":2,"title":"<code>ephysiopy.phase_precession.linear_track.plot_linear_runs(f_props: list[FieldProps], var: str = 'speed', **kwargs)</code>","text":"<p>Plots the runs through the field(s) on a linear track as a sort of raster plot with each run as a separate line on the y-axis with ticks for each spike occurring on each run. For each run the height of</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#plotting-phase-precssion-results","level":2,"title":"Plotting phase precssion results","text":"","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.plot_phase_precession","level":2,"title":"<code>ephysiopy.phase_precession.plotting.plot_phase_precession(phase, normalised_position, slope, intercept, ax=None, **kwargs)</code>","text":"<p>Plot the phase precession of spikes in a field.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>ndarray</code> <p>The phase of the LFP signal at each spike time.</p> required <code>normalised_position</code> <code>ndarray</code> <p>The normalised position of the animal at each spike time.</p> required <code>slope</code> <code>float</code> <p>The slope of the phase precession.</p> required <code>intercept</code> <code>float</code> <p>The intercept of the phase precession.</p> required <code>ax</code> <code>Axes</code> <p>Axes to plot on. If None, a new figure and axes will be created.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for plotting.</p> <code>{}</code>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.plot_runs_and_precession","level":2,"title":"<code>ephysiopy.phase_precession.plotting.plot_runs_and_precession(trial: AxonaTrial, cluster: int, channel: int, field_props: list[FieldProps])</code>","text":"<p>Plot runs versus time where the colour of the line indicates directional heading. The field limits are also plotted and spikes are overlaid on the runs. Boxes delineate the runs that have been identified in field_props. Also plots phase precession for each field.</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.plot_field_and_runs","level":2,"title":"<code>ephysiopy.phase_precession.plotting.plot_field_and_runs(trial: AxonaTrial, field_props: list[FieldProps])</code>","text":"<p>Parameters:</p> Name Type Description Default <code>trial</code> <code>AxonaTrial</code> <p>The trial containing the position and spike data.</p> required <code>field_props</code> <code>list[FieldProps]</code> <p>List of FieldProps objects containing run and LFP data.</p> required Notes <p>Plot runs versus time where the colour of the line indicates directional heading. The field limits are also plotted and spikes are overlaid on the runs. Boxes delineate the runs that have been identified in field_props</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.plot_phase_v_position","level":2,"title":"<code>ephysiopy.phase_precession.plotting.plot_phase_v_position(field_props: list[FieldProps], ax=None, **kwargs)</code>","text":"<p>Plot the phase of the LFP signal at each position in the field.</p> <p>Parameters:</p> Name Type Description Default <code>field_props</code> <code>list[FieldProps]</code> <p>List of FieldProps objects containing run and LFP data.</p> required <code>ax</code> <code>Axes</code> <p>Axes to plot on. If None, a new figure and axes will be created.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for plotting.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes with the plot.</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.ratemap_line_graph","level":2,"title":"<code>ephysiopy.phase_precession.plotting.ratemap_line_graph(binned_data: BinnedData, ax=None, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plot a line graph of the rate map.</p> <p>Parameters:</p> Name Type Description Default <code>binned_data</code> <code>BinnedData</code> <p>The binned data containing the rate map.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for plotting.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes with the plot.</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.add_fields_to_line_graph","level":2,"title":"<code>ephysiopy.phase_precession.plotting.add_fields_to_line_graph(f_props: list[FieldProps], ax=None) -&gt; plt.Axes</code>","text":"<p>Add field boundaries to a line graph of the rate map.</p> <p>Parameters:</p> Name Type Description Default <code>f_props</code> <code>list[FieldProps]</code> <p>List of FieldProps containing field information.</p> required <p>Returns:</p> Type Description <code>Axes</code> <p>The axes with the field boundaries added.</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.plot_lfp_and_spikes_per_run","level":2,"title":"<code>ephysiopy.phase_precession.plotting.plot_lfp_and_spikes_per_run(f_props: list[FieldProps]) -&gt; plt.Axes</code>","text":"<p>Plot the LFP and spikes per run.</p> <p>Parameters:</p> Name Type Description Default <code>f_props</code> <code>list[FieldProps]</code> <p>List of FieldProps containing field information.</p> required <p>Returns:</p> Type Description <code>Axes</code> <p>The axes with the plot.</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.plot_lfp_segment","level":2,"title":"<code>ephysiopy.phase_precession.plotting.plot_lfp_segment(field: FieldProps, lfp_sample_rate: int = 250)</code>","text":"<p>Plot the lfp segments for a series of runs through a field including the spikes emitted by the cell.</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.plot_lfp_run","level":2,"title":"<code>ephysiopy.phase_precession.plotting.plot_lfp_run(run: RunProps, cycle_labels: np.ndarray = None, lfp_sample_rate: int = 250, **kwargs)</code>","text":"<p>Plot the lfp segment for a single run through a field including the spikes emitted by the cell.</p> Notes <p>There are very small inaccuracies here due to the way the timebase is being created from the slice belonging to the run and the way the indexing is being done by repeating the indices (repeat_ind) of the spike counts binned wrt the LFP sample rate. This shouldn;t matter for purposes of plotting - it's only when you zoom in a lot that you can see the diffferences between this and the actual spike times etc (if you can be arsed to plot them)</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"phase_precession/#ephysiopy.phase_precession.plotting.plot_spikes_in_runs_per_field","level":2,"title":"<code>ephysiopy.phase_precession.plotting.plot_spikes_in_runs_per_field(field_label: np.ndarray, run_starts: np.ndarray, run_ends: np.ndarray, spikes_in_time: np.ndarray, ttls_in_time: np.ndarray | None = None, **kwargs)</code>","text":"<p>Debug plotting to show spikes per run per field found in the ratemap as a raster plot</p> <p>Parameters:</p> Name Type Description Default <code>field_label</code> <code>ndarray</code> <p>The field labels for each position bin a vector</p> required <code>run_starts</code> <code>ndarray</code> <p>The start indices of each run (vectors)</p> required <code>run_ends</code> <code>ndarray</code> <pre><code>The stop indices of each run (vectors)\n</code></pre> required <code>spikes_in_time</code> <code>ndarray</code> <p>The number of spikes in each position bin (vector)</p> required <code>ttls_in_time</code> <code>ndarray</code> <p>TTL occurences in time (vector)</p> <code>None</code> <code>**kwargs</code> <p>separate_plots : bool     If True then each field will be plotted in a separate figure single_axes : bool     If True will plot all the runs/ spikes in a single axis with fields delimited by horizontal lines</p> <code>{}</code> <p>Returns:</p> Type Description <code>fig, axes : tuple</code> <p>The figure and axes objects</p>","path":["API reference","Phase precession"],"tags":[]},{"location":"plotting/","level":1,"title":"Plotting functions","text":"<p>All of these plotting functions are part of a mixin class that is available to OpenEphysBase and AxonaTrial via the base class TrialInterface.</p> <p>Many of the plotting functions that are part of the FigureMaker class accept keyword arguments that can modify the output. These include:</p> <ul> <li>separate_plots (bool) - if True and there is more than one cluster &amp; channel given                           to the method then each one will be plotted in a separate figure.                           Default is False</li> <li>equal_axes (bool) - Make the axes equal or not. Default is True</li> <li>cmap (matplotlib.colormaps) - the colormap to use. Mostly this defaults to                           matplotlib.colormaps['jet']</li> <li>ax - matplotlib.Axes instance. If provided the plot will be added to this axis</li> </ul> <p>Some examples:</p> <p><pre><code>from ephysiopy.io.recording import AxonaTrial\nfrom pathlib import Path\nimport matplotlib.pylab as plt\n\ndata = Path(\"/path/to/data/M851_140908t2rh.set\")\n\ntrial = AxonaTrial(data)\ntrial.load_pos_data()\n\ntrial.plot_rate_map([2,5],[3,3],separate_plots=True,cmap=matplotlib.colormaps['bone'])\nplt.show()\n</code></pre> </p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker","level":2,"title":"<code>ephysiopy.visualise.plotting.FigureMaker()</code>","text":"<p>               Bases: <code>object</code></p> <p>A mixin class for TrialInterface that deals solely with producing graphical output.</p> <p>Methods:</p> Name Description <code>plot_spike_path</code> <p>Plots the spikes on the path for the specified cluster(s) and channel.</p> <code>plot_rate_map</code> <p>Plots the rate map for the specified cluster(s) and channel.</p> <code>plot_hd_map</code> <p>Gets the head direction map for the specified cluster(s) and channel.</p> <code>plot_linear_rate_map</code> <p>Plots the linear rate map for the specified cluster(s) and channel.</p> <code>plot_eb_spikes</code> <p>Plots the ego-centric boundary spikes for the specified cluster(s)</p> <code>plot_eb_map</code> <p>Plots the ego-centric boundary map for the specified cluster(s) and</p> <code>plot_acorr</code> <p>Plots the autocorrelogram for the specified cluster(s) and channel.</p> <code>plot_xcorr</code> <p>Plots the temporal cross-correlogram between cluster_a and cluster_b</p> <code>plot_sac</code> <p>Plots the spatial autocorrelation for the specified cluster(s) and channel.</p> <code>plot_speed_v_hd</code> <p>Plots the speed versus head direction plot for the specified cluster(s) and channel.</p> <code>plot_raster</code> <p>Plots the raster plot for the specified cluster(s) and channel.</p> <code>plot_speed_v_rate</code> <p>Plots the speed versus rate plot for the specified cluster(s) and</p> <code>plot_power_spectrum</code> <p>Plots the power spectrum.</p> <code>plot_theta_vs_running_speed</code> <p>Plots theta frequency versus running speed.</p> <code>plot_clusters_theta_phase</code> <p>Plots the theta phase for the specified cluster and channel.</p> <code>plot_waveforms</code> <p>Plot the waveforms for the selected cluster on the channel (tetrode)</p> <code>plotSpectrogramByDepth</code> <p>Plots a heat map spectrogram of the LFP for each channel.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_spike_path","level":3,"title":"<code>plot_spike_path(cluster=None, channel=None, **kws) -&gt; plt.Axes</code>","text":"<p>Plots the spikes on the path for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int or None</code> <p>The cluster(s) to get the spike path for.</p> <code>None</code> <code>channel</code> <code>int or None</code> <p>The channel number.</p> <code>None</code> <code>**kws</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the spike path plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_rate_map","level":3,"title":"<code>plot_rate_map(cluster: int | list, channel: int | list, **kwargs) -&gt; plt.Figure</code>","text":"<p>Plots the rate map for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int or list</code> <p>The cluster(s) to get the rate map for.</p> required <code>channel</code> <code>int or list</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function. ax : plt.Axes, optional     The axes to plot on. If None, new axes are created. separate_plots : bool, optional     If True, each cluster will be plotted on a separate plot.     Defaults to False.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the rate map plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_hd_map","level":3,"title":"<code>plot_hd_map(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Gets the head direction map for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the head direction map for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the head direction map plot.</p> Notes <p>NB Following mathmatical convention, 0/360 degrees is 3 o'clock, 90 degrees is 12 o'clock, 180 degrees is 9 o'clock and 270 degrees</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_linear_rate_map","level":3,"title":"<code>plot_linear_rate_map(cluster: int | list, channel: int | list, **kwargs) -&gt; plt.Figure</code>","text":"<p>Plots the linear rate map for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int or list</code> <p>The cluster(s) to get the linear rate map for.</p> required <code>channel</code> <code>int or list</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the linear rate map plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_eb_spikes","level":3,"title":"<code>plot_eb_spikes(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the ego-centric boundary spikes for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the ego-centric boundary spikes for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the ego-centric boundary spikes plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_eb_map","level":3,"title":"<code>plot_eb_map(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the ego-centric boundary map for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the ego-centric boundary map for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the ego-centric boundary map plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_acorr","level":3,"title":"<code>plot_acorr(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the autocorrelogram for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the autocorrelogram for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function, including: binsize : int, optional     The size of the bins in ms.     Gets passed to SpikeCalcsGeneric.xcorr().     Defaults to 1.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the autocorrelogram plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_xcorr","level":3,"title":"<code>plot_xcorr(cluster_a: int, channel_a: int, cluster_b: int, channel_b: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the temporal cross-correlogram between cluster_a and cluster_b</p> <p>Parameters:</p> Name Type Description Default <code>cluster_a</code> <code>int</code> <p>first cluster</p> required <code>channel_a</code> <code>int</code> <p>first channel</p> required <code>cluster_b</code> <code>int</code> <p>second cluster</p> required <code>channel_b</code> <code>int</code> <p>second channel</p> required <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the cross-correlogram plot</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_sac","level":3,"title":"<code>plot_sac(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the spatial autocorrelation for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the spatial autocorrelation for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the spatial autocorrelation plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_speed_v_hd","level":3,"title":"<code>plot_speed_v_hd(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the speed versus head direction plot for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the speed versus head direction plot for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the speed versus head direction plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_raster","level":3,"title":"<code>plot_raster(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the raster plot for the specified cluster(s) and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the raster plot for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function, including: dt : list     The range in seconds to plot data over either side of the TTL pulse. seconds_per_bin : float     The number of seconds per bin.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the raster plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_speed_v_rate","level":3,"title":"<code>plot_speed_v_rate(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the speed versus rate plot for the specified cluster(s) and channel.</p> <p>By default the distribution of speeds will be plotted as a twin axis. To disable set add_speed_hist = False</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster(s) to get the speed versus rate plot for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the speed versus rate plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_power_spectrum","level":3,"title":"<code>plot_power_spectrum(**kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the power spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments passed to _getPowerSpectrumPlot</p> <code>{}</code>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_theta_vs_running_speed","level":3,"title":"<code>plot_theta_vs_running_speed(**kwargs) -&gt; QuadMesh</code>","text":"<p>Plots theta frequency versus running speed.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function, including: low_theta : float     The lower bound of the theta frequency range (default is 6). high_theta : float     The upper bound of the theta frequency range (default is 12). low_speed : float     The lower bound of the running speed range (default is 2). high_speed : float     The upper bound of the running speed range (default is 50).</p> <code>{}</code> <p>Returns:</p> Type Description <code>QuadMesh</code> <p>The QuadMesh object containing the plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_clusters_theta_phase","level":3,"title":"<code>plot_clusters_theta_phase(cluster: int, channel: int, **kwargs) -&gt; plt.Axes</code>","text":"<p>Plots the theta phase for the specified cluster and channel.</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> <p>The cluster to get the theta phase for.</p> required <code>channel</code> <code>int</code> <p>The channel number.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes containing the theta phase plot.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plot_waveforms","level":3,"title":"<code>plot_waveforms(cluster: int, channel: int, **kws) -&gt; list[plt.Axes]</code>","text":"<p>Plot the waveforms for the selected cluster on the channel (tetrode)</p> <p>Parameters:</p> Name Type Description Default <code>cluster</code> <code>int</code> required <code>channel</code> <code>int</code> required <p>Returns:</p> Type Description <code>plt.Axes - the axes holding the plot</code>","path":["API reference","Plotting functions"],"tags":[]},{"location":"plotting/#ephysiopy.visualise.plotting.FigureMaker.plotSpectrogramByDepth","level":3,"title":"<code>plotSpectrogramByDepth(nchannels: int = 384, nseconds: int = 100, maxFreq: int = 125, channels: list = [], frequencies: list = [], frequencyIncrement: int = 1, **kwargs)</code>","text":"<p>Plots a heat map spectrogram of the LFP for each channel. Line plots of power per frequency band and power on a subset of channels are also displayed to the right and above the main plot.</p> <p>Parameters:</p> Name Type Description Default <code>nchannels</code> <code>int</code> <p>The number of channels on the probe.</p> <code>384</code> <code>nseconds</code> <code>int</code> <p>How long in seconds from the start of the trial to do the spectrogram for (for speed). Default is 100.</p> <code>100</code> <code>maxFreq</code> <code>int</code> <p>The maximum frequency in Hz to plot the spectrogram out to. Maximum is 1250. Default is 125.</p> <code>125</code> <code>channels</code> <code>list</code> <p>The channels to plot separately on the top plot.</p> <code>[]</code> <code>frequencies</code> <code>list</code> <p>The specific frequencies to examine across all channels. The mean from frequency: frequency+frequencyIncrement is calculated and plotted on the left hand side of the plot.</p> <code>[]</code> <code>frequencyIncrement</code> <code>int</code> <p>The amount to add to each value of the frequencies list above.</p> <code>1</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the function. Valid key value pairs:     \"saveas\" - save the figure to this location, needs absolute path and filename.</p> <code>{}</code> Notes <p>Should also allow kwargs to specify exactly which channels and / or frequency bands to do the line plots for.</p>","path":["API reference","Plotting functions"],"tags":[]},{"location":"position/","level":1,"title":"Position data","text":"","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric","level":2,"title":"<code>ephysiopy.common.ephys_generic.PosCalcsGeneric(x: np.ndarray | list, y: np.ndarray | list, ppm: float, convert2cm: bool = True, jumpmax: float = 100, **kwargs)</code>","text":"<p>               Bases: <code>object</code></p> <p>Generic class for post-processing of position data Uses numpys masked arrays for dealing with bad positions, filtering etc</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>the x and y positions</p> required <code>y</code> <code>ndarray</code> <p>the x and y positions</p> required <code>ppm</code> <code>int</code> <p>Pixels per metre</p> required <code>convert2cm</code> <code>bool</code> <p>Whether everything is converted into cms or not</p> <code>True</code> <code>jumpmax</code> <code>int</code> <p>Jumps in position (pixel coords) &gt; than this are bad</p> <code>100</code> <code>**kwargs</code> <p>a dict[str, float] called 'tracker_params' is used to limit the range of valid xy positions - 'bad' positions are masked out and interpolated over</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>orig_xy</code> <code>ndarray</code> <p>the original xy coordinates, never modified directly</p> <code>npos</code> <code>int</code> <p>the number of position samples</p> <code>xy</code> <code>ndarray</code> <p>2 x npos array</p> <code>convert2cm</code> <code>bool</code> <p>whether to convert the xy position data to cms or not</p> <code>duration</code> <code>float</code> <p>the trial duration in seconds</p> <code>xyTS</code> <code>ndarray</code> <p>the timestamps the position data was recorded at. npos long vector</p> <code>dir</code> <code>ndarray</code> <p>the directional data. In degrees</p> <code>ppm</code> <code>float</code> <p>the number of pixels per metre</p> <code>jumpmax</code> <code>float</code> <p>the minimum jump between consecutive positions before a jump is considered 'bad' and smoothed over</p> <code>speed</code> <code>ndarray</code> <p>the speed data, extracted from a difference of xy positions. npos long vector</p> <code>sample_rate</code> <code>int</code> <p>the sample rate of the position data</p> Notes <p>The positional data (x,y) is turned into a numpy masked array once this class is initialised - that mask is then modified through various functions (postprocesspos being the main one).</p> <p>Methods:</p> Name Description <code>__add__</code> <p>Adds two PosCalcsGeneric objects together</p> <code>apply_mask</code> <p>Applies a mask to the position data</p> <code>calcHeadDirection</code> <p>Calculates the head direction from the xy data</p> <code>calcPhi</code> <p>Calculates phi, distance along a linear track</p> <code>calcSpeed</code> <p>Calculates speed</p> <code>interpnans</code> <p>Interpolates over bad values in the xy data</p> <code>postprocesspos</code> <p>Post-process position data</p> <code>smoothPos</code> <p>Smooths position data</p> <code>smooth_speed</code> <p>Smooth speed data with a window a little bit bigger than the usual</p> <code>speedfilter</code> <p>Filters speed</p> <code>upsamplePos</code> <p>Upsamples position data from 30 to upsample_rate</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.__add__","level":3,"title":"<code>__add__(other)</code>","text":"<p>Adds two PosCalcsGeneric objects together</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PosCalcsGeneric</code> <p>The other PosCalcsGeneric object to add</p> required <p>Returns:</p> Type Description <code>PosCalcsGeneric</code> <p>A new PosCalcsGeneric object with the combined xy data</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.apply_mask","level":3,"title":"<code>apply_mask(mask: np.ndarray)</code>","text":"<p>Applies a mask to the position data</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>The mask to be applied.</p> required Notes <p>If mask is empty, the mask is removed The mask should be a list of tuples, each tuple containing the start and end times of the mask i.e. [(start1, end1), (start2, end2)] everything inside of these times is masked</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.calcHeadDirection","level":3,"title":"<code>calcHeadDirection(xy: np.ma.MaskedArray) -&gt; np.ma.MaskedArray</code>","text":"<p>Calculates the head direction from the xy data</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy data</p> required <p>Returns:</p> Type Description <code>MaskedArray</code> <p>The head direction data</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.calcPhi","level":3,"title":"<code>calcPhi(xy: np.ma.MaskedArray)</code>","text":"<p>Calculates phi, distance along a linear track</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy positional data</p> required","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.calcSpeed","level":3,"title":"<code>calcSpeed(xy: np.ma.MaskedArray)</code>","text":"<p>Calculates speed</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy positional data</p> required","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.interpnans","level":3,"title":"<code>interpnans(xy: np.ma.MaskedArray) -&gt; np.ma.MaskedArray</code>","text":"<p>Interpolates over bad values in the xy data</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> required <p>Returns:</p> Type Description <code>MaskedArray</code> <p>The interpolated xy data</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.postprocesspos","level":3,"title":"<code>postprocesspos(tracker_params: dict[str, float] = {})</code>","text":"<p>Post-process position data</p> <p>Parameters:</p> Name Type Description Default <code>tracker_params</code> <code>dict</code> <p>Same dict as created in OESettings.Settings.parse (from module openephys2py)</p> <code>{}</code> Notes <p>Several internal functions are called here: speedfilter, interpnans, smoothPos and calcSpeed. Some internal state/ instance variables are set as well. The mask of the positional data (an instance of numpy masked array) is modified throughout this method.</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.smoothPos","level":3,"title":"<code>smoothPos(xy: np.ma.MaskedArray, **kwargs) -&gt; np.ma.MaskedArray</code>","text":"<p>Smooths position data</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy data</p> required <code>**kwargs</code> <p>window_len : int     The length of the smoothing window</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>xy</code> <code>array_like</code> <p>The smoothed positional data</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.smooth_speed","level":3,"title":"<code>smooth_speed(speed: np.ma.MaskedArray, window_len: int = 21)</code>","text":"<p>Smooth speed data with a window a little bit bigger than the usual 400ms window used for smoothing position data</p> <p>NB Uses a box car filter as with Axona</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.speedfilter","level":3,"title":"<code>speedfilter(xy: np.ma.MaskedArray)</code>","text":"<p>Filters speed</p> <p>Args:     xy (np.ma.MaskedArray): The xy data</p> <p>Returns:     xy (np.ma.MaskedArray): The xy data with speeds &gt;     self.jumpmax masked</p>","path":["API reference","Position data"],"tags":[]},{"location":"position/#ephysiopy.common.ephys_generic.PosCalcsGeneric.upsamplePos","level":3,"title":"<code>upsamplePos(xy: np.ma.MaskedArray, upsample_rate: int = 50)</code>","text":"<p>Upsamples position data from 30 to upsample_rate</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>MaskedArray</code> <p>The xy positional data</p> required <code>upsample_rate</code> <code>int</code> <p>The rate to upsample to</p> <code>50</code> <p>Returns:</p> Type Description <code>MaskedArray</code> <p>The upsampled xy positional data</p> Notes <p>This is mostly to get pos data recorded using PosTracker at 30Hz into Axona format 50Hz data</p>","path":["API reference","Position data"],"tags":[]},{"location":"quickstart/","level":1,"title":"Quickstart guide","text":"<p>From an ipython terminal, you can load some Axona data as follows:</p> Load data<pre><code>from ephysiopy.io.recording import AxonaTrial\nfrom pathlib import Path\n\ndata = Path(\"/path/to/data/M851_140908t2rh.set\")\n\ntrial = AxonaTrial(data)\n</code></pre> <p>Note</p> <p>The path should point to the .set file for the recording trial files</p> <p>Similarly, to load data recorded using OpenEphys:</p> Load data<pre><code>from ephysiopy.io.recording import OpenEphysBase\nfrom pathlib import Path\n\ndata = Path(\"/path/to/data/RHA1-00064_2023-07-07_10-47-31\")\n\ntrial = OpenEphysBase(data)\n</code></pre> <p>Note</p> <p>The path should point to the top level folder containing the OpenEphys data</p> <p>In both cases, the trial object is the main interface for working with data.</p> <p>Plot the rate map for cluster 1 on channel 2:</p> Plot data<pre><code>import matplotlib.pylab as plt\n\ntrial.plot_rate_map(1, 2)\nplt.show()\n</code></pre> <p></p>","path":["User Guide","Quickstart guide"],"tags":[]},{"location":"spike_train_analysis/","level":1,"title":"Spike train analysis","text":"","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric","level":2,"title":"<code>ephysiopy.common.spikecalcs.SpikeCalcsGeneric(spike_times: np.ndarray, cluster: int, waveforms: np.ndarray = None, **kwargs)</code>","text":"<p>               Bases: <code>object</code></p> <p>Deals with the processing and analysis of spike data. There should be one instance of this class per cluster in the recording session. NB this differs from previous versions of this class where there was one instance per recording session and clusters were selected by passing in the cluster id to the methods.</p> <p>NB Axona waveforms are nSpikes x nChannels x nSamples - this boils down to nSpikes x 4 x 50 NB KiloSort waveforms are nSpikes x nSamples x nChannels - these are ordered by 'best' channel first and then the rest of the channels. This boils down to nSpikes x 61 x 12 SO THIS NEEDS TO BE CHANGED to nSpikes x nChannels x nSamples</p> <p>Parameters:</p> Name Type Description Default <code>spike_times</code> <code>ndarray</code> <p>The times of spikes in the trial in seconds.</p> required <code>cluster</code> <code>int</code> <p>The cluster ID.</p> required <code>waveforms</code> <code>ndarray</code> <p>An nSpikes x nChannels x nSamples array.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>spike_times</code> <code>MaskedArray</code> <p>The times of spikes in the trial in seconds.</p> <code>_waves</code> <code>MaskedArray or None</code> <p>The waveforms of the spikes.</p> <code>cluster</code> <code>int</code> <p>The cluster ID.</p> <code>n_spikes</code> <code>int</code> <p>the total number of spikes for the current cluster</p> <code>duration</code> <code>(float, int)</code> <p>total duration of the trial in seconds</p> <code>event_ts</code> <code>ndarray or None</code> <p>The times that events occurred in seconds.</p> <code>event_window</code> <code>ndarray</code> <p>The window, in seconds, either side of the stimulus, to examine.</p> <code>stim_width</code> <code>float or None</code> <p>The width, in ms, of the stimulus.</p> <code>secs_per_bin</code> <code>float</code> <p>The size of bins in PSTH.</p> <code>sample_rate</code> <code>int</code> <p>The sample rate of the recording.</p> <code>pos_sample_rate</code> <code>int</code> <p>The sample rate of the position data.</p> <code>pre_spike_samples</code> <code>int</code> <p>The number of samples before the spike.</p> <code>post_spike_samples</code> <code>int</code> <p>The number of samples after the spike.</p> <code>KSMeta</code> <code>KSMetaTuple</code> <p>The metadata from KiloSort.</p> <p>Methods:</p> Name Description <code>acorr</code> <p>Calculates the autocorrelogram of a spike train.</p> <code>apply_filter</code> <p>Applies a mask to the spike times.</p> <code>contamination_percent</code> <p>Returns the contamination percentage of a spike train.</p> <code>estimate_AHP</code> <p>Estimate the decay time for the AHP of the waveform of the</p> <code>get_best_channel</code> <p>Returns the channel with the highest mean amplitude of the waveforms.</p> <code>get_ifr</code> <p>Returns the instantaneous firing rate of the cluster</p> <code>get_ifr_power_spectrum</code> <p>Returns the power spectrum of the instantaneous firing rate of a cell</p> <code>get_shuffled_ifr_sp_corr</code> <p>Returns an nShuffles x nSamples sized array of shuffled</p> <code>ifr_sp_corr</code> <p>Calculates the correlation between the instantaneous firing rate and</p> <code>mean_isi_range</code> <p>Calculates the mean of the autocorrelation from 0 to n seconds.</p> <code>mean_waveform</code> <p>Returns the mean waveform and standard error of the mean (SEM) for a</p> <code>plot_waveforms</code> <p>Plots the waveforms of the cluster.</p> <code>psch</code> <p>Calculate the peri-stimulus count histogram of a cell's spiking</p> <code>psth</code> <p>Calculate the PSTH of event_ts against the spiking of a cell</p> <code>responds_to_stimulus</code> <p>Checks whether a cluster responds to a laser stimulus.</p> <code>smooth_spike_train</code> <p>Returns a spike train the same length as num pos samples that has been</p> <code>theta_band_max_freq</code> <p>Calculates the frequency with the maximum power in the theta band (6-12Hz)</p> <code>theta_mod_idx</code> <p>Calculates a theta modulation index of a spike train based on the cells</p> <code>theta_mod_idxV2</code> <p>This is a simpler alternative to the theta_mod_idx method in that it</p> <code>theta_mod_idxV3</code> <p>Another theta modulation index score this time based on the method used</p> <code>update_KSMeta</code> <p>Takes in a TemplateModel instance from a phy session and</p> <code>waveforms</code> <p>Returns the waveforms of the cluster.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.n_channels","level":3,"title":"<code>n_channels: int | None</code>  <code>property</code>","text":"<p>Returns the number of channels in the waveforms.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>The number of channels in the waveforms, or None if no waveforms are available.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.n_samples","level":3,"title":"<code>n_samples: int | None</code>  <code>property</code>","text":"<p>Returns the number of samples in the waveforms.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>The number of samples in the waveforms, or None if no waveforms are available.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.n_spikes","level":3,"title":"<code>n_spikes</code>  <code>property</code>","text":"<p>Returns the number of spikes in the cluster</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of spikes in the cluster</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.acorr","level":3,"title":"<code>acorr(Trange: np.ndarray = np.array([-0.5, 0.5]), **kwargs) -&gt; BinnedData</code>","text":"<p>Calculates the autocorrelogram of a spike train.</p> <p>Parameters:</p> Name Type Description Default <code>Trange</code> <code>ndarray</code> <p>The range of times to calculate the autocorrelogram over (default is [-0.5, 0.5]).</p> <code>array([-0.5, 0.5])</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinnedData</code> <p>Container for the binned data.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.apply_filter","level":3,"title":"<code>apply_filter(*trial_filter: TrialFilter) -&gt; None</code>","text":"<p>Applies a mask to the spike times.</p> <p>Parameters:</p> Name Type Description Default <code>trial_filter</code> <code>TrialFilter</code> <p>The filter</p> <code>()</code>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.contamination_percent","level":3,"title":"<code>contamination_percent(**kwargs) -&gt; tuple</code>","text":"<p>Returns the contamination percentage of a spike train.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Passed into the contamination_percent function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple of float</code> <p>Q - A measure of refractoriness. R - A second measure of refractoriness (kicks in for very low firing rates).</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.estimate_AHP","level":3,"title":"<code>estimate_AHP() -&gt; float | None</code>","text":"<p>Estimate the decay time for the AHP of the waveform of the best channel for the current cluster.</p> <p>Returns:</p> Type Description <code>float | None</code> <p>The estimated AHP decay time in microseconds, or None if no waveforms are available.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_best_channel","level":3,"title":"<code>get_best_channel() -&gt; int | None</code>","text":"<p>Returns the channel with the highest mean amplitude of the waveforms.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>The index of the channel with the highest mean amplitude, or None if no waveforms are available.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_ifr","level":3,"title":"<code>get_ifr(spike_times: np.array, n_samples: int, **kwargs) -&gt; np.ndarray</code>","text":"<p>Returns the instantaneous firing rate of the cluster</p> <p>Parameters:</p> Name Type Description Default <code>spike_times</code> <code>ndarray</code> <p>The times in seconds at which the cluster fired.</p> required <code>n_samples</code> <code>int</code> <p>The number of samples to use in the calculation. Practically this should be the number of position samples in the recording.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The instantaneous firing rate of the cluster</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_ifr_power_spectrum","level":3,"title":"<code>get_ifr_power_spectrum() -&gt; tuple[np.ndarray, ...]</code>","text":"<p>Returns the power spectrum of the instantaneous firing rate of a cell</p> <p>Used to calculate the theta_mod_idxV3 score above</p> <p>Returns:</p> Type Description <code>tuple of np.ndarray</code> <p>The frequency and power of the instantaneous firing rate</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.get_shuffled_ifr_sp_corr","level":3,"title":"<code>get_shuffled_ifr_sp_corr(ts: np.array, speed: np.array, nShuffles: int = 100, **kwargs)</code>","text":"<p>Returns an nShuffles x nSamples sized array of shuffled instantaneous firing rate x speed correlations</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>ndarray</code> <p>the times in seconds at which the cluster fired</p> required <code>speed</code> <code>ndarray</code> <p>the speed vector</p> required <code>nShuffles</code> <code>int</code> <p>the number of times to shuffle the timestamp vector 'ts'</p> <code>100</code> <code>**kwargs</code> <p>Passed into ifr_sp_corr</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A nShuffles x nSamples sized array of the shuffled firing rate vs speed correlations.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.ifr_sp_corr","level":3,"title":"<code>ifr_sp_corr(ts, speed, minSpeed=2.0, maxSpeed=40.0, sigma=3, nShuffles=100, **kwargs)</code>","text":"<p>Calculates the correlation between the instantaneous firing rate and speed.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <p>The times in seconds at which the cluster fired.</p> required <code>speed</code> <code>ndarray</code> <p>Instantaneous speed (nSamples lenght vector).</p> required <code>minSpeed</code> <code>float</code> <p>Speeds below this value are ignored.</p> <code>2.0</code> <code>maxSpeed</code> <code>float</code> <p>Speeds above this value are ignored.</p> <code>40.0</code> <code>sigma</code> <code>int</code> <p>The standard deviation of the gaussian used to smooth the spike train.</p> <code>3</code> <code>nShuffles</code> <code>int</code> <p>The number of resamples to feed into the permutation test.</p> <code>100</code> <code>**kwargs</code> <p>method: how the significance of the speed vs firing rate correlation         is calculated</p> <code>{}</code> <p>Examples:</p> <p>An example of how I was calculating this is:</p> <p>rng = np.random.default_rng() method = stats.PermutationMethod(n_resamples=nShuffles, random_state=rng)</p> See Also <p>See scipy.stats.PermutationMethod.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.mean_isi_range","level":3,"title":"<code>mean_isi_range(isi_range: float) -&gt; float</code>","text":"<p>Calculates the mean of the autocorrelation from 0 to n seconds. Used to help classify a neuron's type (principal, interneuron, etc).</p> <p>Parameters:</p> Name Type Description Default <code>isi_range</code> <code>int</code> <p>The range in seconds to calculate the mean over.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The mean of the autocorrelogram between 0 and n seconds.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.mean_waveform","level":3,"title":"<code>mean_waveform(channel_id: Sequence = None)</code>","text":"<p>Returns the mean waveform and standard error of the mean (SEM) for a given spike train on a particular channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Sequence</code> <p>The channel IDs to return the mean waveform for. If None, returns mean waveforms for all channels.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing: - mn_wvs (np.ndarray): The mean waveforms, usually 4x50 for tetrode recordings. - std_wvs (np.ndarray): The standard deviations of the waveforms, usually 4x50 for tetrode recordings.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.plot_waveforms","level":3,"title":"<code>plot_waveforms(n_waveforms: int = 2000, n_channels: int = 4)</code>","text":"<p>Plots the waveforms of the cluster.</p> <p>Parameters:</p> Name Type Description Default <code>n_waveforms</code> <code>int</code> <p>The number of waveforms to plot.</p> <code>2000</code> <code>n_channels</code> <code>int</code> <p>The number of channels to plot.</p> <code>4</code> <p>Returns:</p> Type Description <code>None</code>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.psch","level":3,"title":"<code>psch(bin_width_secs: float) -&gt; np.ndarray</code>","text":"<p>Calculate the peri-stimulus count histogram of a cell's spiking against event times.</p> <p>Parameters:</p> Name Type Description Default <code>bin_width_secs</code> <code>float</code> <p>The width of each bin in seconds.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>ndarray</code> <p>Rows are counts of spikes per bin_width_secs. Size of columns ranges from self.event_window[0] to self.event_window[1] with bin_width_secs steps; so x is count, y is \"event\".</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.psth","level":3,"title":"<code>psth() -&gt; tuple[list, ...]</code>","text":"<p>Calculate the PSTH of event_ts against the spiking of a cell</p> <p>Returns:</p> Type Description <code>x, y : list</code> <code>The list of time differences between the spikes of the cluster</code> <code>and the events (x) and the trials (y)</code>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.responds_to_stimulus","level":3,"title":"<code>responds_to_stimulus(threshold: float, min_contiguous: int, return_activity: bool = False, return_magnitude: bool = False, **kwargs)</code>","text":"<p>Checks whether a cluster responds to a laser stimulus.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>The amount of activity the cluster needs to go beyond to be classified as a responder (1.5 = 50% more or less than the baseline activity).</p> required <code>min_contiguous</code> <code>int</code> <p>The number of contiguous samples in the post-stimulus period for which the cluster needs to be active beyond the threshold value to be classed as a responder.</p> required <code>return_activity</code> <code>bool</code> <p>Whether to return the mean reponse curve.</p> <code>False</code> <code>return_magnitude</code> <code>int</code> <p>Whether to return the magnitude of the response. NB this is either +1 for excited or -1 for inhibited.</p> <code>False</code> <p>Returns:</p> Type Description <code>namedtuple</code> <p>With named fields \"responds\" (bool), \"normed_response_curve\" (np.ndarray), \"response_magnitude\" (np.ndarray)</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.smooth_spike_train","level":3,"title":"<code>smooth_spike_train(npos, sigma=3.0, shuffle=None)</code>","text":"<p>Returns a spike train the same length as num pos samples that has been smoothed in time with a gaussian kernel M in width and standard deviation equal to sigma.</p> <p>Parameters:</p> Name Type Description Default <code>npos</code> <code>int</code> <p>The number of position samples captured.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation of the gaussian used to smooth the spike train.</p> <code>3.0</code> <code>shuffle</code> <code>int</code> <p>The number of seconds to shift the spike train by. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The smoothed spike train.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_band_max_freq","level":3,"title":"<code>theta_band_max_freq()</code>","text":"<p>Calculates the frequency with the maximum power in the theta band (6-12Hz) of a spike train's autocorrelogram.</p> <p>This function is used to look for differences in theta frequency in different running directions as per Blair. See Welday paper - https://doi.org/10.1523/jneurosci.0712-11.2011</p> <p>Returns:</p> Type Description <code>float</code> <p>The frequency with the maximum power in the theta band.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input spike train is not valid.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idx","level":3,"title":"<code>theta_mod_idx(**kwargs) -&gt; float</code>","text":"<p>Calculates a theta modulation index of a spike train based on the cells autocorrelogram.</p> <p>The difference of the mean power in the theta band (6-11 Hz) and the mean power in the 1-50 Hz band is divided by their sum to give a metric that lives between 0 and 1</p> <p>Returns:</p> Type Description <code>float</code> <p>The difference of the values at the first peak and trough of the autocorrelogram.</p> Notes <p>This is a fairly skewed metric with a distribution strongly biased to -1 (although more evenly distributed than theta_mod_idxV2 below)</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idxV2","level":3,"title":"<code>theta_mod_idxV2() -&gt; float</code>","text":"<p>This is a simpler alternative to the theta_mod_idx method in that it calculates the difference between the normalized temporal autocorrelogram at the trough between 50-70ms and the peak between 100-140ms over their sum (data is binned into 5ms bins)</p> <p>Returns:</p> Type Description <code>float</code> <p>The difference of the values at the first peak and trough of the autocorrelogram.</p> Notes <p>Measure used in Cacucci et al., 2004 and Kropff et al 2015</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.theta_mod_idxV3","level":3,"title":"<code>theta_mod_idxV3(**kwargs) -&gt; float</code>","text":"<p>Another theta modulation index score this time based on the method used by Kornienko et al., (2024) (Kevin Allens lab) see https://doi.org/10.7554/eLife.35949.001</p> <p>Uses the binned spike train instead of the autocorrelogram as the input to the periodogram function (they use pwelch in R; periodogram is a simplified call to welch in scipy.signal)</p> <p>The resulting metric is similar to that in theta_mod_idx above except that the frequency bands compared to the theta band are narrower and exclusive of the theta band</p> <p>Produces a fairly normally distributed score with a mean and median pretty close to 0</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Passed into get_ifr_power_spectrum</p> <code>{}</code> <p>Returns:</p> Type Description <code>float</code> <p>The difference of the values at the first peak and trough of the autocorrelogram.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.update_KSMeta","level":3,"title":"<code>update_KSMeta(value: dict) -&gt; None</code>","text":"<p>Takes in a TemplateModel instance from a phy session and parses out the relevant metrics for the cluster and places into the namedtuple KSMeta.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict</code> <p>A dictionary containing the relevant metrics for the cluster.</p> required","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.SpikeCalcsGeneric.waveforms","level":3,"title":"<code>waveforms(channel_id: Sequence = None) -&gt; np.ndarray | None</code>","text":"<p>Returns the waveforms of the cluster.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>Sequence</code> <p>The channel IDs to return the waveforms for. If None, returns waveforms for all channels.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray | None</code> <p>The waveforms of the cluster, or None if no waveforms are available.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.get_param","level":2,"title":"<code>ephysiopy.common.spikecalcs.get_param(waveforms, param='Amp', t=200, fet=1) -&gt; np.ndarray</code>","text":"<p>Returns the requested parameter from a spike train as a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>waveforms</code> <code>ndarray</code> <p>Shape of array can be nSpikes x nSamples OR nSpikes x nElectrodes x nSamples.</p> required <code>param</code> <code>str</code> <p>Valid values are: - 'Amp': peak-to-trough amplitude - 'P': height of peak - 'T': depth of trough - 'Vt': height at time t - 'tP': time of peak (in seconds) - 'tT': time of trough (in seconds) - 'PCA': first n fet principal components (defaults to 1)</p> <code>'Amp'</code> <code>t</code> <code>int</code> <p>The time used for Vt</p> <code>200</code> <code>fet</code> <code>int</code> <p>The number of principal components (use with param 'PCA').</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The requested parameter as a numpy array.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.get_peak_to_trough_time","level":2,"title":"<code>ephysiopy.common.spikecalcs.get_peak_to_trough_time(waveforms: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Returns the time in seconds of the peak to trough in a waveform.</p> <p>Parameters:</p> Name Type Description Default <code>waveforms</code> <code>ndarray</code> <p>The waveforms to calculate the peak to trough time for.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The time of the peak to trough in seconds.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.get_burstiness","level":2,"title":"<code>ephysiopy.common.spikecalcs.get_burstiness(isi_matrix: np.ndarray, whiten: bool = False, plot_pcs: bool = False) -&gt; np.ndarray</code>","text":"<p>Returns the burstiness of a waveform.</p> <p>Parameters:</p> Name Type Description Default <code>isi_matrix</code> <code>ndarray</code> <p>A matrix of normalized interspike intervals (ISIs) for the neurons. Rows are neurons, columns are ISI time bins.</p> required <p>Returns:</p> Type Description <code>ndarray</code> Notes <p>Algorithm:</p> <p>1) The interspike intervals between 0 and 60ms were binned into 2ms bins, and the area of the histogram was normalised to 1 to produce a probability distribution histogram for each neuron</p> <p>2) A principal components analysis (PCA) is performed on the matrix of the ISI probability distributions of all neurons</p> <p>3) Neurons were then assigned to two clusters using a k-means clustering algorithm on the first three principal components</p> <p>4) a linear discriminant analysis performed in MATLAB (‘classify’) was undertaken to determine the optimal linear discriminant (Fishers Linear Discriminant) i.e., the plane which best separated the two clusters in a three-dimensional scatter plot of the principal components.</p> <p>Training on 80% of the data and testing on the remaining 20% resulted in a good separation of the two clusters.</p> <p>5) A burstiness score was assigned to each neuron which was calculated by computing the shortest distance between the plotted point for each neuron in the three-dimensional cluster space (principal components 1,2 and 3), and the plane separating the two clusters (i.e., the optimal linear discriminant).</p> <p>6) To ensure the distribution of these burstiness scores was bimodal, reflecting the presence of two classes of neuron (‘bursty’ versus ‘non-bursty’), probability density functions for Gaussian mixture models with between one and four underlying Gaussian curves were fitted and the fit of each compared using the Akaike information criterion (AIC)</p> <p>7) Optionally plot the principal components and the centres of the kmeans results</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.mahal","level":2,"title":"<code>ephysiopy.common.spikecalcs.mahal(u, v)</code>","text":"<p>Returns the L-ratio and Isolation Distance measures calculated on the principal components of the energy in a spike matrix.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray</code> <p>The first set of waveforms.</p> required <code>v</code> <code>ndarray</code> <p>The second set of waveforms.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The Mahalanobis distances.</p> <p>Raises:</p> Type Description <code>Warning</code> <p>If input size mismatch, too few rows, or complex inputs are detected.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.cluster_quality","level":2,"title":"<code>ephysiopy.common.spikecalcs.cluster_quality(waveforms: np.ndarray = None, spike_clusters: np.ndarray = None, cluster_id: int = None, fet: int = 1)</code>","text":"<p>Returns the L-ratio and Isolation Distance measures calculated on the principal components of the energy in a spike matrix.</p> <p>Parameters:</p> Name Type Description Default <code>waveforms</code> <code>ndarray</code> <p>The waveforms to be processed. If None, the function will return None.</p> <code>None</code> <code>spike_clusters</code> <code>ndarray</code> <p>The spike clusters to be processed.</p> <code>None</code> <code>cluster_id</code> <code>int</code> <p>The ID of the cluster to be processed.</p> <code>None</code> <code>fet</code> <code>int</code> <p>The feature to be used in the PCA calculation (default is 1).</p> <code>1</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the L-ratio and Isolation Distance of the cluster.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs during the calculation of the L-ratio or Isolation Distance.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.xcorr","level":2,"title":"<code>ephysiopy.common.spikecalcs.xcorr(x1: np.ndarray, x2: np.ndarray | None = None, Trange: np.ndarray | list = np.array([-0.5, 0.5]), binsize: float = 0.001, normed=False, **kwargs) -&gt; BinnedData</code>","text":"<p>Calculates the ISIs in x1 or x1 vs x2 within a given range.</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>ndarray</code> <p>The times of the spikes emitted by the first cluster in seconds.</p> required <code>x2</code> <code>ndarray</code> <p>The times of the spikes emitted by the second cluster in seconds. If None, x1 is used.</p> <code>None</code> <code>Trange</code> <code>ndarray or list</code> <p>Range of times to bin up in seconds (default is [-0.5, 0.5]).</p> <code>array([-0.5, 0.5])</code> <code>binsize</code> <code>float</code> <p>The size of the bins in seconds (default is 0.001).</p> <code>0.001</code> <code>normed</code> <code>bool</code> <p>Whether to divide the counts by the total number of spikes to give a probability (default is False).</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinnedData</code> <p>A BinnedData object containing the binned data and the bin edges.</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.fit_smoothed_curve_to_xcorr","level":2,"title":"<code>ephysiopy.common.spikecalcs.fit_smoothed_curve_to_xcorr(xc: BinnedData, **kwargs) -&gt; BinnedData</code>","text":"<p>Idea is to smooth out the result of an auto- or cross-correlogram with a view to correlating the result with another auto- or cross-correlogram to see how similar two of these things are.</p> <p>Check Brandon et al., 2011?2012?</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"spike_train_analysis/#ephysiopy.common.spikecalcs.contamination_percent","level":2,"title":"<code>ephysiopy.common.spikecalcs.contamination_percent(x1: np.ndarray, x2: np.ndarray | None = None, **kwargs) -&gt; tuple</code>","text":"<p>Computes the cross-correlogram between two sets of spikes and estimates how refractory the cross-correlogram is.</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>ndarray</code> <p>The first set of spikes.</p> required <code>x2</code> <code>ndarray</code> <p>The second set of spikes. If None, x1 is used.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments that can be fed into xcorr.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing: - Q (float): A measure of refractoriness. - R (float): A second measure of refractoriness (kicks in for very low firing rates).</p> Notes <p>Taken from KiloSorts ccg.m</p> <p>The contamination metrics are calculated based on an analysis of the 'shoulders' of the cross-correlogram. Specifically, the spike counts in the ranges ±5-25ms and</p>","path":["API reference","Spike train analysis"],"tags":[]},{"location":"usage/","level":1,"title":"Further usage","text":"<p>First, load some data:</p> <pre><code>from ephysiopy.io.recording import AxonaTrial\nfrom pathlib import Path\n\ndata = Path(\"/path/to/data/M851_140908t2rh.set\")\n\ntrial = AxonaTrial(data)\n</code></pre>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#trial-settings","level":2,"title":"Trial settings","text":"<p>At this point the only data that has been loaded is the settings data. For Axona data this consists of the key - value pairs in the .set file, essentially the  state machine of the recording. Because of it's simple structure this is stored as a standard python dictionary</p> <pre><code>type(trial.settings)\ndict\n</code></pre> <p>Because of the more flexible/ complex design of the OpenEphys plugin-GUI this settings data is stored as it's own class:</p> <pre><code>from ephysiopy.io.recording import OpenEphysBase\n\ndata = Path(\"/path/to/data/RHA1-00064_2023-07-07_10-47-31\")\n\ntrial = OpenEphysBase(data)\n\ntype(trial.settings)\nephysiopy.openephys2py.OESettings.Settings\n</code></pre> <p>See OEPlugins for more details</p> <p>You won't need to interact with the settings directly for most if not all analyses; the relevant bits are extracted and used in loading/ processing of other data.</p>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#position-data","level":2,"title":"Position data","text":"<p>Regardless of the data source, position data is stored in the PosCalcsGeneric class:</p> <pre><code>trial.load_pos_data()\nLoaded pos data\n\ntype(trial.PosCalcs)\nephysiopy.common.ephys_generic.PosCalcsGeneric\n</code></pre> <p>There are several arguments you can add to the load_pos_data function to control how the position data is treated. An important one is 'ppm' which stads for pixels_per_metre. It specifies how many pixels in camera units correspond to one metre. This is something you should measure experimentally and record somewhere. The number is used to convert the position data to real world units. If you don't specify it, the ppm value will take a default value of 300 (CHECK)</p> <pre><code>trial.load_pos_data(ppm=800)\nLoaded pos data\n</code></pre> <p>Other important arguments are jumpmax and cm. Jumpmax is the maximum distance that the animal can move between two frames. If the distance between two frames is greater than this value, the position data for that frame will be interpolated over. This is useful for removing artefacts in the position data caused by tracking errors. The default value is 100 pixels. 'cm' is a boolean that specifies whether the position data should be converted to centimetres. The default value is False, which means that the position data will be in metres.</p> <p>Once loaded the PosCalcs attribute has several attributes itself like 'xy' and 'dir' which are the x and y position and the head direction.</p> <p>You shouldn't need to interact with the PosCalcs class directly for most analyses, but it's there if you need it.</p> <p>The position data is used in several of the plotting functions and in the rate map calculations.</p> <pre><code>import matplotlib.pylab as plt\n\ntrial.plot_spike_path()\nplt.show()\n</code></pre> <p></p>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#spiking-data","level":2,"title":"Spiking data","text":"<p>We can get the spike times in seconds at which a cluster fired:</p> Spike times for cluster 2 on channel 3<pre><code>trial.get_spike_times(2, 3)\nmasked_array(data=[0.7710416666666666, 4.6870416666666666,\n                   4.693291666666667, ..., 2394.8471458333333,\n                   2394.8537291666667, 2394.860708333333],\n             mask=[False, False, False, ..., False, False, False],\n       fill_value=1e+20)\n</code></pre> <p>Note</p> <p>The spike times are returned as a masked numpy array. It is possible to filter a trial for various things like speed, time, position etc. Many of the arrays returned from functions like this are masked to  reflect such filtering i.e. spikes that occurred when the animal ran below a speed threshold will be masked (mask value will be True)</p> <p>You can plot the position at which spikes were emitted for a specific cluster on top of the path:</p> Cluster 2 on channel 3<pre><code>trial.plot_spike_path(2, 3)\nplt.show()\n</code></pre> <p></p> <p>And the corresponding rate map:</p> Rate map for cluster 2 on channel 3<pre><code>trial.plot_rate_map(2, 3)\nplt.show()\n</code></pre> <p></p> <p>You can access the underlying data for the rate map as well:</p> Rate map data for cluster 2 on channel 3<pre><code>trial.get_rate_map(2, 3)\n\nBinnedData(variable=&lt;VariableToBin.XY: 1&gt;, map_type=&lt;MapType.RATE: 1&gt;, binned_data=[masked_array(\n...\n</code></pre> <p>Read more about the BinnedData class in the API docs BinnedData class and a more verbose description here</p>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#local-field-potential-lfp-data","level":2,"title":"Local field potential (LFP) data","text":"<p>Load the LFP data like so:</p> <pre><code>trial.load_lfp()\n</code></pre> <p>This can take a while especially if the trial is long and recorded using OpenEphys as the raw data has to be bandpass filtered first. Once that's done the data is available as an EEGCalcs attribute of the trial object</p> <p>The default sampling rate for the LFP data is 250 Hz, but this can be changed by specifying the 'resample' argument in the load_lfp() function. For example, to resample the LFP data to 500 Hz:</p> <pre><code>trial.load_lfp(target_sample_rate=500)\n</code></pre> <p>Target sample rates should not exceed the Nyquist frequency of the original data, which is half the original sampling rate. For example, if the original sampling rate is 1000 Hz, the target sample rate should not exceed 500 Hz. </p> <p>Once the data has been loaded you can then bandpass filter it using butterFilter function:</p> Bandpass filter the LFP data between 6 and 12 Hz<pre><code>trial.LFP.butterFilter(6, 12)\n</code></pre>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#filtering-a-trial","level":2,"title":"Filtering a trial","text":"<p>There is an apply_filter() method of the trial object that takes a list of TrialFilter and applies those filters to the underlying data of the trial.</p> <p>Specify a TrialFilter like so:</p> Filter for speed<pre><code>from ephysiopy.common.utils import TrialFilter\n\nspeed_filter = TrialFilter(\"speed\", 0, 5)\ntrial.apply_filter([speed_filter])\n</code></pre> <p>This will filter out all data points where the animal's speed was below 5 cm/s. The filter is applied to all relevant data, so for example the spike times will be masked for all spikes that occurred when the animal was below the speed threshold.</p> <p>You can build up a list of filters and apply them all at once:</p> Filter for speed and time<pre><code>speed_filter = TrialFilter(\"speed\", 0, 5)\ntime_filter = TrialFilter(\"time\", 100, 200)\ntrial.apply_filter([speed_filter, time_filter])\n</code></pre> <p>The trial has now been filtered for all data points where the animal's speed was below 5 cm/s and where the time was between 100 and 200 seconds. The spike times will be masked for all spikes that occurred when the animal was below the speed threshold or outside the specified time range.</p> <p>To remove the filters just call the apply_filter() method with no arguments:</p> Remove all filters<pre><code>trial.apply_filter()\n</code></pre> <p>All of the TrialFilter objects take the same arguments: the name of the filter, the minimum value and the maximum value. The name of the filter should be one of the following:</p> <pre><code>time\ndir\nspeed\nxrange\nyrange\nphi\n</code></pre>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#examining-individual-firing-fields","level":2,"title":"Examining individual firing fields","text":"<p>We can extract individual firing fields from a firing rate map to look more closely at what's happening during individual passes through a firing field.</p> <pre><code>field_props = trial.get_field_properties(2, 3)\nField 1 has 47 potential runs\nField 2 has 134 potential runs\nField 3 has 165 potential runs\nField 4 has 55 potential runs\nField 5 has 95 potential runs\nField 6 has 113 potential runs\nField 7 has 4 potential runs\n</code></pre> <p>The get_field_properties() method has detected 7 fields and a number of  runs through each one and returned them as a list. </p> <p>You can plot the results of this image segmentation like so:</p> <pre><code>from ephysiopy.common.fieldcalcs import plot_field_props\nplot_field_props(field_props)\nplt.show()\n</code></pre> <p></p> <p>The top left-hand part of the figure shows the results of the segmentation colour-coded for field number (should go from 1 to n numbering from the top left and rastering left to  right). The plot at the top-right is the result of taking each run through a field and transforming it so that it lies on a unit circle. This is useful for performing phase precession anaylsis in 2D environments<sup>1</sup>. The bottom left-hand part of the figure shows the angle of each point on the perimeter of each field that that firing fields peak and the central heatmap part of each field shows the distance of each bin the field to the firing field centre. The bottom right-hand part of the figure shows the firing rate map numbered with the firing field identity.</p> <p>Each item in field_props in the example above is of type FieldProps  and has a large number of attributes availabale. You can also add LFP data for each run through the field(s) which should make phase precession type anaylses easier.</p> <p>Each field will have one or more runs associated with it, each of these is of type RunProps and has a large number of attributes available.</p> <p>You can also add LFP data for each run through a field - each run will also then have an LFPSegment object associated with it which contains the LFP data for that run.</p>","path":["User Guide","Further usage"],"tags":[]},{"location":"usage/#dealing-with-field-properties","level":3,"title":"Dealing with field properties","text":"<p>There are a number of methods for dealing with the field properties objects. We might want to sort them by some particular attribute or filter them similarly. As each FieldProps object will  have a list of RunProps associated with it it's likely that not all of these runs will have spikes associated with them for example. We may also want to filter out small fields that are unlikely to contain enough data.</p> Sort fields by field size<pre><code>from ephysiopy.common.fieldcalcs import sort_fields_by_attr\nsorted_fields = sort_fields_by_attr(field_props, \"area\")\nfor field in sorted_fields:\n    print(field.area)\n157.0\n132.0\n130.0\n123.0\n100.0\n83.0\n5.0\n</code></pre> <p>We can also filter the runs by some attribute but we need to give a bit more information this time. Filter runs by number of spikes<pre><code>from ephysiopy.common.fieldcalcs import filter_runs\n\nfilter_runs(field_props, [\"num_spikes\"], [np.greater], [3])\nFiltering runs for n_spikes greater than 3...\nField 1 has 18 potential runs\nFiltering runs for n_spikes greater than 3...\nField 2 has 37 potential runs\nFiltering runs for n_spikes greater than 3...\nField 3 has 39 potential runs\n...    \n</code></pre></p> <p>Notice how the filtering occurs in place so the field_props object is updated with the filtered runs. In this example we have filtered out all runs that had 3 or fewer spikes in them.</p> <p>There are two important options we can use to change how the segmentation of fields from the rate map occurs. The partitioning of the rate map can be done in either a 'simple' or a 'fancy' way.</p> <p>The simple_parition method essentially just returns the areas of the ratemap that are greater than some threshold percentage4  of the mean firing rate. This was done mostly to deal with one-dimensional linear track data</p> <ol> <li> <p>Jeewajee A, Barry C, Douchamps V, Manson D, Lever C, Burgess N.     Theta phase precession of grid and place cell firing in open     environments.     Philos Trans R Soc Lond B Biol Sci. 2013 Dec 23;369(1635):20120532.     doi: 10.1098/rstb.2012.0532. ↩</p> </li> </ol>","path":["User Guide","Further usage"],"tags":[]},{"location":"utils/","level":1,"title":"Utility classes and functions","text":"<p>Add some preamble about what's in this module...</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.BinnedData","level":2,"title":"<code>ephysiopy.common.utils.BinnedData(variable: VariableToBin, map_type: MapType, binned_data: list[np.ma.MaskedArray], bin_edges: list[np.ndarray], cluster_id: list[ClusterID] = ClusterID(0, 0))</code>  <code>dataclass</code>","text":"<p>A dataclass to store binned data. The binned data is stored in a list of numpy arrays. The bin edges are stored in a list of numpy arrays. The variable to bin is stored as an instance of the VariableToBin enum. The map type is stored as an instance of the MapType enum. The binned data and bin edges are initialized as empty lists. bin_units is how to conver the binned data to \"real\" units e.g. for XY it might be how to convert to cms, for time to seconds etc. You multiply the binned data by that number to get the real values. Note that this might not make sense / be obvious for some binning (i.e. SPEED_DIR)</p> <p>The BinnedData class is the output of the main binning function in the ephysiopy.common.binning.RateMap class. It is used to store the binned data as a convenience mostly for easily iterating over the binned data and using the bin_edges to plot the data. As such, it is used as a convenience for plotting as the bin edges are used when calling pcolormesh in the plotting functions.</p> <p>Methods:</p> Name Description <code>get_cluster</code> <p>Returns the binned data for the specified cluster id</p> <code>correlate</code> <p>This method is used to correlate the binned data of this BinnedData</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.BinnedData.get_cluster","level":3,"title":"<code>get_cluster(id: ClusterID)</code>","text":"<p>Returns the binned data for the specified cluster id</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>ClusterID</code> <p>The cluster id to return</p> required <p>Returns:</p> Type Description <code>BinnedData</code> <p>A new BinnedData instance with the binned data for the specified cluster id</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.BinnedData.correlate","level":3,"title":"<code>correlate(other=None, as_matrix=False) -&gt; list[float] | np.ndarray</code>","text":"<p>This method is used to correlate the binned data of this BinnedData instance with the binned data of another BinnedData instance.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>BinnedData</code> <p>The other BinnedData instance to correlate with. If None, then correlations are performed between all the data held in the list self.binned_data</p> <code>None</code> <code>as_matrix</code> <code>bool</code> <p>If True will return the full correlation matrix for all of the correlations in the list of data in self.binned_data. If False, a list of the unique correlations for the comparisons in self.binned_data are returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>BinnedData</code> <p>A new BinnedData instance with the correlation of the binned data of this instance and the other instance.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.TrialFilter","level":2,"title":"<code>ephysiopy.common.utils.TrialFilter(name: str, start: float | str, end: float | str = None)</code>  <code>dataclass</code>","text":"<p>A basic dataclass for holding filter values</p> Notes <p>Units:     time: seconds     dir: degrees     speed: cm/s     xrange/ yrange: cm</p> <p>name : str     The name of the filter type start : float, str     start value of filter end : float, str     end value of filter</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin","level":2,"title":"<code>ephysiopy.common.utils.VariableToBin</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Holds a human readable representation of the variable being binned</p> <p>Attributes:</p> Name Type Description <code>XY</code> <code>DIR</code> <code>SPEED</code> <code>XY_TIME</code> <code>SPEED_DIR</code> <code>EGO_BOUNDARY</code> <code>TIME</code> <code>X</code> <code>Y</code> <code>PHI</code>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.XY","level":3,"title":"<code>XY = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.DIR","level":3,"title":"<code>DIR = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.SPEED","level":3,"title":"<code>SPEED = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.XY_TIME","level":3,"title":"<code>XY_TIME = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.SPEED_DIR","level":3,"title":"<code>SPEED_DIR = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.EGO_BOUNDARY","level":3,"title":"<code>EGO_BOUNDARY = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.TIME","level":3,"title":"<code>TIME = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.X","level":3,"title":"<code>X = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.Y","level":3,"title":"<code>Y = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.VariableToBin.PHI","level":3,"title":"<code>PHI = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType","level":2,"title":"<code>ephysiopy.common.utils.MapType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A human readable representation of the map type</p> <p>Attributes:</p> Name Type Description <code>RATE</code> <code>POS</code> <code>SPK</code> <code>ADAPTIVE</code> <code>AUTO_CORR</code> <code>CROSS_CORR</code>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.RATE","level":3,"title":"<code>RATE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.POS","level":3,"title":"<code>POS = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.SPK","level":3,"title":"<code>SPK = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.ADAPTIVE","level":3,"title":"<code>ADAPTIVE = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.AUTO_CORR","level":3,"title":"<code>AUTO_CORR = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.MapType.CROSS_CORR","level":3,"title":"<code>CROSS_CORR = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.ClusterID","level":2,"title":"<code>ephysiopy.common.utils.ClusterID = namedtuple('ClusterID', ['Cluster', 'Channel'])</code>  <code>module-attribute</code>","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#miscellaneous-functions","level":2,"title":"Miscellaneous functions","text":"","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.get_z_score","level":2,"title":"<code>ephysiopy.common.utils.get_z_score(x: np.ndarray, mean=None, sd=None, axis: int = 0) -&gt; np.ndarray</code>","text":"<p>Calculate the z-scores for array x based on the mean and standard deviation in that sample, unless stated</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The array to z-score</p> required <code>mean</code> <code>float</code> <p>The mean of x. Calculated from x if not provided</p> <code>None</code> <code>sd</code> <code>float</code> <p>The standard deviation of x. Calculated from x if not provided</p> <code>None</code> <code>axis</code> <code>int</code> <p>The axis along which to operate</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The z-scored version of the input array x</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.filter_trial_by_time","level":2,"title":"<code>ephysiopy.common.utils.filter_trial_by_time(duration: int | float, how: str = 'in_half') -&gt; tuple[list[TrialFilter], ...]</code>","text":"<p>Filters the data in trial by time</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int | float</code> required <code>how</code> <code>str</code> <pre><code>    Legal values: \"in_half\" or \"odd_even\"\n    \"in_half\" filters for first n seconds and last n second\n    \"odd_even\" filters for odd vs even minutes\n</code></pre> <code>'in_half'</code> <p>Returns:</p> Type Description <code>tuple of TrialFilter</code> <p>A tuple of TrialFilter instances, one for each half or odd/even minutes</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.mean_norm","level":2,"title":"<code>ephysiopy.common.utils.mean_norm(x: np.ndarray, mn=None, axis: int = 0) -&gt; np.ndarray</code>","text":"<p>Mean normalise an input array</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The array t normalise</p> required <code>mn</code> <code>float</code> <p>The mean of x</p> <code>None</code> <code>axis</code> <code>int</code> <p>The axis along which to operate</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mean normalised version of the input array</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.min_max_norm","level":2,"title":"<code>ephysiopy.common.utils.min_max_norm(x: np.ndarray, min=None, max=None, axis: int = 0) -&gt; np.ndarray</code>","text":"<p>Normalise the input array x to lie between min and max</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>the array to normalise</p> required <code>min</code> <code>float</code> <p>the minimun value in the returned array</p> <code>None</code> <code>max</code> <code>float</code> <p>the maximum value in the returned array</p> <code>None</code> <code>axis</code> <code>int</code> <p>the axis along which to operate. Default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the normalised array</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.remap_to_range","level":2,"title":"<code>ephysiopy.common.utils.remap_to_range(x: np.ndarray, new_min=0, new_max=1, axis=0) -&gt; np.ndarray</code>","text":"<p>Remap the values of x to the range [new_min, new_max].</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>the array to remap</p> required <code>new_min</code> <code>float</code> <p>the minimun value in the returned array</p> <code>0</code> <code>new_max</code> <code>float</code> <p>the maximum value in the returned array</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The remapped values</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.flatten_list","level":2,"title":"<code>ephysiopy.common.utils.flatten_list(list_to_flatten: list) -&gt; list</code>","text":"<p>Flattens a list of lists</p> <p>Parameters:</p> Name Type Description Default <code>list_to_flatten</code> <code>list</code> <p>the list to flatten</p> required <p>Returns:</p> Type Description <code>list</code> <p>The flattened list</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.smooth","level":2,"title":"<code>ephysiopy.common.utils.smooth(x, window_len=9, window='hanning')</code>","text":"<p>Smooth the data using a window with requested size.</p> <p>This method is based on the convolution of a scaled window with the signal. The signal is prepared by introducing reflected copies of the signal (with the window size) in both ends so that transient parts are minimized in the beginning and end part of the output signal.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input signal.</p> required <code>window_len</code> <code>int</code> <p>The length of the smoothing window.</p> <code>9</code> <code>window</code> <code>str</code> <p>The type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'. 'flat' window will produce a moving average smoothing.</p> <code>'hanning'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The smoothed signal.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t=linspace(-2,2,0.1)\n&gt;&gt;&gt; x=sin(t)+randn(len(t))*0.1\n&gt;&gt;&gt; y=smooth(x)\n</code></pre> See Also <p>numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve, scipy.signal.lfilter</p> Notes <p>The window parameter could be the window itself if an array instead of a string.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.blur_image","level":2,"title":"<code>ephysiopy.common.utils.blur_image(im: BinnedData, n: int, ny: int = 0, ftype: str = 'boxcar', **kwargs) -&gt; BinnedData</code>","text":"<p>Smooths all the binned_data in an instance of BinnedData by convolving with a filter.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>BinnedData</code> <p>Contains the array to smooth.</p> required <code>n</code> <code>int</code> <p>The size of the smoothing kernel.</p> required <code>ny</code> <code>int</code> <p>The size of the smoothing kernel.</p> required <code>ftype</code> <code>str</code> <p>The type of smoothing kernel. Either 'boxcar' or 'gaussian'.</p> <code>'boxcar'</code> <p>Returns:</p> Type Description <code>BinnedData</code> <p>BinnedData instance with the smoothed data.</p> Notes <p>This essentially does the smoothing in-place</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.shift_vector","level":2,"title":"<code>ephysiopy.common.utils.shift_vector(v, shift, maxlen=None)</code>","text":"<p>Shifts the elements of a vector by a given amount. A bit like numpys roll function but when the shift goes beyond some limit that limit is subtracted from the shift. The result is then sorted and returned.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array_like</code> <p>The input vector.</p> required <code>shift</code> <code>int</code> <p>The amount to shift the elements.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The shifted vector.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.count_to","level":2,"title":"<code>ephysiopy.common.utils.count_to(n: np.ndarray) -&gt; np.ndarray</code>","text":"<p>This function is equivalent to hstack((arange(n_i) for n_i in n)). It seems to be faster for some possible inputs and encapsulates a task in a function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; n = np.array([0, 0, 3, 0, 0, 2, 0, 2, 1])\n&gt;&gt;&gt; count_to(n)\narray([0, 1, 2, 0, 1, 0, 1, 0])\n</code></pre>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.window_rms","level":2,"title":"<code>ephysiopy.common.utils.window_rms(a: np.ndarray, window_size: int | float) -&gt; np.ndarray</code>","text":"<p>Calculates the root mean square of the input a over a window of size window_size</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>The input array</p> required <code>window_size</code> <code>(int, float)</code> <p>The size of the smoothing window</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The rms'd result</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.find_runs","level":2,"title":"<code>ephysiopy.common.utils.find_runs(x)</code>","text":"<p>Find runs of consecutive items in an array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>(ndarray, list)</code> <p>The array to search for runs in</p> required <p>Returns:</p> Name Type Description <code>run_values</code> <code>ndarray</code> <p>the values of each run</p> <code>run_starts</code> <code>ndarray</code> <p>the indices into x at which each run starts</p> <code>run_lengths</code> <code>ndarray</code> <p>The length of each run</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; n = np.array([0, 0, 3, 3, 0, 2, 0,0, 1])\n&gt;&gt;&gt; find_runs(n)\n(array([0, 3, 0, 2, 0, 1]),\narray([0, 2, 4, 5, 6, 8]),\narray([2, 2, 1, 1, 2, 1]))\n</code></pre> Notes <p>Taken from: https://gist.github.com/alimanfoo/c5977e87111abe8127453b21204c1065</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.repeat_ind","level":2,"title":"<code>ephysiopy.common.utils.repeat_ind(n: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Repeat a given index a specified number of times.</p> <p>The input specifies how many times to repeat the given index. It is equivalent to something like this:</p> <p>hstack((zeros(n_i,dtype=int)+i for i, n_i in enumerate(n)))</p> <p>But this version seems to be faster, and probably scales better. At any rate, it encapsulates a task in a function.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>ndarray</code> <p>A 1D array where each element specifies the number of times to repeat its index.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 1D array with indices repeated according to the input array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; n = np.array([0, 0, 3, 0, 0, 2, 0, 2, 1])\n&gt;&gt;&gt; repeat_ind(n)\narray([2, 2, 2, 5, 5, 7, 7, 8])\n</code></pre>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.rect","level":2,"title":"<code>ephysiopy.common.utils.rect(r, w, deg=False)</code>","text":"<p>Convert from polar (r, w) to rectangular (x, y) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float or ndarray</code> <p>Radial coordinate(s).</p> required <code>w</code> <code>float or ndarray</code> <p>Angular coordinate(s).</p> required <code>deg</code> <code>bool</code> <p>If True, <code>w</code> is in degrees. Default is False (radians).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing: - x : float or np.ndarray     X coordinate(s). - y : float or np.ndarray     Y coordinate(s).</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.polar","level":2,"title":"<code>ephysiopy.common.utils.polar(x, y, deg=False)</code>","text":"<p>Converts from rectangular coordinates to polar ones.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>The x coordinates.</p> required <code>y</code> <code>array_like</code> <p>The y coordinates.</p> required <code>deg</code> <code>bool</code> <p>If True, returns the angle in degrees. Default is False (radians).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>r</code> <code>array_like</code> <p>The radial coordinates.</p> <code>theta</code> <code>array_like</code> <p>The angular coordinates.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.labelledCumSum","level":2,"title":"<code>ephysiopy.common.utils.labelledCumSum(X, L)</code>","text":"<p>Compute the cumulative sum of an array with labels, resetting the sum at label changes.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Input array to compute the cumulative sum.</p> required <code>L</code> <code>ndarray</code> <p>Label array indicating where to reset the cumulative sum.</p> required <p>Returns:</p> Type Description <code>MaskedArray</code> <p>The cumulative sum array with resets at label changes, masked appropriately.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.cart2pol","level":2,"title":"<code>ephysiopy.common.utils.cart2pol(x, y)</code>","text":"<p>Convert Cartesian coordinates to polar coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> <p>X coordinate(s).</p> required <code>y</code> <code>float or ndarray</code> <p>Y coordinate(s).</p> required <p>Returns:</p> Name Type Description <code>r</code> <code>float or ndarray</code> <p>Radial coordinate(s).</p> <code>th</code> <code>float or ndarray</code> <p>Angular coordinate(s) in radians.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.pol2cart","level":2,"title":"<code>ephysiopy.common.utils.pol2cart(r, theta)</code>","text":"<p>Convert polar coordinates to Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float or ndarray</code> <p>Radial coordinate(s).</p> required <code>theta</code> <code>float or ndarray</code> <p>Angular coordinate(s) in radians.</p> required <p>Returns:</p> Name Type Description <code>x</code> <code>float or ndarray</code> <p>X coordinate(s).</p> <code>y</code> <code>float or ndarray</code> <p>Y coordinate(s).</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.applyFilter2Labels","level":2,"title":"<code>ephysiopy.common.utils.applyFilter2Labels(M, x)</code>","text":"<p>M is a logical mask specifying which label numbers to keep x is an array of positive integer labels</p> <p>This method sets the undesired labels to 0 and renumbers the remaining labels 1 to n when n is the number of trues in M</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.getLabelStarts","level":2,"title":"<code>ephysiopy.common.utils.getLabelStarts(x)</code>","text":"<p>Get the indices of the start of contiguous runs of non-zero values in a 1D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input 1D numpy array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of indices marking the start of each contiguous run of non-zero values.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.getLabelEnds","level":2,"title":"<code>ephysiopy.common.utils.getLabelEnds(x)</code>","text":"<p>Get the indices of the end of contiguous runs of non-zero values in a 1D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input 1D numpy array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of indices marking the end of each contiguous run of non-zero values.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.circ_abs","level":2,"title":"<code>ephysiopy.common.utils.circ_abs(x)</code>","text":"<p>Calculate the absolute value of an angle in radians, normalized to the range [-pi, pi].</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> <p>Angle(s) in radians.</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Absolute value of the angle(s) normalized to the range [-pi, pi].</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.labelContigNonZeroRuns","level":2,"title":"<code>ephysiopy.common.utils.labelContigNonZeroRuns(x)</code>","text":"<p>Label contiguous non-zero runs in a 1D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input 1D numpy array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array where each element is labeled with an integer representing the contiguous non-zero run it belongs to.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.fixAngle","level":2,"title":"<code>ephysiopy.common.utils.fixAngle(a)</code>","text":"<p>Ensure angles lie between -pi and pi.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float or ndarray</code> <p>Angle(s) in radians.</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Angle(s) normalized to the range [-pi, pi].</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.bwperim","level":2,"title":"<code>ephysiopy.common.utils.bwperim(bw, n=4)</code>","text":"<p>Finds the perimeter of objects in binary images.</p> <p>A pixel is part of an object perimeter if its value is one and there is at least one zero-valued pixel in its neighborhood.</p> <p>By default, the neighborhood of a pixel is 4 nearest pixels, but if <code>n</code> is set to 8, the 8 nearest pixels will be considered.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>array_like</code> <p>A black-and-white image.</p> required <code>n</code> <code>int</code> <p>Connectivity. Must be 4 or 8. Default is 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>perim</code> <code>array_like</code> <p>A boolean image.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.count_runs_and_unique_numbers","level":2,"title":"<code>ephysiopy.common.utils.count_runs_and_unique_numbers(arr: np.ndarray) -&gt; tuple</code>","text":"<p>Counts the number of continuous runs of numbers in a 1D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The input 1D numpy array of numbers.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing: - dict: A dictionary with the count of runs for each unique number. - set: The set of unique numbers in the array.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"utils/#ephysiopy.common.utils.corr_maps","level":2,"title":"<code>ephysiopy.common.utils.corr_maps(map1, map2, maptype='normal') -&gt; float</code>","text":"<p>Correlates two rate maps together, ignoring areas that have zero sampling.</p> <p>Parameters:</p> Name Type Description Default <code>map1</code> <code>ndarray</code> <p>The first rate map to correlate.</p> required <code>map2</code> <code>ndarray</code> <p>The second rate map to correlate.</p> required <code>maptype</code> <code>str</code> <p>The type of correlation to perform. Options are \"normal\" and \"grid\". Default is \"normal\".</p> <code>'normal'</code> <p>Returns:</p> Type Description <code>float</code> <p>The correlation coefficient between the two rate maps.</p> Notes <p>If the shapes of the input maps are different, the smaller map will be resized to match the shape of the larger map using reflection mode.</p> <p>The \"normal\" maptype considers non-zero and non-NaN values for correlation, while the \"grid\" maptype considers only finite values.</p>","path":["API reference","Utility classes and functions"],"tags":[]},{"location":"what_is_ephysiopy/","level":1,"title":"What is ephysiopy?","text":"<p>ephysiopy is a Python package for the analysis of electrophysiological data collected with the Axona or openephys recording systems. It provides a unifying set of tools for the analysis of electrophysiological data recorded using tetrode or Neuropixels (LINK).</p> <p>It can load the data and so some plotting and analysis too.</p> <p>What it isn't is a way to pre-process data (drift correction etc) or to do spike sorting.</p> <p>There are some excellent tools for that already, and ephysiopy is designed to work with the output of those tools, not to replace them.</p> <p>There are many spike sorting tools available, KiloSort is popular among Neuropixels users, but there are many others (LINKS)</p> <p>Although there are some methods in ephysiopy for visualising spike waveforms, auto- and cross-correlograms and so on it is not supposed to be a replacement for tools like phy or SpikeInterface</p> <p>Iniitially, it was a collection of functions and scripts for loading and analysing data from the Axona system, but over time grew to encompass data from the OpenEphys system. That led to the development of an interface class (TrialInterface) to provide a common set of methods for loading, plotting and analysing the data regardless of the recording system used. It should therefore be possible to extend that interface for other recording systems in the future, if there is demand for that.</p>","path":["User Guide","What is ephysiopy?"],"tags":[]}]}